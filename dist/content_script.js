/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/ext/content_script/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/aes-js/index.js":
/*!**************************************!*\
  !*** ./node_modules/aes-js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
(function(root) {
    "use strict";

    function checkInt(value) {
        return (parseInt(value) === value);
    }

    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) { return false; }

        for (var i = 0; i < arrayish.length; i++) {
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                return false;
            }
        }

        return true;
    }

    function coerceArray(arg, copy) {

        // ArrayBuffer view
        if (arg.buffer && arg.name === 'Uint8Array') {

            if (copy) {
                if (arg.slice) {
                    arg = arg.slice();
                } else {
                    arg = Array.prototype.slice.call(arg);
                }
            }

            return arg;
        }

        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
                throw new Error('Array contains invalid value: ' + arg);
            }

            return new Uint8Array(arg);
        }

        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
        }

        throw new Error('unsupported array-like object');
    }

    function createArray(length) {
        return new Uint8Array(length);
    }

    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
        }
        targetArray.set(sourceArray, targetStart);
    }



    var convertUtf8 = (function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while (i < text.length) {
                var c = text.charCodeAt(i++);

                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16))
                    i += 2;

                // otherwise, just the actual byte
                } else {
                    result.push(c)
                }
            }

            return coerceArray(result);
        }

        function fromBytes(bytes) {
            var result = [], i = 0;

            while (i < bytes.length) {
                var c = bytes[i];

                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                    i += 2;
                } else {
                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                    i += 3;
                }
            }

            return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();

    var convertHex = (function() {
        function toBytes(text) {
            var result = [];
            for (var i = 0; i < text.length; i += 2) {
                result.push(parseInt(text.substr(i, 2), 16));
            }

            return result;
        }

        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = '0123456789abcdef';

        function fromBytes(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i++) {
                    var v = bytes[i];
                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                }
                return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();


    // Number of rounds by keysize
    var numberOfRounds = {16: 10, 24: 12, 32: 14}

    // Round constant words
    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

    // S-box and Inverse S-box (S is for Substitution)
    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

    // Transformations for encryption
    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

    // Transformations for decryption
    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

    // Transformations for decryption key expansion
    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

    function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
            result.push(
                (bytes[i    ] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] <<  8) |
                 bytes[i + 3]
            );
        }
        return result;
    }

    var AES = function(key) {
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }

        Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
        });

        this._prepare();
    }


    AES.prototype._prepare = function() {

        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
        }

        // encryption round keys
        this._Ke = [];

        // decryption round keys
        this._Kd = [];

        for (var i = 0; i <= rounds; i++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
        }

        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;

        // convert the key into ints
        var tk = convertToInt32(this.key);

        // copy values into round key arrays
        var index;
        for (var i = 0; i < KC; i++) {
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }

        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                      (S[(tt >>  8) & 0xFF] << 16) ^
                      (S[ tt        & 0xFF] <<  8) ^
                       S[(tt >> 24) & 0xFF]        ^
                      (rcon[rconpointer] << 24));
            rconpointer += 1;

            // key expansion (for non-256 bit)
            if (KC != 8) {
                for (var i = 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }

            // key expansion for 256-bit keys is "slightly different" (fips-197)
            } else {
                for (var i = 1; i < (KC / 2); i++) {
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[(KC / 2) - 1];

                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                              (S[(tt >>  8) & 0xFF] <<  8) ^
                              (S[(tt >> 16) & 0xFF] << 16) ^
                              (S[(tt >> 24) & 0xFF] << 24));

                for (var i = (KC / 2) + 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
            }

            // copy values into round key arrays
            var i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }

        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for (var r = 1; r < rounds; r++) {
            for (var c = 0; c < 4; c++) {
                tt = this._Kd[r][c];
                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                                  U2[(tt >> 16) & 0xFF] ^
                                  U3[(tt >>  8) & 0xFF] ^
                                  U4[ tt        & 0xFF]);
            }
        }
    }

    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
        }

        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Ke[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T4[ t[(i + 3) % 4]        & 0xff] ^
                        this._Ke[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Ke[rounds][i];
            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }

    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
        }

        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Kd[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T8[ t[(i + 1) % 4]        & 0xff] ^
                        this._Kd[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Kd[rounds][i];
            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }


    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */
    var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Electronic Code Block";
        this.name = "ecb";

        this._aes = new AES(key);
    }

    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */
    var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Block Chaining";
        this.name = "cbc";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastCipherblock = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);

            for (var j = 0; j < 16; j++) {
                block[j] ^= this._lastCipherblock[j];
            }

            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);

            for (var j = 0; j < 16; j++) {
                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }

            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */
    var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Feedback";
        this.name = "cfb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
        }

        if (!segmentSize) { segmentSize = 1; }

        this.segmentSize = segmentSize;

        this._shiftRegister = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if ((plaintext.length % this.segmentSize) != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
        }

        var encrypted = coerceArray(plaintext, true);

        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j = 0; j < this.segmentSize; j++) {
                encrypted[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return encrypted;
    }

    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if ((ciphertext.length % this.segmentSize) != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        }

        var plaintext = coerceArray(ciphertext, true);

        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
                plaintext[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return plaintext;
    }

    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */
    var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Output Feedback";
        this.name = "ofb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


    /**
     *  Counter object for CTR common mode of operation
     */
    var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
        }

        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

        if (typeof(initialValue) === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);

        } else {
            this.setBytes(initialValue);
        }
    }

    Counter.prototype.setValue = function(value) {
        if (typeof(value) !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
        }

        // We cannot safely handle numbers beyond the safe range for integers
        if (value > Number.MAX_SAFE_INTEGER) {
            throw new Error('integer value out of safe range');
        }

        for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = parseInt(value / 256);
        }
    }

    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);

        if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
        }

        this._counter = bytes;
    };

    Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            } else {
                this._counter[i]++;
                break;
            }
        }
    }


    /**
     *  Mode Of Operation - Counter (CTR)
     */
    var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Counter";
        this.name = "ctr";

        if (!(counter instanceof Counter)) {
            counter = new Counter(counter)
        }

        this._counter = counter;

        this._remainingCounter = null;
        this._remainingCounterIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


    ///////////////////////
    // Padding

    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - (data.length % 16);
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
            result[i] = padder;
        }
        return result;
    }

    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

        var padder = data[data.length - 1];
        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
                throw new Error('PKCS#7 invalid padding byte');
            }
        }

        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }

    ///////////////////////
    // Exporting


    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,

        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },

        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },

        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },

        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray,
        }
    };


    // node.js
    if (true) {
        module.exports = aesjs

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}


})(this);


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-hash/make-hash.js":
/*!***********************************************!*\
  !*** ./node_modules/create-hash/make-hash.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var intSize = 4
var zeroBuffer = new Buffer(intSize)
zeroBuffer.fill(0)

var charSize = 8
var hashSize = 16

function toArray (buf) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize))
    buf = Buffer.concat([buf, zeroBuffer], len)
  }

  var arr = new Array(buf.length >>> 2)
  for (var i = 0, j = 0; i < buf.length; i += intSize, j++) {
    arr[j] = buf.readInt32LE(i)
  }

  return arr
}

module.exports = function hash (buf, fn) {
  var arr = fn(toArray(buf), buf.length * charSize)
  buf = new Buffer(hashSize)
  for (var i = 0; i < arr.length; i++) {
    buf.writeInt32LE(arr[i], i << 2, true)
  }
  return buf
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var makeHash = __webpack_require__(/*! ./make-hash */ "./node_modules/create-hash/make-hash.js")

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5 (x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32)
  x[(((len + 64) >>> 9) << 4) + 14] = len

  var a = 1732584193
  var b = -271733879
  var c = -1732584194
  var d = 271733878

  for (var i = 0; i < x.length; i += 16) {
    var olda = a
    var oldb = b
    var oldc = c
    var oldd = d

    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936)
    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)
    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)
    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)
    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)
    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)
    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)
    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)
    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)
    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)
    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)
    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)
    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)
    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)
    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)
    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)

    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)
    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)
    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)
    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302)
    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)
    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)
    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)
    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)
    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)
    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)
    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)
    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)
    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)
    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)
    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)
    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)

    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)
    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)
    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)
    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)
    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)
    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)
    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)
    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)
    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)
    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222)
    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)
    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)
    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)
    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)
    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)
    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)

    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844)
    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)
    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)
    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)
    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)
    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)
    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)
    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)
    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)
    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)
    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)
    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)
    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)
    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)
    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)
    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)

    a = safe_add(a, olda)
    b = safe_add(b, oldb)
    c = safe_add(c, oldc)
    d = safe_add(d, oldd)
  }

  return [a, b, c, d]
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn (q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
}

function md5_ff (a, b, c, d, x, s, t) {
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
}

function md5_gg (a, b, c, d, x, s, t) {
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
}

function md5_hh (a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t)
}

function md5_ii (a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add (x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF)
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
  return (msw << 16) | (lsw & 0xFFFF)
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

module.exports = function md5 (buf) {
  return makeHash(buf, core_md5)
}


/***/ }),

/***/ "./node_modules/dom-element-is-natively-editable/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/dom-element-is-natively-editable/index.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (element) {
  if (
    element.ownerDocument.designMode &&
    element.ownerDocument.designMode.toLowerCase() === 'on'
  ) {
    return true
  }

  switch (element.tagName.toLowerCase()) {
    case 'input':
      return isEditableInput(element)
    case 'textarea':
      return true
  }

  if (isContentEditable(element)) {
    return true
  }

  return false
});

function isContentEditable (element) {
  if (
    element.contentEditable &&
    element.contentEditable.toLowerCase() === 'true'
  ) {
    return true
  }
  if (
    element.contentEditable &&
    element.contentEditable.toLowerCase() === 'inherit' &&
    element.parentNode
  ) {
    return isContentEditable(element.parentNode)
  }
  return false
}

function isEditableInput (input) {
  switch (input.type) {
    case 'text':
      return true
    case 'email':
      return true
    case 'password':
      return true
    case 'search':
      return true
    case 'tel':
      return true
    case 'url':
      return true
    default:
      return false
  }
}


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function HashBase (blockSize) {
  Transform.call(this)

  this._block = new Buffer(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    if (encoding !== 'buffer') chunk = new Buffer(chunk, encoding)
    this.update(chunk)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this._digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || 'binary')

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function (data) {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)
  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/idb.filesystem.js/src/idb.filesystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/idb.filesystem.js/src/idb.filesystem.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013 - Eric Bidelman
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.

 * @fileoverview
 * A polyfill implementation of the HTML5 Filesystem API which sits on top of
 * IndexedDB as storage layer. Files and folders are stored as FileEntry and
 * FolderEntry objects in a single object store. IDBKeyRanges are used to query
 * into a folder. A single object store is sufficient because we can utilize the
 * properties of ASCII. Namely, ASCII / is followed by ASCII 0. Thus,
 * "/one/two/" comes before "/one/two/ANYTHING" comes before "/one/two/0".
 *
 * @author Eric Bidelman (ebidel@gmail.com)
 */



(function(exports) {

// Bomb out if the Filesystem API is available natively.
if (exports.requestFileSystem || exports.webkitRequestFileSystem) {
  return;
}

// Bomb out if no indexedDB available
const indexedDB = exports.indexedDB || exports.mozIndexedDB ||
                  exports.msIndexedDB;
if (!indexedDB) {
  return;
}

let IDB_SUPPORTS_BLOB = true;

// Check to see if IndexedDB support blobs.
const support = new function() {
  var dbName = "blob-support";
  indexedDB.deleteDatabase(dbName).onsuccess = function() {
    var request = indexedDB.open(dbName, 1);
    request.onerror = function() {
      IDB_SUPPORTS_BLOB = false;
    };
    request.onsuccess = function() {
      var db = request.result;
      try {
        var blob = new Blob(["test"], {type: "text/plain"});
        var transaction = db.transaction("store", "readwrite");
        transaction.objectStore("store").put(blob, "key");
        IDB_SUPPORTS_BLOB = true;
      } catch (err) {
        IDB_SUPPORTS_BLOB = false;
      } finally {
        db.close();
        indexedDB.deleteDatabase(dbName);
      }
    };
    request.onupgradeneeded = function() {
      request.result.createObjectStore("store");
    };
  };
};

const Base64ToBlob = function(dataURL) {
  var BASE64_MARKER = ';base64,';
  if (dataURL.indexOf(BASE64_MARKER) == -1) {
    var parts = dataURL.split(',');
    var contentType = parts[0].split(':')[1];
    var raw = decodeURIComponent(parts[1]);

    return new Blob([raw], {type: contentType});
  }

  var parts = dataURL.split(BASE64_MARKER);
  var contentType = parts[0].split(':')[1];
  var raw = window.atob(parts[1]);
  var rawLength = raw.length;

  var uInt8Array = new Uint8Array(rawLength);

  for (var i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }

  return new Blob([uInt8Array], {type: contentType});
};

const BlobToBase64 = function(blob, onload) {
  var reader = new FileReader();
  reader.readAsDataURL(blob);
  reader.onloadend = function() {
    onload(reader.result);
  };
};

if (!exports.PERSISTENT) {
  exports.TEMPORARY = 0;
  exports.PERSISTENT = 1;
}

// Prevent errors in browsers that don't support FileError.
// TODO: FF 13+ supports DOM4 Events (DOMError). Use them instead?
if (exports.FileError === undefined) {
  window.FileError = function() {};
  FileError.prototype.prototype = Error.prototype;
}

if (!FileError.INVALID_MODIFICATION_ERR) {
  FileError.INVALID_MODIFICATION_ERR = 9;
  FileError.NOT_FOUND_ERR  = 1;
}

function MyFileError(obj) {
  var code_ = obj.code;
  var name_ = obj.name;

    // Required for FF 11.
  Object.defineProperty(this, 'code', {
    set: function(code) {
      code_ = code;
    },
    get: function() {
      return code_;
    }
  });

  Object.defineProperty(this, 'name', {
    set: function(name) {
      name_ = name;
    },
    get: function() {
      return name_;
    }
  });
}

MyFileError.prototype = FileError.prototype;
MyFileError.prototype.toString = Error.prototype.toString;

const INVALID_MODIFICATION_ERR = new MyFileError({
      code: FileError.INVALID_MODIFICATION_ERR,
      name: 'INVALID_MODIFICATION_ERR'});
const NOT_IMPLEMENTED_ERR = new MyFileError({code: 1000,
                                             name: 'Not implemented'});
const NOT_FOUND_ERR = new MyFileError({code: FileError.NOT_FOUND_ERR,
                                       name: 'Not found'});

let fs_ = null;

// Browsers other than Chrome don't implement persistent vs. temporary storage.
// but default to temporary anyway.
let storageType_ = 'temporary';
const idb_ = {db: null};
const FILE_STORE_ = 'entries';

const DIR_SEPARATOR = '/';
const DIR_OPEN_BOUND = String.fromCharCode(DIR_SEPARATOR.charCodeAt(0) + 1);

// When saving an entry, the fullPath should always lead with a slash and never
// end with one (e.g. a directory). Also, resolve '.' and '..' to an absolute
// one. This method ensures path is legit!
function resolveToFullPath_(cwdFullPath, path) {
  var fullPath = path;

  var relativePath = path[0] != DIR_SEPARATOR;
  if (relativePath) {
    fullPath = cwdFullPath + DIR_SEPARATOR + path;
  }

  // Normalize '.'s,  '..'s and '//'s.
  var parts = fullPath.split(DIR_SEPARATOR);
  var finalParts = [];
  for (var i = 0; i < parts.length; ++i) {
    var part = parts[i];
    if (part === '..') {
      // Go up one level.
      if (!finalParts.length) {
        throw Error('Invalid path');
      }
      finalParts.pop();
    } else if (part === '.') {
      // Skip over the current directory.
    } else if (part !== '') {
      // Eliminate sequences of '/'s as well as possible leading/trailing '/'s.
      finalParts.push(part);
    }
  }

  fullPath = DIR_SEPARATOR + finalParts.join(DIR_SEPARATOR);

  // fullPath is guaranteed to be normalized by construction at this point:
  // '.'s, '..'s, '//'s will never appear in it.

  return fullPath;
}

// // Path can be relative or absolute. If relative, it's taken from the cwd_.
// // If a filesystem URL is passed it, it is simple returned
// function pathToFsURL_(path) {
//   path = resolveToFullPath_(cwdFullPath, path);
//   path = fs_.root.toURL() + path.substring(1);
//   return path;
// };

/**
 * Interface to wrap the native File interface.
 *
 * This interface is necessary for creating zero-length (empty) files,
 * something the Filesystem API allows you to do. Unfortunately, File's
 * constructor cannot be called directly, making it impossible to instantiate
 * an empty File in JS.
 *
 * @param {Object} opts Initial values.
 * @constructor
 */
function MyFile(opts) {
  var blob_ = null;

  this.size = opts.size || 0;
  this.name = opts.name || '';
  this.type = opts.type || '';
  this.lastModifiedDate = opts.lastModifiedDate || null;
  //this.slice = Blob.prototype.slice; // Doesn't work with structured clones.

  // Need some black magic to correct the object's size/name/type based on the
  // blob that is saved.
  Object.defineProperty(this, 'blob_', {
    enumerable: true,
    get: function() {
      return blob_;
    },
    set: function (val) {
      blob_ = val;
      this.size = blob_.size;
      this.name = blob_.name;
      this.type = blob_.type;
      this.lastModifiedDate = blob_.lastModifiedDate;
    }.bind(this)
  });
}
MyFile.prototype.constructor = MyFile;
//MyFile.prototype.slice = Blob.prototype.slice;

/**
 * Interface to writing a Blob/File.
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/file-writer.html#the-filewriter-interface
 *
 * @param {FileEntry} fileEntry The FileEntry associated with this writer.
 * @constructor
 */
function FileWriter(fileEntry) {
  if (!fileEntry) {
    throw Error('Expected fileEntry argument to write.');
  }

  var position_ = 0;
  var blob_ = fileEntry.file_ ? fileEntry.file_.blob_ : null;

  Object.defineProperty(this, 'position', {
    get: function() {
      return position_;
    }
  });

  Object.defineProperty(this, 'length', {
    get: function() {
      return blob_ ? blob_.size : 0;
    }
  });

  this.seek = function(offset) {
    position_ = offset;

    if (position_ > this.length) {
      position_ = this.length;
    }
    if (position_ < 0) {
      position_ += this.length;
    }
    if (position_ < 0) {
      position_ = 0;
    }
  };

  this.truncate = function(size) {
    if (blob_) {
      if (size < this.length) {
        blob_ = blob_.slice(0, size);
      } else {
        blob_ = new Blob([blob_, new Uint8Array(size - this.length)],
                         {type: blob_.type});
      }
    } else {
      blob_ = new Blob([]);
    }

    position_ = 0; // truncate from beginning of file.

    this.write(blob_); // calls onwritestart and onwriteend.
  };

  this.write = function(data) {
    if (!data) {
      throw Error('Expected blob argument to write.');
    }

    // Call onwritestart if it was defined.
    if (this.onwritestart) {
      this.onwritestart();
    }

    // TODO: not handling onprogress, onwrite, onabort. Throw an error if
    // they're defined.

    if (blob_) {
      // Calc the head and tail fragments
      var head = blob_.slice(0, position_);
      var tail = blob_.slice(position_ + data.size);

      // Calc the padding
      var padding = position_ - head.size;
      if (padding < 0) {
        padding = 0;
      }

      // Do the "write". In fact, a full overwrite of the Blob.
      // TODO: figure out if data.type should overwrite the exist blob's type.
      blob_ = new Blob([head, new Uint8Array(padding), data, tail],
                       {type: blob_.type});
    } else {
      blob_ = new Blob([data], {type: data.type});
    }

    const writeFile = function(blob) {
      // Blob might be a DataURI depending on browser support.
      fileEntry.file_.blob_ = blob;
      fileEntry.file_.lastModifiedDate = data.lastModifiedDate || new Date();
      idb_.put(fileEntry, function(entry) {
        if (!IDB_SUPPORTS_BLOB) {
          // Set the blob we're writing on this file entry so we can recall it later.
          fileEntry.file_.blob_ = blob_;
          fileEntry.file_.lastModifiedDate = data.lastModifiedDate || null;
        }

        // Add size of data written to writer.position.
        position_ += data.size;

        if (this.onwriteend) {
          this.onwriteend();
        }
      }.bind(this), this.onerror);
    }.bind(this);

    if (IDB_SUPPORTS_BLOB) {
      writeFile(blob_);
    } else {
      BlobToBase64(blob_, writeFile);
    }
  };
}


/**
 * Interface for listing a directory's contents (files and folders).
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/pub/FileSystem/#idl-def-DirectoryReader
 *
 * @constructor
 */
function DirectoryReader(dirEntry) {
  var dirEntry_ = dirEntry;
  var used_ = false;

  this.readEntries = function(successCallback, opt_errorCallback) {
    if (!successCallback) {
      throw Error('Expected successCallback argument.');
    }

    // This is necessary to mimic the way DirectoryReader.readEntries() should
    // normally behavior.  According to spec, readEntries() needs to be called
    // until the length of result array is 0. To handle someone implementing
    // a recursive call to readEntries(), get everything from indexedDB on the
    // first shot. Then (DirectoryReader has been used), return an empty
    // result array.
    if (!used_) {
      idb_.getAllEntries(dirEntry_.fullPath, function(entries) {
        used_= true;
        successCallback(entries);
      }, opt_errorCallback);
    } else {
      successCallback([]);
    }
  };
};

/**
 * Interface supplies information about the state of a file or directory.
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/file-dir-sys.html#idl-def-Metadata
 *
 * @constructor
 */
function Metadata(modificationTime, size) {
  this.modificationTime_ = modificationTime || null;
  this.size_ = size || 0;
}

Metadata.prototype = {
  get modificationTime() {
    return this.modificationTime_;
  },
  get size() {
    return this.size_;
  }
}

/**
 * Interface representing entries in a filesystem, each of which may be a File
 * or DirectoryEntry.
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/pub/FileSystem/#idl-def-Entry
 *
 * @constructor
 */
function Entry() {}

Entry.prototype = {
  name: null,
  fullPath: null,
  filesystem: null,
  copyTo: function() {
    throw NOT_IMPLEMENTED_ERR;
  },
  getMetadata: function(successCallback, opt_errorCallback) {
    if (!successCallback) {
      throw Error('Expected successCallback argument.');
    }

    try {
      if (this.isFile) {
        successCallback(
            new Metadata(this.file_.lastModifiedDate, this.file_.size));
      } else {
        opt_errorCallback(new MyFileError({code: 1001,
            name: 'getMetadata() not implemented for DirectoryEntry'}));
      }
    } catch(e) {
      opt_errorCallback && opt_errorCallback(e);
    }
  },
  getParent: function() {
    throw NOT_IMPLEMENTED_ERR;
  },
  moveTo: function() {
    throw NOT_IMPLEMENTED_ERR;
  },
  remove: function(successCallback, opt_errorCallback) {
    if (!successCallback) {
      throw Error('Expected successCallback argument.');
    }
    // TODO: This doesn't protect against directories that have content in it.
    // Should throw an error instead if the dirEntry is not empty.
    idb_['delete'](this.fullPath, function() {
      successCallback();
    }, opt_errorCallback);
  },
  toURL: function() {
    var origin = location.protocol + '//' + location.host;
    return 'filesystem:' + origin + DIR_SEPARATOR + storageType_.toLowerCase() +
           this.fullPath;
  },
};

/**
 * Interface representing a file in the filesystem.
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/pub/FileSystem/#the-fileentry-interface
 *
 * @param {FileEntry} opt_fileEntry Optional FileEntry to initialize this
 *     object from.
 * @constructor
 * @extends {Entry}
 */
function FileEntry(opt_fileEntry) {
  this.file_ = null;

  Object.defineProperty(this, 'isFile', {
    enumerable: true,
    get: function() {
      return true;
    }
  });
  Object.defineProperty(this, 'isDirectory', {
    enumerable: true,
    get: function() {
      return false;
    }
  });

  // Create this entry from properties from an existing FileEntry.
  if (opt_fileEntry) {
    this.file_ = opt_fileEntry.file_;
    this.name = opt_fileEntry.name;
    this.fullPath = opt_fileEntry.fullPath;
    this.filesystem = opt_fileEntry.filesystem;
    if (typeof(this.file_.blob_) === "string") {
      this.file_.blob_ = Base64ToBlob(this.file_.blob_);
    }
  }
}
FileEntry.prototype = new Entry();
FileEntry.prototype.constructor = FileEntry;
FileEntry.prototype.createWriter = function(callback) {
  // TODO: figure out if there's a way to dispatch onwrite event as we're writing
  // data to IDB. Right now, we're only calling onwritend/onerror
  // FileEntry.write().
  callback(new FileWriter(this));
};
FileEntry.prototype.file = function(successCallback, opt_errorCallback) {
  if (!successCallback) {
    throw Error('Expected successCallback argument.');
  }

  if (this.file_ == null) {
    if (opt_errorCallback) {
      opt_errorCallback(NOT_FOUND_ERR);
    } else {
      throw NOT_FOUND_ERR;
    }
    return;
  }

  // If we're returning a zero-length (empty) file, return the fake file obj.
  // Otherwise, return the native File object that we've stashed.
  var file = this.file_.blob_ == null ? this.file_ : this.file_.blob_;
  file.lastModifiedDate = this.file_.lastModifiedDate;

  // Add Blob.slice() to this wrapped object. Currently won't work :(
  /*if (!val.slice) {
    val.slice = Blob.prototype.slice; // Hack to add back in .slice().
  }*/
  successCallback(file);
};

/**
 * Interface representing a directory in the filesystem.
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/pub/FileSystem/#the-directoryentry-interface
 *
 * @param {DirectoryEntry} opt_folderEntry Optional DirectoryEntry to
 *     initialize this object from.
 * @constructor
 * @extends {Entry}
 */
function DirectoryEntry(opt_folderEntry) {
  Object.defineProperty(this, 'isFile', {
    enumerable: true,
    get: function() {
      return false;
    }
  });
  Object.defineProperty(this, 'isDirectory', {
    enumerable: true,
    get: function() {
      return true;
    }
  });

  // Create this entry from properties from an existing DirectoryEntry.
  if (opt_folderEntry) {
    this.name = opt_folderEntry.name;
    this.fullPath = opt_folderEntry.fullPath;
    this.filesystem = opt_folderEntry.filesystem;
  }
}
DirectoryEntry.prototype = new Entry();
DirectoryEntry.prototype.constructor = DirectoryEntry;
DirectoryEntry.prototype.createReader = function() {
  return new DirectoryReader(this);
};
DirectoryEntry.prototype.getDirectory = function(path, options, successCallback,
                                                 opt_errorCallback) {

  // Create an absolute path if we were handed a relative one.
  path = resolveToFullPath_(this.fullPath, path);

  idb_.get(path, function(folderEntry) {
    if (!options) {
      options = {};
    }

    if (options.create === true && options.exclusive === true && folderEntry) {
      // If create and exclusive are both true, and the path already exists,
      // getDirectory must fail.
      if (opt_errorCallback) {
        opt_errorCallback(INVALID_MODIFICATION_ERR);
        return;
      }
    } else if (options.create === true && !folderEntry) {
      // If create is true, the path doesn't exist, and no other error occurs,
      // getDirectory must create it as a zero-length file and return a corresponding
      // DirectoryEntry.
      var dirEntry = new DirectoryEntry();
      dirEntry.name = path.split(DIR_SEPARATOR).pop(); // Just need filename.
      dirEntry.fullPath = path;
      dirEntry.filesystem = fs_;

      idb_.put(dirEntry, successCallback, opt_errorCallback);
    } else if (options.create === true && folderEntry) {

      if (folderEntry.isDirectory) {
        // IDB won't save methods, so we need re-create the DirectoryEntry.
        successCallback(new DirectoryEntry(folderEntry));
      } else {
        if (opt_errorCallback) {
          opt_errorCallback(INVALID_MODIFICATION_ERR);
          return;
        }
      }
    } else if ((!options.create || options.create === false) && !folderEntry) {
      // Handle root special. It should always exist.
      if (path == DIR_SEPARATOR) {
        folderEntry = new DirectoryEntry();
        folderEntry.name = '';
        folderEntry.fullPath = DIR_SEPARATOR;
        folderEntry.filesystem = fs_;
        successCallback(folderEntry);
        return;
      }

      // If create is not true and the path doesn't exist, getDirectory must fail.
      if (opt_errorCallback) {
        opt_errorCallback(NOT_FOUND_ERR);
        return;
      }
    } else if ((!options.create || options.create === false) && folderEntry &&
               folderEntry.isFile) {
      // If create is not true and the path exists, but is a file, getDirectory
      // must fail.
      if (opt_errorCallback) {
        opt_errorCallback(INVALID_MODIFICATION_ERR);
        return;
      }
    } else {
      // Otherwise, if no other error occurs, getDirectory must return a
      // DirectoryEntry corresponding to path.

      // IDB won't' save methods, so we need re-create DirectoryEntry.
      successCallback(new DirectoryEntry(folderEntry));
    }
  }, opt_errorCallback);
};

DirectoryEntry.prototype.getFile = function(path, options, successCallback,
                                            opt_errorCallback) {

  // Create an absolute path if we were handed a relative one.
  path = resolveToFullPath_(this.fullPath, path);

  idb_.get(path, function(fileEntry) {
    if (!options) {
      options = {};
    }

    if (options.create === true && options.exclusive === true && fileEntry) {
      // If create and exclusive are both true, and the path already exists,
      // getFile must fail.

      if (opt_errorCallback) {
        opt_errorCallback(INVALID_MODIFICATION_ERR);
        return;
      }
    } else if (options.create === true && !fileEntry) {
      // If create is true, the path doesn't exist, and no other error occurs,
      // getFile must create it as a zero-length file and return a corresponding
      // FileEntry.
      var fileEntry = new FileEntry();
      fileEntry.name = path.split(DIR_SEPARATOR).pop(); // Just need filename.
      fileEntry.fullPath = path;
      fileEntry.filesystem = fs_;
      fileEntry.file_ = new MyFile({size: 0, name: fileEntry.name,
                                    lastModifiedDate: new Date()});

      idb_.put(fileEntry, successCallback, opt_errorCallback);

    } else if (options.create === true && fileEntry) {
      if (fileEntry.isFile) {
        // IDB won't save methods, so we need re-create the FileEntry.
        successCallback(new FileEntry(fileEntry));
      } else {
        if (opt_errorCallback) {
          opt_errorCallback(INVALID_MODIFICATION_ERR);
          return;
        }
      }
    } else if ((!options.create || options.create === false) && !fileEntry) {
      // If create is not true and the path doesn't exist, getFile must fail.
      if (opt_errorCallback) {
        opt_errorCallback(NOT_FOUND_ERR);
        return;
      }
    } else if ((!options.create || options.create === false) && fileEntry &&
               fileEntry.isDirectory) {
      // If create is not true and the path exists, but is a directory, getFile
      // must fail.
      if (opt_errorCallback) {
        opt_errorCallback(INVALID_MODIFICATION_ERR);
        return;
      }
    } else {
      // Otherwise, if no other error occurs, getFile must return a FileEntry
      // corresponding to path.

      // IDB won't' save methods, so we need re-create the FileEntry.
      successCallback(new FileEntry(fileEntry));
    }
  }, opt_errorCallback);
};

DirectoryEntry.prototype.removeRecursively = function(successCallback,
                                                      opt_errorCallback) {
  if (!successCallback) {
    throw Error('Expected successCallback argument.');
  }

  this.remove(successCallback, opt_errorCallback);
};

/**
 * Interface representing a filesystem.
 *
 * Modeled from:
 * dev.w3.org/2009/dap/file-system/pub/FileSystem/#idl-def-LocalFileSystem
 *
 * @param {number} type Kind of storage to use, either TEMPORARY or PERSISTENT.
 * @param {number} size Storage space (bytes) the application expects to need.
 * @constructor
 */
function DOMFileSystem(type, size) {
  storageType_ = type == exports.TEMPORARY ? 'Temporary' : 'Persistent';
  this.name = (location.protocol + location.host).replace(/:/g, '_') +
              ':' + storageType_;
  this.root = new DirectoryEntry();
  this.root.fullPath = DIR_SEPARATOR;
  this.root.filesystem = this;
  this.root.name = '';
}

function requestFileSystem(type, size, successCallback, opt_errorCallback) {
  if (type != exports.TEMPORARY && type != exports.PERSISTENT) {
    if (opt_errorCallback) {
      opt_errorCallback(INVALID_MODIFICATION_ERR);
      return;
    }
  }

  fs_ = new DOMFileSystem(type, size);
  idb_.open(fs_.name, function(e) {
    successCallback(fs_);
  }, opt_errorCallback);
}

function resolveLocalFileSystemURL(url, successCallback, opt_errorCallback) {
  var origin = location.protocol + '//' + location.host;
  var base = 'filesystem:' + origin + DIR_SEPARATOR + storageType_.toLowerCase();
  url = url.replace(base, '');
  if (url.substr(-1) === '/') {
    url = url.slice(0, -1);
  }
  if (url) {
    idb_.get(url, function(entry) {
      if (entry) {
        if (entry.isFile) {
          return successCallback(new FileEntry(entry));
        } else if (entry.isDirectory) {
          return successCallback(new DirectoryEntry(entry));
        }
      } else {
        opt_errorCallback && opt_errorCallback(NOT_FOUND_ERR);
      }
    }, opt_errorCallback);
  } else {
    successCallback(fs_.root);
  }
}

// Core logic to handle IDB operations =========================================

idb_.open = function(dbName, successCallback, opt_errorCallback) {
  var self = this;

  // TODO: FF 12.0a1 isn't liking a db name with : in it.
  var request = indexedDB.open(dbName.replace(':', '_')/*, 1 /*version*/);

  request.onerror = opt_errorCallback || onError;

  request.onupgradeneeded = function(e) {
    // First open was called or higher db version was used.

   // console.log('onupgradeneeded: oldVersion:' + e.oldVersion,
   //           'newVersion:' + e.newVersion);

    self.db = e.target.result;
    self.db.onerror = onError;

    if (!self.db.objectStoreNames.contains(FILE_STORE_)) {
      var store = self.db.createObjectStore(FILE_STORE_/*,{keyPath: 'id', autoIncrement: true}*/);
    }
  };

  request.onsuccess = function(e) {
    self.db = e.target.result;
    self.db.onerror = onError;
    successCallback(e);
  };

  request.onblocked = opt_errorCallback || onError;
};

idb_.close = function() {
  this.db.close();
  this.db = null;
};

// TODO: figure out if we should ever call this method. The filesystem API
// doesn't allow you to delete a filesystem once it is 'created'. Users should
// use the public remove/removeRecursively API instead.
idb_.drop = function(successCallback, opt_errorCallback) {
  if (!this.db) {
    return;
  }

  var dbName = this.db.name;

  var request = indexedDB.deleteDatabase(dbName);
  request.onsuccess = function(e) {
    successCallback(e);
  };
  request.onerror = opt_errorCallback || onError;

  idb_.close();
};

idb_.get = function(fullPath, successCallback, opt_errorCallback) {
  if (!this.db) {
    return;
  }

  var tx = this.db.transaction([FILE_STORE_], 'readonly');

  //var request = tx.objectStore(FILE_STORE_).get(fullPath);
  var range = IDBKeyRange.bound(fullPath, fullPath + DIR_OPEN_BOUND,
                                false, true);
  var request = tx.objectStore(FILE_STORE_).get(range);

  tx.onabort = opt_errorCallback || onError;
  tx.oncomplete = function(e) {
    successCallback(request.result);
  };
};

idb_.getAllEntries = function(fullPath, successCallback, opt_errorCallback) {
  if (!this.db) {
    return;
  }

  var results = [];

  //var range = IDBKeyRange.lowerBound(fullPath, true);
  //var range = IDBKeyRange.upperBound(fullPath, true);

  // Treat the root entry special. Querying it returns all entries because
  // they match '/'.
  var range = null;
  if (fullPath != DIR_SEPARATOR) {
    //console.log(fullPath + '/', fullPath + DIR_OPEN_BOUND)
    range = IDBKeyRange.bound(
        fullPath + DIR_SEPARATOR, fullPath + DIR_OPEN_BOUND, false, true);
  }

  var tx = this.db.transaction([FILE_STORE_], 'readonly');
  tx.onabort = opt_errorCallback || onError;
  tx.oncomplete = function(e) {
    // TODO: figure out how to do be range queries instead of filtering result
    // in memory :(
    results = results.filter(function(val) {
      var valPartsLen = val.fullPath.split(DIR_SEPARATOR).length;
      var fullPathPartsLen = fullPath.split(DIR_SEPARATOR).length;

      if (fullPath == DIR_SEPARATOR && valPartsLen < fullPathPartsLen + 1) {
        // Hack to filter out entries in the root folder. This is inefficient
        // because reading the entires of fs.root (e.g. '/') returns ALL
        // results in the database, then filters out the entries not in '/'.
        return val;
      } else if (fullPath != DIR_SEPARATOR &&
                 valPartsLen == fullPathPartsLen + 1) {
        // If this a subfolder and entry is a direct child, include it in
        // the results. Otherwise, it's not an entry of this folder.
        return val;
      }
    });

    successCallback(results);
  };

  var request = tx.objectStore(FILE_STORE_).openCursor(range);

  request.onsuccess = function(e) {
    var cursor = e.target.result;
    if (cursor) {
      var val = cursor.value;

      results.push(val.isFile ? new FileEntry(val) : new DirectoryEntry(val));
      cursor['continue']();
    }
  };
};

idb_['delete'] = function(fullPath, successCallback, opt_errorCallback) {
  if (!this.db) {
    return;
  }

  var tx = this.db.transaction([FILE_STORE_], 'readwrite');
  tx.oncomplete = successCallback;
  tx.onabort = opt_errorCallback || onError;

  //var request = tx.objectStore(FILE_STORE_).delete(fullPath);
  var range = IDBKeyRange.bound(
      fullPath, fullPath + DIR_OPEN_BOUND, false, true);
  var request = tx.objectStore(FILE_STORE_)['delete'](range);
};

idb_.put = function(entry, successCallback, opt_errorCallback) {
  if (!this.db) {
    return;
  }

  var tx = this.db.transaction([FILE_STORE_], 'readwrite');
  tx.onabort = opt_errorCallback || onError;
  tx.oncomplete = function(e) {
    // TODO: Error is thrown if we pass the request event back instead.
    successCallback(entry);
  };

  var request = tx.objectStore(FILE_STORE_).put(entry, entry.fullPath);
};

// Global error handler. Errors bubble from request, to transaction, to db.
function onError(e) {
  switch (e.target.errorCode) {
    case 12:
      console.log('Error - Attempt to open db with a lower version than the ' +
                  'current one.');
      break;
    default:
      console.log('errorCode: ' + e.target.errorCode);
  }

  console.log(e, e.code, e.message);
}

// Clean up.
// TODO: decide if this is the best place for this.
exports.addEventListener('beforeunload', function(e) {
  idb_.db && idb_.db.close();
}, false);

//exports.idb = idb_;
exports.requestFileSystem = requestFileSystem;
exports.resolveLocalFileSystemURL = resolveLocalFileSystemURL;

// Export more stuff (to window) for unit tests to do their thing.
if (exports === window && exports.RUNNING_TESTS) {
  exports['Entry'] = Entry;
  exports['FileEntry'] = FileEntry;
  exports['DirectoryEntry'] = DirectoryEntry;
  exports['resolveToFullPath_'] = resolveToFullPath_;
  exports['Metadata'] = Metadata;
  exports['Base64ToBlob'] = Base64ToBlob;
}

})(self); // Don't use window because we want to run in workers.


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/kd-glob-to-regexp/index.js":
/*!*************************************************!*\
  !*** ./node_modules/kd-glob-to-regexp/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (glob, opts) {
  if (typeof glob !== 'string') {
    throw new TypeError('Expected a string');
  }

  var str = String(glob);

  // The regexp we are building, as a string.
  var reStr = "";

  // Whether we are matching so called "extended" globs (like bash) and should
  // support single character matching, matching ranges of characters, group
  // matching, etc.
  var extended = opts ? !!opts.extended : false;

  // Whether or not to capture those stars, it means wrapping them with parentheses
  // It's not necessary if globstart is turned on
  var capture = opts ? !!opts.capture : false;

  // When globstar is _false_ (default), '/foo/*' is translated a regexp like
  // '^\/foo\/.*$' which will match any string beginning with '/foo/'
  // When globstar is _true_, '/foo/*' is translated to regexp like
  // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
  // which does not have a '/' to the right of it.
  // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
  // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
  // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
  // globstar is _false_
  var globstar = opts ? !!opts.globstar : false;

  // If we are doing extended matching, this boolean is true when we are inside
  // a group (eg {*.html,*.js}), and false otherwise.
  var inGroup = false;

  // RegExp flags (eg "i" ) to pass in to RegExp constructor.
  var flags = opts && typeof( opts.flags ) === "string" ? opts.flags : "";

  var c;
  for (var i = 0, len = str.length; i < len; i++) {
    c = str[i];

    switch (c) {
    case "/":
    case "$":
    case "^":
    case "+":
    case ".":
    case "(":
    case ")":
    case "=":
    case "!":
    case "|":
      reStr += "\\" + c;
      break;

    case "?":
      if (extended) {
        reStr += ".";
	    break;
      }

    case "[":
    case "]":
      if (extended) {
        reStr += c;
	    break;
      }

    case "{":
      if (extended) {
        inGroup = true;
	    reStr += "(";
	    break;
      }

    case "}":
      if (extended) {
        inGroup = false;
	    reStr += ")";
	    break;
      }

    case ",":
      if (inGroup) {
        reStr += "|";
	    break;
      }
      reStr += "\\" + c;
      break;

    case "*":
      // Move over all consecutive "*"'s.
      // Also store the previous and next characters
      var prevChar = str[i - 1];
      var starCount = 1;
      while(str[i + 1] === "*") {
        starCount++;
        i++;
      }
      var nextChar = str[i + 1];

      if (!globstar) {
        // globstar is disabled, so treat any number of "*" as one
        reStr += capture ? "(.*)" : ".*";
      } else {
        // globstar is enabled, so determine if this is a globstar segment
        var isGlobstar = starCount > 1                      // multiple "*"'s
          && (prevChar === "/" || prevChar === undefined)   // from the start of the segment
          && (nextChar === "/" || nextChar === undefined)   // to the end of the segment

        if (isGlobstar) {
          // it's a globstar, so match zero or more path segments
          reStr += "((?:[^/]*(?:\/|$))*)";
          i++; // move over the "/"
        } else {
          // it's not a globstar, so only match one path segment
          reStr += "([^/]*)";
        }
      }
      break;

    default:
      reStr += c;
    }
  }

  // When regexp 'g' flag is specified don't
  // constrain the regular expression with ^ & $
  if (!flags || !~flags.indexOf('g')) {
    reStr = "^" + reStr + "$";
  }

  return new RegExp(reStr, flags);
};


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ "./node_modules/pbkdf2/lib/async.js")

exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/pbkdf2/lib/sync-browser.js")


/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var sync = __webpack_require__(/*! ./sync */ "./node_modules/pbkdf2/lib/sync-browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}
function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  checkParameters(iterations, keylen)
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]
  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }
  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) {
      return browserPbkdf2(password, salt, iterations, keylen, algo)
    } else {
      return sync(password, salt, iterations, keylen, digest)
    }
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var rmd160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  checkParameters(iterations, keylen)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/readable-stream/duplex.js":
/*!************************************************!*\
  !*** ./node_modules/readable-stream/duplex.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js")


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = Readable;

/*<replacement>*/
var processNextTick = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js");

/*<replacement>*/
var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js");
  } catch (_) {} finally {
    if (!Stream) Stream = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 0);
var debug = undefined;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/*<replacement>*/
var processNextTick = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js");
  } catch (_) {} finally {
    if (!Stream) Stream = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // create the two objects needed to store the corked requests
  // they are not a linked list, as no new elements are inserted in there
  this.corkedRequestsFree = new CorkedRequest(this);
  this.corkedRequestsFree.next = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    state.corkedRequestsFree = holder.next;
    holder.next = null;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js")


/***/ }),

/***/ "./node_modules/readable-stream/readable.js":
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/readable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stream = (function (){
  try {
    return __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js"); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js")


/***/ }),

/***/ "./node_modules/readable-stream/writable.js":
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/writable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js")


/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var m = new Array(16)
  for (var i = 0; i < 16; ++i) m[i] = this._block.readInt32LE(i * 4)

  var al = this._a
  var bl = this._b
  var cl = this._c
  var dl = this._d
  var el = this._e

  // Mj = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  // K = 0x00000000
  // Sj = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
  al = fn1(al, bl, cl, dl, el, m[0], 0x00000000, 11); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[1], 0x00000000, 14); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[2], 0x00000000, 15); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[3], 0x00000000, 12); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[4], 0x00000000, 5); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[5], 0x00000000, 8); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[6], 0x00000000, 7); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[7], 0x00000000, 9); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[8], 0x00000000, 11); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[9], 0x00000000, 13); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[10], 0x00000000, 14); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[11], 0x00000000, 15); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[12], 0x00000000, 6); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[13], 0x00000000, 7); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[14], 0x00000000, 9); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[15], 0x00000000, 8); cl = rotl(cl, 10)

  // Mj = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
  // K = 0x5a827999
  // Sj = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
  el = fn2(el, al, bl, cl, dl, m[7], 0x5a827999, 7); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[4], 0x5a827999, 6); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[13], 0x5a827999, 8); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[1], 0x5a827999, 13); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[10], 0x5a827999, 11); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[6], 0x5a827999, 9); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[15], 0x5a827999, 7); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[3], 0x5a827999, 15); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[12], 0x5a827999, 7); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[0], 0x5a827999, 12); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[9], 0x5a827999, 15); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[5], 0x5a827999, 9); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[2], 0x5a827999, 11); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[14], 0x5a827999, 7); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[11], 0x5a827999, 13); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[8], 0x5a827999, 12); bl = rotl(bl, 10)

  // Mj = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
  // K = 0x6ed9eba1
  // Sj = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
  dl = fn3(dl, el, al, bl, cl, m[3], 0x6ed9eba1, 11); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[10], 0x6ed9eba1, 13); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[14], 0x6ed9eba1, 6); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[4], 0x6ed9eba1, 7); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[9], 0x6ed9eba1, 14); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[15], 0x6ed9eba1, 9); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[8], 0x6ed9eba1, 13); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[1], 0x6ed9eba1, 15); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[2], 0x6ed9eba1, 14); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[7], 0x6ed9eba1, 8); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[0], 0x6ed9eba1, 13); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[6], 0x6ed9eba1, 6); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[13], 0x6ed9eba1, 5); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[11], 0x6ed9eba1, 12); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[5], 0x6ed9eba1, 7); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[12], 0x6ed9eba1, 5); al = rotl(al, 10)

  // Mj = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
  // K = 0x8f1bbcdc
  // Sj = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
  cl = fn4(cl, dl, el, al, bl, m[1], 0x8f1bbcdc, 11); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[9], 0x8f1bbcdc, 12); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[11], 0x8f1bbcdc, 14); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[10], 0x8f1bbcdc, 15); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[0], 0x8f1bbcdc, 14); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[8], 0x8f1bbcdc, 15); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[12], 0x8f1bbcdc, 9); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[4], 0x8f1bbcdc, 8); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[13], 0x8f1bbcdc, 9); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[3], 0x8f1bbcdc, 14); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[7], 0x8f1bbcdc, 5); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[15], 0x8f1bbcdc, 6); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[14], 0x8f1bbcdc, 8); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[5], 0x8f1bbcdc, 6); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[6], 0x8f1bbcdc, 5); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[2], 0x8f1bbcdc, 12); el = rotl(el, 10)

  // Mj = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  // K = 0xa953fd4e
  // Sj = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  bl = fn5(bl, cl, dl, el, al, m[4], 0xa953fd4e, 9); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[0], 0xa953fd4e, 15); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[5], 0xa953fd4e, 5); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[9], 0xa953fd4e, 11); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[7], 0xa953fd4e, 6); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[12], 0xa953fd4e, 8); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[2], 0xa953fd4e, 13); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[10], 0xa953fd4e, 12); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[14], 0xa953fd4e, 5); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[1], 0xa953fd4e, 12); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[3], 0xa953fd4e, 13); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[8], 0xa953fd4e, 14); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[11], 0xa953fd4e, 11); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[6], 0xa953fd4e, 8); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[15], 0xa953fd4e, 5); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[13], 0xa953fd4e, 6); dl = rotl(dl, 10)

  var ar = this._a
  var br = this._b
  var cr = this._c
  var dr = this._d
  var er = this._e

  // M'j = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
  // K' = 0x50a28be6
  // S'j = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
  ar = fn5(ar, br, cr, dr, er, m[5], 0x50a28be6, 8); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[14], 0x50a28be6, 9); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[7], 0x50a28be6, 9); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[0], 0x50a28be6, 11); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[9], 0x50a28be6, 13); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[2], 0x50a28be6, 15); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[11], 0x50a28be6, 15); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[4], 0x50a28be6, 5); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[13], 0x50a28be6, 7); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[6], 0x50a28be6, 7); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[15], 0x50a28be6, 8); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[8], 0x50a28be6, 11); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[1], 0x50a28be6, 14); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[10], 0x50a28be6, 14); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[3], 0x50a28be6, 12); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[12], 0x50a28be6, 6); cr = rotl(cr, 10)

  // M'j = 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
  // K' = 0x5c4dd124
  // S'j = 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
  er = fn4(er, ar, br, cr, dr, m[6], 0x5c4dd124, 9); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[11], 0x5c4dd124, 13); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[3], 0x5c4dd124, 15); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[7], 0x5c4dd124, 7); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[0], 0x5c4dd124, 12); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[13], 0x5c4dd124, 8); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[5], 0x5c4dd124, 9); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[10], 0x5c4dd124, 11); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[14], 0x5c4dd124, 7); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[15], 0x5c4dd124, 7); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[8], 0x5c4dd124, 12); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[12], 0x5c4dd124, 7); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[4], 0x5c4dd124, 6); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[9], 0x5c4dd124, 15); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[1], 0x5c4dd124, 13); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[2], 0x5c4dd124, 11); br = rotl(br, 10)

  // M'j = 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
  // K' = 0x6d703ef3
  // S'j = 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
  dr = fn3(dr, er, ar, br, cr, m[15], 0x6d703ef3, 9); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[5], 0x6d703ef3, 7); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[1], 0x6d703ef3, 15); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[3], 0x6d703ef3, 11); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[7], 0x6d703ef3, 8); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[14], 0x6d703ef3, 6); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[6], 0x6d703ef3, 6); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[9], 0x6d703ef3, 14); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[11], 0x6d703ef3, 12); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[8], 0x6d703ef3, 13); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[12], 0x6d703ef3, 5); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[2], 0x6d703ef3, 14); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[10], 0x6d703ef3, 13); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[0], 0x6d703ef3, 13); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[4], 0x6d703ef3, 7); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[13], 0x6d703ef3, 5); ar = rotl(ar, 10)

  // M'j = 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
  // K' = 0x7a6d76e9
  // S'j = 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
  cr = fn2(cr, dr, er, ar, br, m[8], 0x7a6d76e9, 15); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[6], 0x7a6d76e9, 5); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[4], 0x7a6d76e9, 8); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[1], 0x7a6d76e9, 11); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[3], 0x7a6d76e9, 14); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[11], 0x7a6d76e9, 14); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[15], 0x7a6d76e9, 6); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[0], 0x7a6d76e9, 14); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[5], 0x7a6d76e9, 6); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[12], 0x7a6d76e9, 9); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[2], 0x7a6d76e9, 12); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[13], 0x7a6d76e9, 9); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[9], 0x7a6d76e9, 12); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[7], 0x7a6d76e9, 5); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[10], 0x7a6d76e9, 15); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[14], 0x7a6d76e9, 8); er = rotl(er, 10)

  // M'j = 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  // K' = 0x00000000
  // S'j = 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  br = fn1(br, cr, dr, er, ar, m[12], 0x00000000, 8); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[15], 0x00000000, 5); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[10], 0x00000000, 12); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[4], 0x00000000, 9); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[1], 0x00000000, 12); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[5], 0x00000000, 5); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[8], 0x00000000, 14); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[7], 0x00000000, 6); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[6], 0x00000000, 8); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[2], 0x00000000, 13); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[13], 0x00000000, 6); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[14], 0x00000000, 5); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[0], 0x00000000, 15); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[3], 0x00000000, 13); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[9], 0x00000000, 11); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[11], 0x00000000, 11); dr = rotl(dr, 10)

  // change state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = bits & 0xffffffff
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/common/box.js":
/*!***************************!*\
  !*** ./src/common/box.js ***!
  \***************************/
/*! exports provided: BOX_ANCHOR_POS, fitSquarePoint, calcRectAndAnchor, pointAtPos, diagonalPos, diagonalPoint, genGetAnchorRects, getAnchorRects, Box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOX_ANCHOR_POS", function() { return BOX_ANCHOR_POS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitSquarePoint", function() { return fitSquarePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calcRectAndAnchor", function() { return calcRectAndAnchor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointAtPos", function() { return pointAtPos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diagonalPos", function() { return diagonalPos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diagonalPoint", function() { return diagonalPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genGetAnchorRects", function() { return genGetAnchorRects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAnchorRects", function() { return getAnchorRects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BOX_ANCHOR_POS = {
  TOP_LEFT: 1,
  TOP_RIGHT: 2,
  BOTTOM_RIGHT: 3,
  BOTTOM_LEFT: 4
};

var fitSquarePoint = function fitSquarePoint(movingPoint, fixedPoint) {
  var mp = movingPoint;
  var fp = fixedPoint;
  var xlen = Math.abs(mp.x - fp.x);
  var ylen = Math.abs(mp.y - fp.y);
  var len = Math.min(xlen, ylen);

  return {
    x: fp.x + Math.sign(mp.x - fp.x) * len,
    y: fp.y + Math.sign(mp.y - fp.y) * len
  };
};

var calcRectAndAnchor = function calcRectAndAnchor(movingPoint, fixedPoint) {
  var mp = movingPoint;
  var fp = fixedPoint;
  var pos = null;
  var tlp = null;

  if (mp.x <= fp.x && mp.y <= fp.y) {
    pos = BOX_ANCHOR_POS.TOP_LEFT;
    tlp = mp;
  } else if (mp.x > fp.x && mp.y > fp.y) {
    pos = BOX_ANCHOR_POS.BOTTOM_RIGHT;
    tlp = fp;
  } else if (mp.x > fp.x) {
    pos = BOX_ANCHOR_POS.TOP_RIGHT;
    tlp = { x: fp.x, y: mp.y };
  } else if (mp.y > fp.y) {
    pos = BOX_ANCHOR_POS.BOTTOM_LEFT;
    tlp = { x: mp.x, y: fp.y };
  }

  return {
    rect: {
      x: tlp.x,
      y: tlp.y,
      width: Math.abs(mp.x - fp.x),
      height: Math.abs(mp.y - fp.y)
    },
    anchorPos: pos
  };
};

var pointAtPos = function pointAtPos(rect, pos) {
  switch (pos) {
    case BOX_ANCHOR_POS.TOP_LEFT:
      return {
        x: rect.x,
        y: rect.y
      };
    case BOX_ANCHOR_POS.TOP_RIGHT:
      return {
        x: rect.x + rect.width,
        y: rect.y
      };
    case BOX_ANCHOR_POS.BOTTOM_RIGHT:
      return {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      };
    case BOX_ANCHOR_POS.BOTTOM_LEFT:
      return {
        x: rect.x,
        y: rect.y + rect.height
      };
  }
};

var diagonalPos = function diagonalPos(pos) {
  switch (pos) {
    case BOX_ANCHOR_POS.TOP_LEFT:
      return BOX_ANCHOR_POS.BOTTOM_RIGHT;

    case BOX_ANCHOR_POS.TOP_RIGHT:
      return BOX_ANCHOR_POS.BOTTOM_LEFT;

    case BOX_ANCHOR_POS.BOTTOM_RIGHT:
      return BOX_ANCHOR_POS.TOP_LEFT;

    case BOX_ANCHOR_POS.BOTTOM_LEFT:
      return BOX_ANCHOR_POS.TOP_RIGHT;
  }
};

var diagonalPoint = function diagonalPoint(rect, anchorPos) {
  return pointAtPos(rect, diagonalPos(anchorPos));
};

var genGetAnchorRects = function genGetAnchorRects(ANCHOR_POS, pointAtPos) {
  return function (_ref) {
    var rect = _ref.rect,
        _ref$size = _ref.size,
        size = _ref$size === undefined ? 5 : _ref$size;

    var values = function values(obj) {
      return Object.keys(obj).map(function (key) {
        return obj[key];
      });
    };
    var createRect = function createRect(point, size) {
      return {
        x: point.x - size,
        y: point.y - size,
        width: size * 2,
        height: size * 2
      };
    };

    return values(ANCHOR_POS).map(function (pos) {
      return {
        anchorPos: pos,
        rect: createRect(pointAtPos(rect, pos), size)
      };
    });
  };
};

var getAnchorRects = genGetAnchorRects(BOX_ANCHOR_POS, pointAtPos);

var Box = function () {
  function Box(options) {
    _classCallCheck(this, Box);

    this.state = {
      type: 'box',
      data: null,
      style: {},
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
    this.local = {};

    var opts = _extends({
      firstSilence: true,
      transform: function transform(x) {
        return x;
      },
      onStateChange: function onStateChange() {}
    }, options);

    this.transform = opts.transform;
    this.onStateChange = opts.onStateChange;
    this.normalizeRect = opts.normalizeRect || function (x) {
      return x;
    };

    this.__setState({
      id: opts.id,
      data: opts.data,
      type: this.getType(),
      style: this.getDefaultStyle(),
      category: this.getCategory(),
      rect: {
        x: opts.x,
        y: opts.y,
        width: opts.width || 0,
        height: opts.height || 0
      }
    }, { silent: opts.firstSilence });
  }
  // Note: possible settings


  _createClass(Box, [{
    key: 'getType',
    value: function getType() {
      return 'box';
    }
  }, {
    key: 'getCategory',
    value: function getCategory() {
      return Box.category;
    }
  }, {
    key: 'getDefaultAnchorPos',
    value: function getDefaultAnchorPos() {
      return BOX_ANCHOR_POS.BOTTOM_RIGHT;
    }
  }, {
    key: 'getDefaultStyle',
    value: function getDefaultStyle() {
      return {};
    }
  }, {
    key: 'getId',
    value: function getId() {
      return this.state.id;
    }
  }, {
    key: 'getState',
    value: function getState() {
      return this.transform(this.state);
    }
  }, {
    key: 'processIncomingStyle',
    value: function processIncomingStyle(style) {
      return style;
    }
  }, {
    key: 'setStyle',
    value: function setStyle(obj) {
      this.__setState({
        style: _extends({}, this.state.style, this.processIncomingStyle(obj))
      });
    }
  }, {
    key: 'setData',
    value: function setData(data) {
      this.__setState({ data: data });
    }
  }, {
    key: 'moveAnchorStart',
    value: function moveAnchorStart(_ref2) {
      var anchorPos = _ref2.anchorPos;

      this.__setLocal({
        oldPoint: pointAtPos(this.state.rect, anchorPos),
        oldAnchorPos: anchorPos,
        anchorPos: anchorPos
      });
    }
  }, {
    key: 'moveAnchor',
    value: function moveAnchor(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          fit = _ref4.fit;

      var old = this.state.rect;
      var pos = this.local.anchorPos;
      var fixed = diagonalPoint(old, pos);
      var moving = !fit ? { x: x, y: y } : fitSquarePoint({ x: x, y: y }, fixed);
      var res = calcRectAndAnchor(moving, fixed);

      this.__setLocal({ anchorPos: res.anchorPos });
      this.__setState({ rect: this.normalizeRect(res.rect, 'moveAnchor') });
    }
  }, {
    key: 'moveAnchorEnd',
    value: function moveAnchorEnd() {
      this.__setLocal({
        oldPoint: null,
        oldAnchorPos: null,
        anchorPos: null
      });
    }
  }, {
    key: 'moveBoxStart',
    value: function moveBoxStart() {
      this.__setLocal({
        oldRect: _extends({}, this.state.rect)
      });
    }
  }, {
    key: 'moveBox',
    value: function moveBox(_ref5) {
      var dx = _ref5.dx,
          dy = _ref5.dy;

      var old = this.local.oldRect;
      var upd = _extends({}, old, {
        x: old.x + dx,
        y: old.y + dy
      });

      this.__setState({ rect: this.normalizeRect(upd, 'moveBox') });
    }
  }, {
    key: 'moveBoxEnd',
    value: function moveBoxEnd() {
      this.__setLocal({
        oldRect: null
      });
    }
  }, {
    key: '__setState',
    value: function __setState(obj) {
      var _this = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var last = this.getState();

      this.state = _extends({}, this.state, obj);

      if (opts.silent) return;

      var fn = function fn() {
        return _this.onStateChange(_this.getState(), last);
      };
      var invoke = opts.nextTick ? function (fn) {
        return setTimeout(fn, 0);
      } : function (fn) {
        return fn();
      };

      invoke(fn);
    }
  }, {
    key: '__setLocal',
    value: function __setLocal(obj) {
      this.local = _extends({}, this.local, obj);
    }
  }]);

  return Box;
}();
Box.settings = [];
Box.category = 'rect';
Box.defaultAnchorPos = BOX_ANCHOR_POS.BOTTOM_RIGHT;

/***/ }),

/***/ "./src/common/capture_screenshot.js":
/*!******************************************!*\
  !*** ./src/common/capture_screenshot.js ***!
  \******************************************/
/*! exports provided: imageSizeFromDataURI, getScreenshotRatio, scaleDataURI, captureScreen, createCaptureScreenWithCachedScreenshotRatio, saveScreen, captureFullScreen, captureScreenInSelectionSimple, captureScreenInSelection, captureClientAPI, saveFullScreen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imageSizeFromDataURI", function() { return imageSizeFromDataURI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScreenshotRatio", function() { return getScreenshotRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleDataURI", function() { return scaleDataURI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "captureScreen", function() { return captureScreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCaptureScreenWithCachedScreenshotRatio", function() { return createCaptureScreenWithCachedScreenshotRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveScreen", function() { return saveScreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "captureFullScreen", function() { return captureFullScreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "captureScreenInSelectionSimple", function() { return captureScreenInSelectionSimple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "captureScreenInSelection", function() { return captureScreenInSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "captureClientAPI", function() { return captureClientAPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveFullScreen", function() { return saveFullScreen; });
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _filesystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filesystem */ "./src/common/filesystem.js");
/* harmony import */ var _common_screenshot_man__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/screenshot_man */ "./src/common/screenshot_man.js");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();






function getActiveTabInfo() {
  return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.windows.getLastFocused().then(function (win) {
    return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.tabs.query({ active: true, windowId: win.id }).then(function (tabs) {
      return tabs[0];
    });
  });
}

function imageSizeFromDataURI(dataURI) {
  return new Promise(function (resolve, reject) {
    var img = new Image();
    img.onload = function () {
      resolve({
        width: img.naturalWidth,
        height: img.naturalHeight
      });
    };
    img.src = dataURI;
  });
}

function getScreenshotRatio(dataURI, tabId, devicePixelRatio) {
  return Promise.all([imageSizeFromDataURI(dataURI), _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.tabs.get(tabId)]).then(function (tuple) {
    var _tuple = _slicedToArray(tuple, 2),
        size = _tuple[0],
        tab = _tuple[1];

    return tab.width * devicePixelRatio / size.width;
  });
}

function scaleDataURI(dataURI, scale) {
  if (scale === 1) return Promise.resolve(dataURI);

  return new Promise(function (resolve, reject) {
    var img = new Image();
    img.onload = function () {
      resolve(img);
    };
    img.src = dataURI;
  }).then(function (img) {
    var canvas = createCanvas(img.naturalWidth, img.naturalHeight, scale);
    return drawOnCanvas({
      canvas: canvas,
      dataURI: dataURI,
      x: 0,
      y: 0,
      width: img.naturalWidth * scale,
      height: img.naturalHeight * scale
    }).then(function () {
      return canvas.toDataURL();
    });
  });
}

function captureScreen(tabId, presetScreenshotRatio) {
  var is2ndArgFunction = typeof presetScreenshotRatio === 'function';
  var hasScreenshotRatio = presetScreenshotRatio && !is2ndArgFunction;
  var pDataURI = _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.tabs.captureVisibleTab(null, { format: 'png' });
  var pRatio = hasScreenshotRatio ? Promise.resolve(presetScreenshotRatio) : pDataURI.then(function (dataURI) {
    return getScreenshotRatio(dataURI, tabId, window.devicePixelRatio);
  });

  return Promise.all([pDataURI, pRatio]).then(function (tuple) {
    var _tuple2 = _slicedToArray(tuple, 2),
        dataURI = _tuple2[0],
        screenshotRatio = _tuple2[1];
    // Note: leak the info about screenshotRatio on purpose


    if (!hasScreenshotRatio && is2ndArgFunction) presetScreenshotRatio(screenshotRatio);
    if (screenshotRatio === 1) return dataURI;
    return scaleDataURI(dataURI, screenshotRatio);
  });
}

function createCaptureScreenWithCachedScreenshotRatio() {
  var screenshotRatio = void 0;

  return function (tabId) {
    return captureScreen(tabId, screenshotRatio || function (ratio) {
      screenshotRatio = ratio;
    });
  };
}

function captureScreenBlob(tabId) {
  return captureScreen(tabId).then(_common_utils__WEBPACK_IMPORTED_MODULE_3__["dataURItoBlob"]);
}

function saveScreen(tabId, fileName) {
  return captureScreenBlob(tabId).then(function (screenBlob) {
    return Object(_common_screenshot_man__WEBPACK_IMPORTED_MODULE_2__["getScreenshotMan"])().overwrite(fileName, screenBlob).then(function (url) {
      return {
        url: url,
        fileName: fileName
      };
    });
  });
}

function pCompose(list) {
  return list.reduce(function (prev, fn) {
    return prev.then(fn);
  }, Promise.resolve());
}

function getAllScrollOffsets(_ref) {
  var pageWidth = _ref.pageWidth,
      pageHeight = _ref.pageHeight,
      windowWidth = _ref.windowWidth,
      windowHeight = _ref.windowHeight,
      _ref$topPadding = _ref.topPadding,
      topPadding = _ref$topPadding === undefined ? 150 : _ref$topPadding;

  var topPad = windowHeight > topPadding ? topPadding : 0;
  var xStep = windowWidth;
  var yStep = windowHeight - topPad;
  var result = [];

  // Note: bottom comes first so that when we render those screenshots one by one to the final canvas,
  // those at top will overwrite top padding part of those at bottom, it is useful if that page has some fixed header
  for (var y = pageHeight - windowHeight; y > -1 * yStep; y -= yStep) {
    for (var x = 0; x < pageWidth; x += xStep) {
      result.push({ x: x, y: y });
    }
  }

  return result;
}

function getAllScrollOffsetsForRect(_ref2, _ref3) {
  var x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height;
  var pageWidth = _ref3.pageWidth,
      pageHeight = _ref3.pageHeight,
      windowWidth = _ref3.windowWidth,
      windowHeight = _ref3.windowHeight,
      originalX = _ref3.originalX,
      originalY = _ref3.originalY,
      _ref3$topPadding = _ref3.topPadding,
      topPadding = _ref3$topPadding === undefined ? 150 : _ref3$topPadding;

  var topPad = windowHeight > topPadding ? topPadding : 0;
  var xStep = windowWidth;
  var yStep = windowHeight - topPad;
  var result = [];

  for (var sy = y + height - windowHeight; sy > y - yStep; sy -= yStep) {
    for (var sx = x; sx < x + width; sx += xStep) {
      result.push({ x: sx, y: sy });
    }
  }

  if (result.length === 0) {
    result.push({ x: x, y: y + height - windowHeight });
  }

  return result;
}

function createCanvas(width, height) {
  var pixelRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var canvas = document.createElement('canvas');
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  return canvas;
}

function drawOnCanvas(_ref4) {
  var canvas = _ref4.canvas,
      dataURI = _ref4.dataURI,
      x = _ref4.x,
      y = _ref4.y,
      width = _ref4.width,
      height = _ref4.height;

  return new Promise(function (resolve, reject) {
    var image = new Image();

    image.onload = function () {
      canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height, x, y, width || image.width, height || image.height);
      resolve({
        x: x,
        y: y,
        width: width,
        height: height
      });
    };

    image.src = dataURI;
  });
}

function withPageInfo(startCapture, endCapture, callback) {
  return startCapture().then(function (pageInfo) {
    // Note: in case sender contains any non-serializable data
    delete pageInfo.sender;

    return callback(pageInfo).then(function (result) {
      endCapture(pageInfo);
      return result;
    });
  });
}

function captureFullScreen(tabId) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : captureClientAPI,
      startCapture = _ref5.startCapture,
      scrollPage = _ref5.scrollPage,
      endCapture = _ref5.endCapture;

  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var opts = _extends({
    blob: false
  }, options);

  return withPageInfo(startCapture, endCapture, function (pageInfo) {
    var devicePixelRatio = pageInfo.devicePixelRatio;

    // Note: cut down page width and height
    // reference: https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element/11585939#11585939
    var maxSide = Math.floor(32767 / devicePixelRatio);
    pageInfo.pageWidth = Math.min(maxSide, pageInfo.pageWidth);
    pageInfo.pageHeight = Math.min(maxSide, pageInfo.pageHeight);

    var captureScreen = createCaptureScreenWithCachedScreenshotRatio();
    var canvas = createCanvas(pageInfo.pageWidth, pageInfo.pageHeight, devicePixelRatio);
    var scrollOffsets = getAllScrollOffsets(pageInfo);
    var todos = scrollOffsets.map(function (offset, i) {
      return function () {
        return scrollPage(offset, { index: i, total: scrollOffsets.length }).then(function (realOffset) {
          return captureScreen(tabId).then(function (dataURI) {
            return drawOnCanvas({
              canvas: canvas,
              dataURI: dataURI,
              x: realOffset.x * devicePixelRatio,
              y: realOffset.y * devicePixelRatio,
              width: pageInfo.windowWidth * devicePixelRatio,
              height: pageInfo.windowHeight * devicePixelRatio
            });
          });
        });
      };
    });
    var convert = opts.blob ? _common_utils__WEBPACK_IMPORTED_MODULE_3__["dataURItoBlob"] : function (x) {
      return x;
    };

    return pCompose(todos).then(function () {
      return convert(canvas.toDataURL());
    });
  });
}

function captureScreenInSelectionSimple(tabId, _ref6) {
  var rect = _ref6.rect,
      devicePixelRatio = _ref6.devicePixelRatio;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var opts = _extends({
    blob: false
  }, options);
  var convert = opts.blob ? _common_utils__WEBPACK_IMPORTED_MODULE_3__["dataURItoBlob"] : function (x) {
    return x;
  };
  var ratio = devicePixelRatio;
  var canvas = createCanvas(rect.width, rect.height, ratio);

  return captureScreen(tabId).then(function (dataURI) {
    return drawOnCanvas({
      canvas: canvas,
      dataURI: dataURI,
      x: -1 * rect.x * devicePixelRatio,
      y: -1 * rect.y * devicePixelRatio
    });
  }).then(function () {
    return convert(canvas.toDataURL());
  });
}

function captureScreenInSelection(tabId, _ref7, _ref8) {
  var rect = _ref7.rect,
      devicePixelRatio = _ref7.devicePixelRatio;
  var startCapture = _ref8.startCapture,
      scrollPage = _ref8.scrollPage,
      endCapture = _ref8.endCapture;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var opts = _extends({
    blob: false
  }, options);
  var convert = opts.blob ? _common_utils__WEBPACK_IMPORTED_MODULE_3__["dataURItoBlob"] : function (x) {
    return x;
  };
  var ratio = devicePixelRatio;

  return withPageInfo(startCapture, endCapture, function (pageInfo) {
    var maxSide = Math.floor(32767 / ratio);
    pageInfo.pageWidth = Math.min(maxSide, pageInfo.pageWidth);
    pageInfo.pageHeight = Math.min(maxSide, pageInfo.pageHeight);

    var captureScreen = createCaptureScreenWithCachedScreenshotRatio();
    var canvas = createCanvas(rect.width, rect.height, ratio);
    var scrollOffsets = getAllScrollOffsetsForRect(rect, pageInfo);
    var todos = scrollOffsets.map(function (offset, i) {
      return function () {
        return scrollPage(offset, { index: i, total: scrollOffsets.length }).then(function (realOffset) {
          return captureScreen(tabId).then(function (dataURI) {
            return drawOnCanvas({
              canvas: canvas,
              dataURI: dataURI,
              x: (realOffset.x - rect.x) * devicePixelRatio,
              y: (realOffset.y - rect.y) * devicePixelRatio,
              width: pageInfo.windowWidth * devicePixelRatio,
              height: pageInfo.windowHeight * devicePixelRatio
            });
          });
        });
      };
    });

    return pCompose(todos).then(function () {
      return convert(canvas.toDataURL());
    });
  });
}

var captureClientAPI = {
  getPageInfo: function getPageInfo() {
    var body = document.body;
    var widths = [document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth, body ? body.scrollWidth : 0, body ? body.offsetWidth : 0];
    var heights = [document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight, body ? body.scrollHeight : 0, body ? body.offsetHeight : 0];

    var data = {
      pageWidth: Math.max.apply(Math, widths),
      pageHeight: Math.max.apply(Math, heights),
      windowWidth: window.innerWidth,
      windowHeight: window.innerHeight,
      hasBody: !!body,
      originalX: window.scrollX,
      originalY: window.scrollY,
      originalOverflowStyle: document.documentElement.style.overflow,
      originalBodyOverflowYStyle: body && body.style.overflowY,
      devicePixelRatio: window.devicePixelRatio
    };

    return data;
  },
  startCapture: function startCapture() {
    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref9$hideScrollbar = _ref9.hideScrollbar,
        hideScrollbar = _ref9$hideScrollbar === undefined ? true : _ref9$hideScrollbar;

    var body = document.body;
    var pageInfo = captureClientAPI.getPageInfo();

    // Note: try to make pages with bad scrolling work, e.g., ones with
    // `body { overflow-y: scroll; }` can break `window.scrollTo`
    if (body) {
      body.style.overflowY = 'visible';
    }

    if (hideScrollbar) {
      // Disable all scrollbars. We'll restore the scrollbar state when we're done
      // taking the screenshots.
      document.documentElement.style.overflow = 'hidden';
    }

    return Promise.resolve(pageInfo);
  },
  scrollPage: function scrollPage(_ref10) {
    var x = _ref10.x,
        y = _ref10.y;

    window.scrollTo(x, y);

    return Object(_common_utils__WEBPACK_IMPORTED_MODULE_3__["delay"])(function () {
      return {
        x: window.scrollX,
        y: window.scrollY
      };
    }, 100);
  },
  endCapture: function endCapture(pageInfo) {
    var originalX = pageInfo.originalX,
        originalY = pageInfo.originalY,
        hasBody = pageInfo.hasBody,
        originalOverflowStyle = pageInfo.originalOverflowStyle,
        originalBodyOverflowYStyle = pageInfo.originalBodyOverflowYStyle;


    if (hasBody) {
      document.body.style.overflowY = originalBodyOverflowYStyle;
    }

    document.documentElement.style.overflow = originalOverflowStyle;
    window.scrollTo(originalX, originalY);

    return Promise.resolve(true);
  }
};

function saveFullScreen(tabId, fileName, clientAPI) {
  return captureFullScreen(tabId, clientAPI, { blob: true }).then(function (screenBlob) {
    return Object(_common_screenshot_man__WEBPACK_IMPORTED_MODULE_2__["getScreenshotMan"])().overwrite(fileName, screenBlob).then(function (url) {
      return {
        url: url,
        fileName: fileName
      };
    });
  });
}

/***/ }),

/***/ "./src/common/command_runner.js":
/*!**************************************!*\
  !*** ./src/common/command_runner.js ***!
  \**************************************/
/*! exports provided: getElementByLocator, getFrameByLocator, run */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElementByLocator", function() { return getElementByLocator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFrameByLocator", function() { return getFrameByLocator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });
/* harmony import */ var kd_glob_to_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kd-glob-to-regexp */ "./node_modules/kd-glob-to-regexp/index.js");
/* harmony import */ var kd_glob_to_regexp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(kd_glob_to_regexp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/common/utils.js");
/* harmony import */ var _dom_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom_utils */ "./src/common/dom_utils.js");
/* harmony import */ var _ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ipc/cs_postmessage */ "./src/common/ipc/cs_postmessage.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log */ "./src/common/log.js");
/* harmony import */ var _drag_mock__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drag_mock */ "./src/common/drag_mock/index.js");
/* harmony import */ var _drag_mock__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_drag_mock__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _send_keys__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./send_keys */ "./src/common/send_keys.js");
/* harmony import */ var _encrypt__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./encrypt */ "./src/common/encrypt.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./constant */ "./src/common/constant.js");
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var HIGHLIGHT_TIMEOUT = 500;

var globMatch = function globMatch(pattern, text) {
  return kd_glob_to_regexp__WEBPACK_IMPORTED_MODULE_0___default()(pattern).test(text);
};

var getElementByXPath = function getElementByXPath(xpath) {
  var snapshot = document.evaluate(xpath, document.body, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

  return snapshot.snapshotItem(0);
};

// reference: https://github.com/timoxley/offset
var viewportOffset = function viewportOffset(el) {
  var box = el.getBoundingClientRect();

  // Note: simply use bouddingClientRect since elementFromPoint uses
  // the same top/left relative to the current viewport/window instead of whole document
  return {
    top: box.top,
    left: box.left
  };
};

var untilInjected = function untilInjected() {
  var api = {
    eval: function _eval(code) {
      Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('sending INJECT_RUN_EVAL');
      return Object(_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window, window, { cmd: 'INJECT_RUN_EVAL', args: { code: code } }, '*', 5000).then(function (data) {
        Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('eval result', data);
        return data.result;
      });
    }
  };
  var injected = !!document.body.getAttribute('data-injected');
  if (injected) return Promise.resolve(api);

  Object(_utils__WEBPACK_IMPORTED_MODULE_1__["insertScript"])(_web_extension__WEBPACK_IMPORTED_MODULE_4___default.a.extension.getURL('inject.js'));

  return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["retry"])(function () {
    Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('sending INJECT_READY');
    return Object(_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window, window, { cmd: 'INJECT_READY' }, '*', 500);
  }, {
    shouldRetry: function shouldRetry() {
      return true;
    },
    timeout: 5000,
    retryInterval: 0
  })().then(function () {
    return api;
  }).catch(function (e) {
    Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])(e.stack);
    throw new Error('fail to inject');
  });
};

var isElementFromPoint = function isElementFromPoint(str) {
  return (/^#elementfrompoint/i.test(str.trim())
  );
};

var pageCoordinateByElementFromPoint = function pageCoordinateByElementFromPoint(str) {
  var reg = /^#elementfrompoint\s*\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/i;
  var m = str.trim().match(reg);

  if (!m) {
    throw new Error('Invalid \'#elementfrompoint\' expression');
  }

  var pageX = parseFloat(m[1]);
  var pageY = parseFloat(m[2]);

  if (pageX <= 0 || pageY <= 0) {
    throw new Error('\'#elementfrompoint\' only accepts positive numbers');
  }

  return [pageX, pageY];
};

var viewportCoordinateByElementFromPoint = function viewportCoordinateByElementFromPoint(str) {
  var _pageCoordinateByElem = pageCoordinateByElementFromPoint(str),
      _pageCoordinateByElem2 = _slicedToArray(_pageCoordinateByElem, 2),
      pageX = _pageCoordinateByElem2[0],
      pageY = _pageCoordinateByElem2[1];

  var offset = 0;
  var x = offset + pageX - Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["scrollLeft"])(document);
  var y = offset + pageY - Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["scrollTop"])(document);

  return [x, y];
};

var elementByElementFromPoint = function elementByElementFromPoint(str) {
  var _viewportCoordinateBy = viewportCoordinateByElementFromPoint(str),
      _viewportCoordinateBy2 = _slicedToArray(_viewportCoordinateBy, 2),
      x = _viewportCoordinateBy2[0],
      y = _viewportCoordinateBy2[1];

  var el = document.elementFromPoint(x, y);

  return el;
};

// Note: parse the locator and return the element found accordingly
var getElementByLocator = function getElementByLocator(str, shouldWaitForVisible) {
  var i = str.indexOf('=');
  var el = void 0;

  if (/^\//.test(str)) {
    el = getElementByXPath(str);
  } else if (/^#elementfrompoint/i.test(str.trim())) {
    el = elementByElementFromPoint(str);
    Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('elementfrompoint', el);
  } else if (i === -1) {
    throw new Error('getElementByLocator: invalid locator, ' + str);
  } else {
    var method = str.substr(0, i);
    var value = str.substr(i + 1);

    switch (method && method.toLowerCase()) {
      case 'id':
        el = document.getElementById(value);
        break;

      case 'name':
        el = document.getElementsByName(value)[0];
        break;

      case 'identifier':
        el = document.getElementById(value) || document.getElementsByName(value)[0];
        break;

      case 'link':
        {
          var links = [].slice.call(document.getElementsByTagName('a'));
          // Note: there are cases such as 'link=exact:xxx'
          var realVal = value.replace(/^exact:/, '');
          // Note: position support. eg. link=Download@POS=3
          var match = realVal.match(/^(.+)@POS=(\d+)$/i);
          var index = 0;

          if (match) {
            realVal = match[1];
            index = parseInt(match[2]) - 1;
          }

          // Note: use textContent instead of innerText to avoid influence from text-transform
          var candidates = links.filter(function (a) {
            return globMatch(realVal, Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["domText"])(a));
          });
          el = candidates[index];
          break;
        }

      case 'css':
        el = document.querySelector(value);
        break;

      case 'xpath':
        el = getElementByXPath(value);
        break;

      default:
        throw new Error('getElementByLocator: unsupported locator method, ' + method);
    }
  }

  if (!el) {
    throw new Error('getElementByLocator: fail to find element based on the locator, ' + str);
  }

  if (shouldWaitForVisible && !Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["isVisible"])(el)) {
    throw new Error('getElementByLocator: element is found but not visible yet');
  }

  return el;
};

var getFrameByLocator = function getFrameByLocator(str, helpers) {
  var i = str.indexOf('=');

  // Note: try to parse format of 'index=0' and 'relative=top/parent'
  if (i !== -1) {
    var method = str.substr(0, i);
    var value = str.substr(i + 1);

    switch (method) {
      case 'index':
        {
          var index = parseInt(value, 10);
          var frames = window.frames;
          var frame = frames[index];

          if (!frame) {
            throw new Error('Frame index out of range (index ' + value + ' in ' + frames.length + ' frames');
          }

          return { frame: frame };
        }

      case 'relative':
        {
          if (value === 'top') {
            return { frame: window.top };
          }

          if (value === 'parent') {
            return { frame: window.parent };
          }

          throw new Error('Unsupported relative type, ' + value);
        }
    }
  }

  // Note: consider it as name, if no '=' found and it has no xpath pattern
  if (i === -1 && !/^\//.test(str)) {
    str = 'name=' + str;
  }

  var frameDom = getElementByLocator(str);

  if (!frameDom || !frameDom.contentWindow) {
    throw new Error('The element found based on ' + str + ' is NOT a frame/iframe');
  }

  // Note: for those iframe/frame that don't have src, they won't load content_script.js
  // so we have to inject the script by ourselves
  if (!frameDom.getAttribute('src')) {
    var file = _web_extension__WEBPACK_IMPORTED_MODULE_4___default.a.extension.getURL('content_script.js');
    var doc = frameDom.contentDocument;
    var s = doc.constructor.prototype.createElement.call(doc, 'script');

    s.setAttribute('type', 'text/javascript');
    s.setAttribute('src', file);

    doc.documentElement.appendChild(s);
    s.parentNode.removeChild(s);

    helpers.hackAlertConfirmPrompt(doc);
  }

  // Note: can't return the contentWindow directly, because Promise 'resolve' will
  // try to test its '.then' method, which will cause a cross origin violation
  // so, we wrap it in an object
  return { frame: frameDom.contentWindow };
};

var run = function run(command, csIpc, helpers) {
  var cmd = command.cmd,
      target = command.target,
      value = command.value,
      extra = command.extra;

  var wrap = function wrap(fn, genOptions) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var options = genOptions.apply(undefined, args);

      return new Promise(function (resolve, reject) {
        try {
          resolve(fn.apply(undefined, args));
        } catch (e) {
          reject(new Error(options.errorMsg(e.message)));
        }
      });
    };
  };
  var getElementByLocatorWithLogForEfp = function getElementByLocatorWithLogForEfp(locator, shouldWaitForVisible) {
    var el = getElementByLocator(locator, shouldWaitForVisible);

    if (isElementFromPoint(locator)) {
      var elXpath = 'unkown';

      try {
        elXpath = helpers.xpath(el);
      } catch (e) {}

      var msg = locator + ' => xpath "' + elXpath + '"';

      console.log(msg, el);
      csIpc.ask('CS_ADD_LOG', { info: msg });
    }

    return el;
  };
  var __getFrameByLocator = wrap(getFrameByLocator, function (locator) {
    return {
      errorMsg: function errorMsg(msg) {
        return 'timeout reached when looking for frame \'' + locator + '\'';
      }
    };
  });
  var __getElementByLocator = wrap(getElementByLocatorWithLogForEfp, function (locator) {
    return {
      errorMsg: function errorMsg(msg) {
        if (/element is found but not visible yet/.test(msg)) {
          return 'element is found but not visible yet for \'' + locator + '\' (use !WaitForVisible = false to disable waiting for visible)';
        }

        return 'timeout reached when looking for element \'' + locator + '\'';
      }
    };
  });

  switch (cmd) {
    case 'open':
      if (window.noCommandsYet) {
        return true;
      }

      return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["until"])('document.body', function () {
        return {
          pass: !!document.body,
          result: document.body
        };
      }).then(function (body) {
        window.location.href = command.target;
        return true;
      });

    case 'refresh':
      setTimeout(function () {
        return window.location.reload();
      }, 0);
      return true;

    case 'mouseOver':
      {
        return __getElementByLocator(target).then(function (el) {
          try {
            if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
            if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
          } catch (e) {
            _log__WEBPACK_IMPORTED_MODULE_5__["default"].error('error in scroll and highlight', e.message);
          }

          el.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
          return true;
        });
      }

    case 'dragAndDropToObject':
      {
        return Promise.all([__getElementByLocator(target), __getElementByLocator(value)]).then(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              $src = _ref2[0],
              $tgt = _ref2[1];

          _drag_mock__WEBPACK_IMPORTED_MODULE_6___default.a.triggerDragEvent($src, $tgt);
          return true;
        });
      }

    case 'waitForVisible':
      {
        return __getElementByLocator(target, true).then(function () {
          return true;
        });
      }

    case 'clickAt':
      {
        var getIframeOffset = function getIframeOffset() {
          if (window === window.top) {
            return Promise.resolve({ x: 0, y: 0 });
          }

          return Object(_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
            action: 'SOURCE_PAGE_OFFSET',
            data: {}
          });
        };
        var isEfp = isElementFromPoint(target);
        var pTarget = function () {
          if (!isEfp) return Promise.resolve(target);
          return getIframeOffset().then(function (iframeOffset) {
            Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('iframeOffset', iframeOffset);

            var _viewportCoordinateBy3 = viewportCoordinateByElementFromPoint(target),
                _viewportCoordinateBy4 = _slicedToArray(_viewportCoordinateBy3, 2),
                x = _viewportCoordinateBy4[0],
                y = _viewportCoordinateBy4[1];

            return '#elementfrompoint (' + (x - iframeOffset.x) + ', ' + (y - iframeOffset.y) + ')';
          });
        }();

        return pTarget.then(function (target) {
          return __getElementByLocator(target, extra.waitForVisible).then(function (el) {
            if (!/^\d+\s*,\s*\d+$/.test(value) && !isElementFromPoint(target)) {
              throw new Error('invalid offset for clickAt: ' + value);
            }

            var scrollAndHighlight = function scrollAndHighlight() {
              try {
                if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
                if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
              } catch (e) {
                _log__WEBPACK_IMPORTED_MODULE_5__["default"].error('error in scroll and highlight');
              }
            };

            var _ref3 = function () {
              if (isEfp) {
                return viewportCoordinateByElementFromPoint(target);
              } else {
                var _value$split$map = value.split(',').map(function (str) {
                  return parseInt(str.trim(), 10);
                }),
                    _value$split$map2 = _slicedToArray(_value$split$map, 2),
                    x = _value$split$map2[0],
                    y = _value$split$map2[1];

                var _viewportOffset = viewportOffset(el),
                    top = _viewportOffset.top,
                    left = _viewportOffset.left;

                return [left + x, top + y];
              }
            }(),
                _ref4 = _slicedToArray(_ref3, 2),
                origClientX = _ref4[0],
                origClientY = _ref4[1];

            var lastScrollX = window.scrollX;
            var lastScrollY = window.scrollY;

            if (!isEfp) scrollAndHighlight();

            var clientX = origClientX + (lastScrollX - window.scrollX);
            var clientY = origClientY + (lastScrollY - window.scrollY);

            Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('clickAt clientX/clientY', clientX, clientY);['mousedown', 'mouseup', 'click'].forEach(function (eventType) {
              el.dispatchEvent(new MouseEvent(eventType, {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: clientX,
                clientY: clientY
              }));
            });

            // Note: delay scroll and highlight for efp,
            // otherwise that scroll could mess up the whole coodirnate calculation
            if (isEfp) scrollAndHighlight();

            return true;
          });
        });
      }

    case 'click':
    case 'clickAndWait':
      {
        return __getElementByLocator(target, extra.waitForVisible).then(function (el) {
          try {
            if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
            if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
          } catch (e) {
            _log__WEBPACK_IMPORTED_MODULE_5__["default"].error('error in scroll and highlight');
          }

          el.click();
          return true;
        });
      }

    case 'select':
    case 'selectAndWait':
      {
        return __getElementByLocator(target, extra.waitForVisible).then(function (el) {
          var options = [].slice.call(el.getElementsByTagName('option'));
          var i = value.indexOf('=');
          var optionType = value.substring(0, i);
          var optionValue = value.substring(i + 1);

          var option = function () {
            switch (optionType) {
              case 'label':
                return options.find(function (op) {
                  return globMatch(optionValue, Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["domText"])(op).trim());
                });

              case 'index':
                return options.find(function (_, index) {
                  return index === parseInt(optionValue);
                });

              case 'id':
                return options.find(function (op, index) {
                  return op.id === optionValue;
                });

              case 'value':
                return options.find(function (op) {
                  return op.value === optionValue;
                });

              default:
                throw new Error('Option type "' + optionType + '" not supported');
            }
          }();

          if (!option) {
            throw new Error('cannot find option with \'' + value + '\'');
          }

          if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
          if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);

          el.value = option.value;
          el.dispatchEvent(new Event('change'));

          return true;
        });
      }

    case 'type':
      {
        return __getElementByLocator(target, extra.waitForVisible).then(function (el) {
          var tag = el.tagName.toLowerCase();

          if (tag !== 'input' && tag !== 'textarea') {
            throw new Error('run command: element found is neither input nor textarea');
          }

          if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
          if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);

          // Note: need the help of chrome.debugger to set file path to file input
          if (el.type && el.type.toLowerCase() === 'file') {
            if (_web_extension__WEBPACK_IMPORTED_MODULE_4___default.a.isFirefox()) {
              throw new Error('Setting file path fo file inputs is not supported by Firefox extension api yet');
            }

            return csIpc.ask('CS_SET_FILE_INPUT_FILES', {
              files: value.split(';'),
              selector: Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["cssSelector"])(el)
            });
          }

          return Object(_encrypt__WEBPACK_IMPORTED_MODULE_8__["decryptIfNeeded"])(value, el).then(function (realValue) {
            el.value = '';
            Object(_send_keys__WEBPACK_IMPORTED_MODULE_7__["default"])(el, realValue, true);

            el.value = realValue;
            el.dispatchEvent(new Event('change'));
            return true;
          });
        }).catch(function (e) {
          if (/This input element accepts a filename/i.test(e.message)) {
            throw new Error('Sorry, upload can not be automated Chrome (API limitation).');
          }

          throw e;
        });
      }

    case 'editContent':
      {
        return __getElementByLocator(target, extra.waitForVisible).then(function (el) {
          if (el.contentEditable !== 'true') {
            throw new Error('Target is not contenteditable');
          }

          if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
          if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);

          el.innerHTML = value;
          return true;
        });
      }

    case 'selectFrame':
      {
        return __getFrameByLocator(target, helpers).then(function (frameWindow) {
          if (!frameWindow) {
            throw new Error('Invalid frame/iframe');
          }

          return frameWindow;
        });
      }

    case 'verifyText':
      {
        return __getElementByLocator(target).then(function (el) {
          var text = Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["domText"])(el);

          if (!globMatch(value, text)) {
            return {
              log: {
                error: 'text not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"'
              }
            };
          }

          return true;
        });
      }

    case 'verifyTitle':
      {
        if (!globMatch(target, document.title)) {
          return {
            log: {
              error: 'title not matched, \n\texpected: "' + target + '", \n\tactual: "' + document.title + '"'
            }
          };
        }

        return true;
      }

    case 'verifyElementPresent':
      {
        var _ref5 = extra || {},
            timeoutElement = _ref5.timeoutElement,
            retryInfo = _ref5.retryInfo;

        return __getElementByLocator(target).then(function () {
          return true;
        }, function (e) {
          var shotsLeft = timeoutElement * 1000 / retryInfo.retryInterval - retryInfo.retryCount;
          var isLastChance = shotsLeft <= 1;

          if (isLastChance) {
            return {
              log: {
                error: '\'' + target + '\' element not present'
              }
            };
          }

          throw e;
        });
      }

    case 'verifyChecked':
      {
        return __getElementByLocator(target).then(function (el) {
          var checked = !!el.checked;

          if (!checked) {
            return {
              log: {
                error: '\'' + target + '\' is not checked'
              }
            };
          }
        });
      }

    case 'verifyAttribute':
      {
        var index = target.lastIndexOf('@');

        if (index === -1) {
          throw new Error('invalid target for verifyAttribute - ' + target);
        }

        var locator = target.substr(0, index);
        var attrName = target.substr(index + 1);

        return __getElementByLocator(locator).then(function (el) {
          var attr = el.getAttribute(attrName);

          if (!globMatch(value, attr)) {
            return {
              log: {
                error: 'attribute not matched, \n\texpected: "' + value + '", \n\tactual: "' + attr + '"'
              }
            };
          }
        });
      }

    case 'verifyError':
      {
        if (extra.lastCommandOk) {
          return {
            log: {
              error: target
            }
          };
        }

        return true;
      }

    case 'assertText':
      {
        return __getElementByLocator(target).then(function (el) {
          var text = Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["domText"])(el);

          if (!globMatch(value, text)) {
            throw new Error('text not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"');
          }

          return true;
        });
      }

    case 'assertTitle':
      {
        if (!globMatch(target, document.title)) {
          throw new Error('title not matched, \n\texpected: "' + target + '", \n\tactual: "' + document.title + '"');
        }

        return true;
      }

    case 'assertElementPresent':
      {
        return __getElementByLocator(target).then(function () {
          return true;
        });
      }

    case 'assertChecked':
      {
        return __getElementByLocator(target).then(function (el) {
          var checked = !!el.checked;

          if (!checked) {
            throw new Error('\'' + target + '\' is not checked');
          }
        });
      }

    case 'assertAttribute':
      {
        var _index = target.lastIndexOf('@');

        if (_index === -1) {
          throw new Error('invalid target for assertAttribute - ' + target);
        }

        var _locator = target.substr(0, _index);
        var _attrName = target.substr(_index + 1);

        return __getElementByLocator(_locator).then(function (el) {
          var attr = el.getAttribute(_attrName);

          if (!globMatch(value, attr)) {
            throw new Error('attribute not matched, \n\texpected: "' + value + '", \n\tactual: "' + attr + '"');
          }
        });
      }

    case 'assertError':
      {
        if (extra.lastCommandOk) {
          throw new Error(target);
        }

        return true;
      }

    case 'assertAlert':
      {
        var msg = document.body.getAttribute('data-alert');

        if (!msg) {
          throw new Error('no alert found!');
        }

        if (!globMatch(target, msg)) {
          throw new Error('unmatched alert msg, \n\texpected: "' + target + '", \n\tactual: "' + msg + '"');
        }

        document.body.setAttribute('data-alert', '');
        return true;
      }

    case 'assertConfirmation':
      {
        var _msg = document.body.getAttribute('data-confirm');

        if (!_msg) {
          throw new Error('no confirm found!');
        }

        if (!globMatch(target, _msg)) {
          throw new Error('unmatched confirm msg, \n\texpected: "' + target + '", \n\tactual: "' + _msg + '"');
        }

        document.body.setAttribute('data-confirm', '');
        return true;
      }

    case 'assertPrompt':
      {
        var _msg2 = document.body.getAttribute('data-prompt');

        if (!_msg2) {
          throw new Error('no prompt found!');
        }

        if (!globMatch(target, _msg2)) {
          throw new Error('unmatched prompt msg, \n\texpected: "' + target + '", \n\tactual: "' + _msg2 + '"');
        }

        document.body.setAttribute('data-prompt', '');
        return true;
      }

    case 'answerOnNextPrompt':
      {
        document.body.setAttribute('data-prompt-answer', target);
        return true;
      }

    case 'waitForPageToLoad':
      return true;

    case 'storeTitle':
      {
        return {
          vars: _defineProperty({}, value, document.title)
        };
      }

    case 'storeText':
      {
        return __getElementByLocator(target).then(function (el) {
          return {
            vars: _defineProperty({}, value, Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["domText"])(el))
          };
        });
      }

    case 'storeAttribute':
      {
        var _index2 = target.lastIndexOf('@');

        if (_index2 === -1) {
          throw new Error('invalid target for storeAttribute - ' + target);
        }

        var _locator2 = target.substr(0, _index2);
        var _attrName2 = target.substr(_index2 + 1);

        return __getElementByLocator(_locator2).then(function (el) {
          var attr = el.getAttribute(_attrName2);

          if (!attr) {
            throw new Error('missing attribute \'' + _attrName2 + '\'');
          }

          return {
            vars: _defineProperty({}, value, attr)
          };
        });
      }

    case 'storeEval':
      {
        return untilInjected().then(function (api) {
          return api.eval(target).then(function (result) {
            return {
              vars: _defineProperty({}, value, result)
            };
          }).catch(function (e) {
            throw new Error('Error in runEval code: ' + e.message);
          });
        });
      }

    case 'storeValue':
      {
        return __getElementByLocator(target).then(function (el) {
          var text = el.value || '';

          return {
            vars: _defineProperty({}, value, text)
          };
        });
      }

    case 'storeChecked':
      {
        return __getElementByLocator(target).then(function (el) {
          var checked = !!el.checked;

          return {
            vars: _defineProperty({}, value, checked)
          };
        });
      }

    case 'verifyValue':
      {
        return __getElementByLocator(target).then(function (el) {
          var text = el.value;

          if (!globMatch(value, text)) {
            return {
              log: {
                error: 'value not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"'
              }
            };
          }

          return true;
        });
      }

    case 'assertValue':
      {
        return __getElementByLocator(target).then(function (el) {
          var text = el.value;

          if (!globMatch(value, text)) {
            throw new Error('value not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"');
          }

          return true;
        });
      }

    case 'sendKeys':
      {
        return __getElementByLocator(target).then(function (el) {
          Object(_send_keys__WEBPACK_IMPORTED_MODULE_7__["default"])(el, value);
          return true;
        });
      }

    case 'selectWindow':
      {
        var p = target && target.toUpperCase() === 'TAB=CLOSEALLOTHER' ? csIpc.ask('CS_CLOSE_OTHER_TABS', {}) : csIpc.ask('CS_SELECT_WINDOW', { target: target, value: value });

        // Note: let `selectWindow` pass through cs and back to background,
        // to keep the flow more consistent with the other commands
        return p.then(function () {
          return true;
        });
      }

    case 'sourceSearch':
    case 'sourceExtract':
      {
        if (!target) {
          throw new Error('Must provide text / regular expression to search for');
        }

        if (!value) {
          throw new Error('Must specify a variable to save the result');
        }

        var getMatchAndCaptureIndex = function getMatchAndCaptureIndex(str) {
          var nonZeroIndex = function nonZeroIndex(n) {
            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            if (n === undefined) return 0;
            return Math.max(0, parseInt(n, 10) + offset);
          };
          var m = /@\s*(\d+)(?:\s*,\s*(\d+))?\s*$/.exec(str);

          if (!m) {
            return {
              rest: str,
              matchIndex: 0,
              captureIndex: 0
            };
          }

          return {
            rest: str.substring(0, m.index),
            matchIndex: nonZeroIndex(m[1], -1),
            captureIndex: nonZeroIndex(m[2])
          };
        };

        // Note: get matchIndex captureIndex first, no matter it's for regexp or simple text

        var _getMatchAndCaptureIn = getMatchAndCaptureIndex(target),
            rest = _getMatchAndCaptureIn.rest,
            matchIndex = _getMatchAndCaptureIn.matchIndex,
            captureIndex = _getMatchAndCaptureIn.captureIndex;

        if (cmd === 'sourceSearch' && rest !== target) {
          throw new Error('The @ parameter is only supported in sourceExtract');
        }

        var regexp = function () {
          if (!/^regex(=|:)/i.test(rest)) return null;

          var raw = rest.replace(/^regex(=|:)/i, '');
          var regexpText = raw.replace(/^\/|\/g?$/g, '');

          return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["toRegExp"])(regexpText, { needEncode: false, flag: 'g' });
        }();
        var regexpForText = function () {
          if (regexp) return null;
          var raw = rest.replace(/^text(=|:)/i, '');

          if (cmd === 'sourceExtract' && !/\*/.test(raw)) {
            throw new Error('Missing * or REGEX in sourceExtract. Extracting a plain text doesn\'t make much sense');
          }

          return kd_glob_to_regexp__WEBPACK_IMPORTED_MODULE_0___default()(raw, { capture: true, flags: 'g' });
        }();
        var matches = function () {
          var html = document.documentElement.outerHTML;
          var reg = regexp || regexpForText;
          var result = [];
          var m = void 0;

          // eslint-disable-next-line no-cond-assign
          while (m = reg.exec(html)) {
            result.push(m);

            // Note: save some energy, if it's already enough to get what users want
            if (cmd === 'sourceExtract' && result.length >= matchIndex + 1) {
              break;
            }
          }

          return result;
        }();

        Object(_log__WEBPACK_IMPORTED_MODULE_5__["default"])('matches', matches, regexp, regexpForText);

        if (cmd === 'sourceSearch') {
          return {
            vars: _defineProperty({}, value, matches.length)
          };
        }

        if (cmd === 'sourceExtract') {
          var guard = function guard(str) {
            return str !== undefined ? str : '#nomatchfound';
          };

          return {
            vars: _defineProperty({}, value, guard((matches[matchIndex] || [])[captureIndex]))
          };
        }

        throw new Error('Impossible to reach here');
      }

    case 'visionLimitSearchArea':
    case 'storeImage':
      {
        var _run = function _run(locator, fileName) {
          return __getElementByLocator(locator).then(function (el) {
            if (!fileName || !fileName.length) {
              throw new Error('storeImage: \'value\' is required as image name');
            }

            var clientRect = el.getBoundingClientRect();
            var pSourceOffset = function () {
              if (window.top === window) {
                return Promise.resolve({ x: 0, y: 0 });
              }

              // Note: it's too complicated to take screenshot of element deep in iframe stack
              // if you have to scroll each level of iframe to get the full image of it.
              el.scrollIntoView();

              return Object(_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
                action: 'SOURCE_PAGE_OFFSET',
                data: {}
              });
            }();

            return pSourceOffset.then(function (sourceOffset) {
              var rect = {
                x: sourceOffset.x + clientRect.x + Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["scrollLeft"])(document),
                y: sourceOffset.y + clientRect.y + Object(_dom_utils__WEBPACK_IMPORTED_MODULE_2__["scrollTop"])(document),
                width: clientRect.width,
                height: clientRect.height
              };

              return csIpc.ask('CS_STORE_SCREENSHOT_IN_SELECTION', {
                rect: rect,
                fileName: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["ensureExtName"])('.png', fileName),
                devicePixelRatio: window.devicePixelRatio
              }).then(function () {
                return {
                  vars: {
                    '!storedImageRect': rect
                  }
                };
              });
            });
          });
        };

        var _locator3 = void 0,
            fileName = void 0;

        if (cmd === 'storeImage') {
          _locator3 = target;
          fileName = value;
        } else if (cmd === 'visionLimitSearchArea') {
          _locator3 = target.trim().replace(/^element:/i, '').trim();
          fileName = _constant__WEBPACK_IMPORTED_MODULE_9__["LAST_SCREENSHOT_FILE_NAME"];
        }

        return _run(_locator3, fileName);
      }

    case 'captureScreenshot':
      {
        if (!target || !target.length) {
          throw new Error('captureScreenshot: \'target\' is required as file name');
        }

        return csIpc.ask('CS_CAPTURE_SCREENSHOT', { fileName: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["ensureExtName"])('.png', target) }).then(function (_ref6) {
          var fileName = _ref6.fileName,
              url = _ref6.url;
          return {
            screenshot: {
              url: url,
              name: fileName
            }
          };
        });
      }

    case 'captureEntirePageScreenshot':
      {
        if (!target || !target.length) {
          throw new Error('captureEntirePageScreenshot: \'target\' is required as file name');
        }

        return csIpc.ask('CS_CAPTURE_FULL_SCREENSHOT', { fileName: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["ensureExtName"])('.png', target) }).then(function (_ref7) {
          var fileName = _ref7.fileName,
              url = _ref7.url;
          return {
            screenshot: {
              url: url,
              name: fileName
            }
          };
        });
      }

    case 'onDownload':
      {
        return csIpc.ask('CS_ON_DOWNLOAD', {
          fileName: target,
          wait: (value || '').trim() === 'true',
          timeout: extra.timeoutDownload * 1000,
          timeoutForStart: Math.max(10, extra.timeoutElement) * 1000
        });
      }

    case 'deleteAllCookies':
      {
        return csIpc.ask('CS_DELETE_ALL_COOKIES', {
          url: window.location.origin
        }).then(function () {
          return true;
        });
      }

    case 'if':
    case 'while':
    case 'gotoIf':
      {
        try {
          return {
            // eslint-disable-next-line no-eval
            condition: window.eval(target)
          };
        } catch (e) {
          throw new Error('Error in runEval condition of ' + cmd + ': ' + e.message);
        }
      }

    default:
      throw new Error('Command ' + cmd + ' not supported yet');
  }
};

/***/ }),

/***/ "./src/common/constant.js":
/*!********************************!*\
  !*** ./src/common/constant.js ***!
  \********************************/
/*! exports provided: APP_STATUS, INSPECTOR_STATUS, RECORDER_STATUS, PLAYER_STATUS, PLAYER_MODE, CONTENT_SCRIPT_STATUS, TEST_CASE_STATUS, LAST_SCREENSHOT_FILE_NAME */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "APP_STATUS", function() { return APP_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INSPECTOR_STATUS", function() { return INSPECTOR_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RECORDER_STATUS", function() { return RECORDER_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLAYER_STATUS", function() { return PLAYER_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLAYER_MODE", function() { return PLAYER_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONTENT_SCRIPT_STATUS", function() { return CONTENT_SCRIPT_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEST_CASE_STATUS", function() { return TEST_CASE_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAST_SCREENSHOT_FILE_NAME", function() { return LAST_SCREENSHOT_FILE_NAME; });

var mk = function mk(list) {
  return list.reduce(function (prev, key) {
    prev[key] = key;
    return prev;
  }, {});
};

var APP_STATUS = mk(['NORMAL', 'INSPECTOR', 'RECORDER', 'PLAYER']);

var INSPECTOR_STATUS = mk(['PENDING', 'INSPECTING', 'STOPPED']);

var RECORDER_STATUS = mk(['PENDING', 'RECORDING', 'STOPPED']);

var PLAYER_STATUS = mk(['PLAYING', 'PAUSED', 'STOPPED']);

var PLAYER_MODE = mk(['TEST_CASE', 'TEST_SUITE']);

var CONTENT_SCRIPT_STATUS = mk(['NORMAL', 'RECORDING', 'INSPECTING', 'PLAYING']);

var TEST_CASE_STATUS = mk(['NORMAL', 'SUCCESS', 'ERROR']);

var LAST_SCREENSHOT_FILE_NAME = '__lastscreenshot';

/***/ }),

/***/ "./src/common/dom_utils.js":
/*!*********************************!*\
  !*** ./src/common/dom_utils.js ***!
  \*********************************/
/*! exports provided: getStyle, setStyle, pixel, bindDrag, bindContentEditableChange, scrollLeft, scrollTop, domText, isVisible, cssSelector, isPositionFixed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStyle", function() { return getStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStyle", function() { return setStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pixel", function() { return pixel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindDrag", function() { return bindDrag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindContentEditableChange", function() { return bindContentEditableChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollLeft", function() { return scrollLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollTop", function() { return scrollTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "domText", function() { return domText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVisible", function() { return isVisible; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssSelector", function() { return cssSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPositionFixed", function() { return isPositionFixed; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/common/utils.js");
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }



var getStyle = function getStyle(dom) {
  if (!dom) throw new Error('getStyle: dom does not exist');
  return getComputedStyle(dom);
};

var setStyle = function setStyle(dom, style) {
  if (!dom) throw new Error('setStyle: dom does not exist');

  for (var i = 0, keys = Object.keys(style), len = keys.length; i < len; i++) {
    dom.style[keys[i]] = style[keys[i]];
  }

  return dom;
};

var pixel = function pixel(num) {
  if ((num + '').indexOf('px') !== -1) return num;
  return (num || 0) + 'px';
};

var bindDrag = function bindDrag(_ref) {
  var onDragStart = _ref.onDragStart,
      onDragEnd = _ref.onDragEnd,
      onDrag = _ref.onDrag,
      $el = _ref.$el,
      _ref$doc = _ref.doc,
      doc = _ref$doc === undefined ? document : _ref$doc;

  var isDragging = false;
  var startPos = { x: 0, y: 0 };

  var onMouseDown = function onMouseDown(e) {
    isDragging = true;
    startPos = { x: e.screenX, y: e.screenY };
    onDragStart(e);
  };
  var onMouseUp = function onMouseUp(e) {
    if (!isDragging) return;
    isDragging = false;
    var dx = e.screenX - startPos.x;
    var dy = e.screenY - startPos.y;
    onDragEnd(e, { dx: dx, dy: dy });
  };
  var onMouseMove = function onMouseMove(e) {
    if (!isDragging) return;

    var dx = e.screenX - startPos.x;
    var dy = e.screenY - startPos.y;
    onDrag(e, { dx: dx, dy: dy });

    e.preventDefault();
    e.stopPropagation();
  };
  var onClick = function onClick(e) {
    e.preventDefault();
    e.stopPropagation();
  };

  doc.addEventListener('click', onClick, true);
  doc.addEventListener('mousemove', onMouseMove, true);
  doc.addEventListener('mouseup', onMouseUp, true);
  $el.addEventListener('mousedown', onMouseDown, true);

  return function () {
    doc.removeEventListener('click', onClick, true);
    doc.removeEventListener('mousemove', onMouseMove, true);
    doc.removeEventListener('mouseup', onMouseUp, true);
    $el.removeEventListener('mousedown', onMouseDown, true);
  };
};

var bindContentEditableChange = function bindContentEditableChange(_ref2) {
  var onChange = _ref2.onChange,
      _ref2$doc = _ref2.doc,
      doc = _ref2$doc === undefined ? document : _ref2$doc;

  var currentCE = null;
  var oldContent = null;

  var onFocus = function onFocus(e) {
    if (e.target.contentEditable !== 'true') return;
    currentCE = e.target;
    oldContent = currentCE.innerHTML;
  };
  var onBlur = function onBlur(e) {
    if (e.target !== currentCE) {
      // Do nothing
    } else if (currentCE.innerHTML !== oldContent) {
      onChange(e);
    }

    currentCE = null;
    oldContent = null;
  };

  doc.addEventListener('focus', onFocus, true);
  doc.addEventListener('blur', onBlur, true);

  return function () {
    doc.removeEventListener('focus', onFocus, true);
    doc.removeEventListener('blur', onBlur, true);
  };
};

var scrollLeft = function scrollLeft(document) {
  return document.documentElement.scrollLeft;
};

var scrollTop = function scrollTop(document) {
  return document.documentElement.scrollTop;
};

var domText = function domText($dom) {
  var it = $dom.innerText && $dom.innerText.trim();
  var tc = $dom.textContent;
  var pos = tc.toUpperCase().indexOf(it.toUpperCase());

  return tc.substr(pos, it.length);
};

var isVisible = function isVisible(el) {
  if (el === window.document) return true;
  if (!el) return true;

  var style = window.getComputedStyle(el);
  if (style.display === 'none' || style.opacity === '0' || style.visibility === 'hidden') return false;

  return isVisible(el.parentNode);
};

var cssSelector = function cssSelector(dom) {
  if (dom.nodeType !== 1) return '';
  if (dom.tagName === 'BODY') return 'body';
  if (dom.id) return '#' + dom.id;

  var classes = dom.className.split(/\s+/g).filter(function (item) {
    return item && item.length;
  });

  var children = Array.from(dom.parentNode.childNodes).filter(function ($el) {
    return $el.nodeType === 1;
  });

  var sameTag = children.filter(function ($el) {
    return $el.tagName === dom.tagName;
  });

  var sameClass = children.filter(function ($el) {
    var cs = $el.className.split(/\s+/g);

    return _utils__WEBPACK_IMPORTED_MODULE_0__["and"].apply(undefined, _toConsumableArray(classes.map(function (c) {
      return cs.indexOf(c) !== -1;
    })));
  });

  var extra = '';

  if (sameTag.length === 1) {
    extra = '';
  } else if (classes.length && sameClass.length === 1) {
    extra = '.' + classes.join('.');
  } else {
    extra = ':nth-child(' + (1 + children.findIndex(function (item) {
      return item === dom;
    })) + ')';
  }

  var me = dom.tagName.toLowerCase() + extra;

  // Note: browser will add an extra 'tbody' when tr directly in table, which will cause an wrong selector,
  // so the hack is to remove all tbody here
  var ret = cssSelector(dom.parentNode) + ' > ' + me;
  return ret;
  // return ret.replace(/\s*>\s*tbody\s*>?/g, ' ')
};

var isPositionFixed = function isPositionFixed($dom) {
  if (!$dom || $dom === document.documentElement || $dom === document.body) return false;
  return getComputedStyle($dom)['position'] === 'fixed' || isPositionFixed($dom.parentNode);
};

/***/ }),

/***/ "./src/common/drag_mock/DataTransfer.js":
/*!**********************************************!*\
  !*** ./src/common/drag_mock/DataTransfer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


function removeFromArray(array, item) {
  var index = array.indexOf(item);

  if (index >= 0) {
    array.splice(index, 1);
  }
}

var DataTransfer = function DataTransfer() {
  this.dataByFormat = {};

  this.dropEffect = 'none';
  this.effectAllowed = 'all';
  this.files = [];
  this.types = [];
};

DataTransfer.prototype.clearData = function (dataFormat) {
  if (dataFormat) {
    delete this.dataByFormat[dataFormat];
    removeFromArray(this.types, dataFormat);
  } else {
    this.dataByFormat = {};
    this.types = [];
  }
};

DataTransfer.prototype.getData = function (dataFormat) {
  return this.dataByFormat[dataFormat];
};

DataTransfer.prototype.setData = function (dataFormat, data) {
  this.dataByFormat[dataFormat] = data;

  if (this.types.indexOf(dataFormat) < 0) {
    this.types.push(dataFormat);
  }

  return true;
};

DataTransfer.prototype.setDragImage = function () {
  // don't do anything (the stub just makes sure there is no error thrown if someone tries to call the method)
};

module.exports = function () {
  // Note: in Firefox, window.DataTransfer exists, but it can't be used as constructor
  // In Firefox, `new window.DataTransfer()` throws errors like 'TypeError: Illegal constructor'
  if (window.DataTransfer) {
    try {
      var tmp = new window.DataTransfer();
      return window.DataTransfer;
    } catch (e) {}
  }

  return DataTransfer;
}();

/***/ }),

/***/ "./src/common/drag_mock/DragDropAction.js":
/*!************************************************!*\
  !*** ./src/common/drag_mock/DragDropAction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var eventFactory = __webpack_require__(/*! ./eventFactory */ "./src/common/drag_mock/eventFactory.js"),
    DataTransfer = __webpack_require__(/*! ./DataTransfer */ "./src/common/drag_mock/DataTransfer.js");

function _noop() {}

function parseParams(targetElement, eventProperties, configCallback) {
  if (typeof eventProperties === 'function') {
    configCallback = eventProperties;
    eventProperties = null;
  }

  if (!targetElement || (typeof targetElement === 'undefined' ? 'undefined' : _typeof(targetElement)) !== 'object') {
    throw new Error('Expected first parameter to be a targetElement. Instead got: ' + targetElement);
  }

  return {
    targetElement: targetElement,
    eventProperties: eventProperties || {},
    configCallback: configCallback || _noop
  };
}

function customizeEvent(event, configCallback, isPrimaryEvent) {
  if (configCallback) {
    // call configCallback only for the primary event if the callback takes less than two arguments
    if (configCallback.length < 2) {
      if (isPrimaryEvent) {
        configCallback(event);
      }
    }
    // call configCallback for each event if the callback takes two arguments
    else {
        configCallback(event, event.type);
      }
  }
}

function createAndDispatchEvents(targetElement, eventNames, primaryEventName, dataTransfer, eventProperties, configCallback) {
  eventNames.forEach(function (eventName) {
    var event = eventFactory.createEvent(eventName, eventProperties, dataTransfer);
    var isPrimaryEvent = eventName === primaryEventName;

    customizeEvent(event, configCallback, isPrimaryEvent);

    targetElement.dispatchEvent(event);
  });
}

var DragDropAction = function DragDropAction() {
  this.lastDragSource = null;
  this.lastDataTransfer = null;
  this.pendingActionsQueue = [];
};

DragDropAction.prototype._queue = function (fn) {
  this.pendingActionsQueue.push(fn);

  if (this.pendingActionsQueue.length === 1) {
    this._queueExecuteNext();
  }
};

DragDropAction.prototype._queueExecuteNext = function () {
  if (this.pendingActionsQueue.length === 0) {
    return;
  }

  var self = this;
  var firstPendingAction = this.pendingActionsQueue[0];

  var doneCallback = function doneCallback() {
    self.pendingActionsQueue.shift();
    self._queueExecuteNext();
  };

  if (firstPendingAction.length === 0) {
    firstPendingAction.call(this);
    doneCallback();
  } else {
    firstPendingAction.call(this, doneCallback);
  }
};

DragDropAction.prototype.dragStart = function (targetElement, eventProperties, configCallback) {
  var params = parseParams(targetElement, eventProperties, configCallback),
      events = ['mousedown', 'dragstart', 'drag'],
      dataTransfer = new DataTransfer();

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'drag', dataTransfer, params.eventProperties, params.configCallback);

    this.lastDragSource = targetElement;
    this.lastDataTransfer = dataTransfer;
  });

  return this;
};

DragDropAction.prototype.dragEnter = function (overElement, eventProperties, configCallback) {
  var params = parseParams(overElement, eventProperties, configCallback),
      events = ['mousemove', 'mouseover', 'dragenter'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'dragenter', this.lastDataTransfer, params.eventProperties, params.configCallback);
  });

  return this;
};

DragDropAction.prototype.dragOver = function (overElement, eventProperties, configCallback) {
  var params = parseParams(overElement, eventProperties, configCallback),
      events = ['mousemove', 'mouseover', 'dragover'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'drag', this.lastDataTransfer, params.eventProperties, params.configCallback);
  });

  return this;
};

DragDropAction.prototype.dragLeave = function (overElement, eventProperties, configCallback) {
  var params = parseParams(overElement, eventProperties, configCallback),
      events = ['mousemove', 'mouseover', 'dragleave'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'dragleave', this.lastDataTransfer, params.eventProperties, params.configCallback);
  });

  return this;
};

DragDropAction.prototype.drop = function (targetElement, eventProperties, configCallback) {
  var params = parseParams(targetElement, eventProperties, configCallback);
  var eventsOnDropTarget = ['mousemove', 'mouseup', 'drop'];
  var eventsOnDragSource = ['dragend'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, eventsOnDropTarget, 'drop', this.lastDataTransfer, params.eventProperties, params.configCallback);

    if (this.lastDragSource) {
      // trigger dragend event on last drag source element
      createAndDispatchEvents(this.lastDragSource, eventsOnDragSource, 'drop', this.lastDataTransfer, params.eventProperties, params.configCallback);
    }
  });

  return this;
};

DragDropAction.prototype.then = function (callback) {
  this._queue(function () {
    callback.call(this);
  }); // make sure _queue() is given a callback with no arguments

  return this;
};

DragDropAction.prototype.delay = function (waitingTimeMs) {
  this._queue(function (done) {
    window.setTimeout(done, waitingTimeMs);
  });

  return this;
};

module.exports = DragDropAction;

/***/ }),

/***/ "./src/common/drag_mock/eventFactory.js":
/*!**********************************************!*\
  !*** ./src/common/drag_mock/eventFactory.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var DataTransfer = __webpack_require__(/*! ./DataTransfer */ "./src/common/drag_mock/DataTransfer.js");

var dataTransferEvents = ['drag', 'dragstart', 'dragenter', 'dragover', 'dragend', 'drop', 'dragleave'];

function mergeInto(destObj, srcObj) {
  for (var key in srcObj) {
    if (!srcObj.hasOwnProperty(key)) {
      continue;
    } // ignore inherited properties

    destObj[key] = srcObj[key];
  }

  return destObj;
}

function isFirefox() {
  return (/Firefox/.test(window.navigator.userAgent)
  );
}

function createModernEvent(eventName, eventType, eventProperties) {
  // if (eventType === 'DragEvent') { eventType = 'CustomEvent'; }     // Firefox fix (since FF does not allow us to override dataTransfer)

  var constructor = window[eventType];
  var options = { view: window, bubbles: true, cancelable: true };

  mergeInto(options, eventProperties);

  var event = new constructor(eventName, options);

  mergeInto(event, eventProperties);

  return event;
}

function createLegacyEvent(eventName, eventType, eventProperties) {
  var event;

  switch (eventType) {
    case 'MouseEvent':
      event = document.createEvent('MouseEvent');
      event.initEvent(eventName, true, true);
      break;

    default:
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(eventName, true, true, 0);
  }

  // copy eventProperties into event
  if (eventProperties) {
    mergeInto(event, eventProperties);
  }

  return event;
}

function _createEvent(eventName, eventType, eventProperties) {
  if (isFirefox()) {
    return createLegacyEvent(eventName, eventType, eventProperties);
  }

  try {
    return createModernEvent(eventName, eventType, eventProperties);
  } catch (error) {
    return createLegacyEvent(eventName, eventType, eventProperties);
  }
}

var EventFactory = {
  createEvent: function createEvent(eventName, eventProperties, dataTransfer) {
    var eventType = 'CustomEvent';

    if (eventName.match(/^mouse/)) {
      eventType = 'MouseEvent';
    } else if (eventName.match(/^(drag|drop)/)) {
      eventType = 'DragEvent';
    }

    if (dataTransferEvents.indexOf(eventName) > -1) {
      eventProperties.dataTransfer = dataTransfer || new DataTransfer();
    }

    var event = _createEvent(eventName, eventType, eventProperties);

    return event;
  }
};

module.exports = EventFactory;

/***/ }),

/***/ "./src/common/drag_mock/index.js":
/*!***************************************!*\
  !*** ./src/common/drag_mock/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var DragDropAction = __webpack_require__(/*! ./DragDropAction */ "./src/common/drag_mock/DragDropAction.js");

function call(instance, methodName, args) {
    return instance[methodName].apply(instance, args);
}

function triggerDragEvent(element, target) {
    var getXpathOfElement = function getXpathOfElement(element) {
        if (element == null) {
            return 'null';
        }
        if (element.parentElement == null) {
            return '/' + element.tagName;
        }

        var siblingElement = element.parentElement.children;
        var tagCount = 0;
        var totalTagCount = 0;
        var isFound = false;

        for (var i = 0; i < siblingElement.length; i++) {
            if (siblingElement[i].tagName == element.tagName && !isFound) {
                tagCount++;
                totalTagCount++;
            } else if (siblingElement[i].tagName == element.tagName) {
                totalTagCount++;
            }
            if (siblingElement[i] == element) {
                isFound = true;
            }
        }

        if (totalTagCount > 1) {
            return getXpathOfElement(element.parentElement) + "/" + element.tagName + "[" + tagCount + "]";
        }

        return getXpathOfElement(element.parentElement) + "/" + element.tagName;
    };
    var script = "                                              \
      function simulateDragDrop(sourceNode, destinationNode){\
      function createCustomEvent(type) {                     \
          var event = new CustomEvent('CustomEvent');        \
          event.initCustomEvent(type, true, true, null);     \
          event.dataTransfer = {                             \
              data: {                                        \
              },                                             \
              setData: function(type, val) {                 \
                  this.data[type] = val;                     \
              },                                             \
              getData: function(type) {                      \
                  return this.data[type];                    \
              }                                              \
          };                                                 \
          return event;                                      \
      }                                                      \
      function dispatchEvent(node, type, event) {            \
          if (node.dispatchEvent) {                          \
              return node.dispatchEvent(event);              \
          }                                                  \
          if (node.fireEvent) {                              \
              return node.fireEvent('on' + type, event);     \
          }                                                  \
      }                                                      \
      var event = createCustomEvent('dragstart');            \
      dispatchEvent(sourceNode, 'dragstart', event);         \
                                                             \
      var dropEvent = createCustomEvent('drop');             \
      dropEvent.dataTransfer = event.dataTransfer;           \
      dispatchEvent(destinationNode, 'drop', dropEvent);     \
                                                             \
      var dragEndEvent = createCustomEvent('dragend');       \
      dragEndEvent.dataTransfer = event.dataTransfer;        \
      dispatchEvent(sourceNode, 'dragend', dragEndEvent);    \
  }                                                          \
  simulateDragDrop(document.evaluate('" + getXpathOfElement(element) + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue, document.evaluate('" + getXpathOfElement(target) + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue);\
  ";
    var win = window;
    var doc = win.document;
    var scriptTag = doc.createElement("script");
    scriptTag.type = "text/javascript";
    scriptTag.text = script;
    doc.body.appendChild(scriptTag);
}

var dragMock = {
    dragStart: function dragStart(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragStart', arguments);
    },
    dragEnter: function dragEnter(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragEnter', arguments);
    },
    dragOver: function dragOver(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragOver', arguments);
    },
    dragLeave: function dragLeave(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragLeave', arguments);
    },
    drop: function drop(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'drop', arguments);
    },
    delay: function delay(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'delay', arguments);
    },

    triggerDragEvent: triggerDragEvent,

    // Just for unit testing:
    DataTransfer: __webpack_require__(/*! ./DataTransfer */ "./src/common/drag_mock/DataTransfer.js"),
    DragDropAction: __webpack_require__(/*! ./DragDropAction */ "./src/common/drag_mock/DragDropAction.js"),
    eventFactory: __webpack_require__(/*! ./eventFactory */ "./src/common/drag_mock/eventFactory.js")
};

module.exports = dragMock;

/***/ }),

/***/ "./src/common/encrypt.js":
/*!*******************************!*\
  !*** ./src/common/encrypt.js ***!
  \*******************************/
/*! exports provided: aesEncrypt, aesDecrypt, encrypt, decrypt, encryptIfNeeded, decryptIfNeeded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aesEncrypt", function() { return aesEncrypt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aesDecrypt", function() { return aesDecrypt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encrypt", function() { return encrypt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decrypt", function() { return decrypt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encryptIfNeeded", function() { return encryptIfNeeded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decryptIfNeeded", function() { return decryptIfNeeded; });
/* harmony import */ var pbkdf2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js");
/* harmony import */ var pbkdf2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pbkdf2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aes-js */ "./node_modules/aes-js/index.js");
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(aes_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage */ "./src/common/storage/index.js");





var RAW_PREFIX = '@_KANTU_@';
var CIPHER_PREFIX = '__KANTU_ENCRYPTED__';
var RAW_PREFIX_REG = new RegExp('^' + RAW_PREFIX);
var CIPHER_PREFIX_REG = new RegExp('^' + CIPHER_PREFIX);

var getEncryptConfig = function getEncryptConfig() {
  return _storage__WEBPACK_IMPORTED_MODULE_3__["default"].get('config').then(function (config) {
    return {
      shouldEncrypt: config.shouldEncryptPassword === 'master_password',
      masterPassword: config.masterPassword
    };
  });
};

var aesEncrypt = function aesEncrypt(text, password) {
  var key = pbkdf2__WEBPACK_IMPORTED_MODULE_0___default.a.pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.ModeOfOperation.ctr(key);

  return aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.hex.fromBytes(engine.encrypt(aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.utf8.toBytes(text)));
};

var aesDecrypt = function aesDecrypt(text, password) {
  var key = pbkdf2__WEBPACK_IMPORTED_MODULE_0___default.a.pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.ModeOfOperation.ctr(key);

  return aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.utf8.fromBytes(engine.decrypt(aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.hex.toBytes(text)));
};

var encrypt = function encrypt(text) {
  return getEncryptConfig().then(function (_ref) {
    var shouldEncrypt = _ref.shouldEncrypt,
        masterPassword = _ref.masterPassword;

    if (!shouldEncrypt) return text;
    return '' + CIPHER_PREFIX + aesEncrypt(RAW_PREFIX + text, masterPassword);
  });
};

var decrypt = function decrypt(text) {
  return getEncryptConfig().then(function (_ref2) {
    var shouldEncrypt = _ref2.shouldEncrypt,
        masterPassword = _ref2.masterPassword;

    if (!shouldEncrypt) return text;
    var raw = aesDecrypt(text.replace(CIPHER_PREFIX_REG, ''), masterPassword);
    if (raw.indexOf(RAW_PREFIX) !== 0) throw new Error('Wrong master password');
    return raw.replace(RAW_PREFIX_REG, '');
  }).catch(function (e) {
    throw new Error('password string invalid');
  });
};

var encryptIfNeeded = function encryptIfNeeded(text, dom) {
  if (dom && dom.tagName.toUpperCase() === 'INPUT' && dom.type === 'password') {
    return encrypt(text);
  }

  return Promise.resolve(text);
};

var decryptIfNeeded = function decryptIfNeeded(text, dom) {
  if (CIPHER_PREFIX_REG.test(text) && dom && dom.tagName.toUpperCase() === 'INPUT' && dom.type === 'password') {
    return decrypt(text);
  }

  return Promise.resolve(text);
};

/***/ }),

/***/ "./src/common/file_man.js":
/*!********************************!*\
  !*** ./src/common/file_man.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _filesystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filesystem */ "./src/common/filesystem.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/common/utils.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





var readableSize = function readableSize(size) {
  var kb = 1024;
  var mb = kb * kb;

  if (size < kb) {
    return size + ' byte';
  }

  if (size < mb) {
    return (size / kb).toFixed(1) + ' KB';
  }

  return (size / mb).toFixed(1) + ' MB';
};

var FileMan = function () {
  function FileMan() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FileMan);

    var _opts$baseDir = opts.baseDir,
        baseDir = _opts$baseDir === undefined ? 'share' : _opts$baseDir;


    if (!baseDir || baseDir === '/') {
      throw new Error('Invalid baseDir, ' + baseDir);
    }

    this.baseDir = baseDir;

    // Note: create the folder in which we will store csv files
    _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].getDirectory(baseDir, true);
  }

  _createClass(FileMan, [{
    key: 'checkFileName',
    value: function checkFileName(fileName) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_2__["withFileExtension"])(fileName, function (baseName) {
        try {
          Object(_utils__WEBPACK_IMPORTED_MODULE_2__["validateStandardName"])(baseName, true);
        } catch (e) {
          throw new Error('Invalid file name \'' + fileName + '\'. File name ' + e.message);
        }
        return baseName;
      });
    }
  }, {
    key: 'getLink',
    value: function getLink(fileName) {
      var tmp = _web_extension__WEBPACK_IMPORTED_MODULE_1___default.a.extension.getURL('temporary');
      return 'filesystem:' + tmp + '/' + this.__filePath(encodeURIComponent(fileName));
    }
  }, {
    key: 'list',
    value: function list() {
      var _this = this;

      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].list(this.baseDir).then(function (fileEntries) {
        var ps = fileEntries.map(function (fileEntry) {
          return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].getMetadata(fileEntry).then(function (meta) {
            return {
              dir: _this.baseDir,
              fileName: fileEntry.name,
              size: readableSize(meta.size),
              lastModified: meta.modificationTime
            };
          });
        });
        return Promise.all(ps);
      });
    }
  }, {
    key: 'exists',
    value: function exists(fileName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].exists(this.__filePath(fileName), { type: 'file' });
    }
  }, {
    key: 'read',
    value: function read(fileName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].readFile(this.__filePath(fileName), 'Text');
    }
  }, {
    key: 'write',
    value: function write(fileName, text) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].writeFile(this.__filePath(fileName, true), new Blob([text]));
    }

    // Note: when you try to write on an existing file with file system api,
    // it won't clear old content, so we have to do it mannually

  }, {
    key: 'overwrite',
    value: function overwrite(fileName, text) {
      var _this2 = this;

      return this.remove(fileName).catch(function () {/* Ignore any error */}).then(function () {
        return _this2.write(fileName, text);
      });
    }
  }, {
    key: 'clear',
    value: function clear() {
      var _this3 = this;

      return this.list().then(function (list) {
        var ps = list.map(function (file) {
          return _this3.remove(file.fileName);
        });

        return Promise.all(ps);
      });
    }
  }, {
    key: 'remove',
    value: function remove(fileName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].removeFile(this.__filePath(fileName));
    }
  }, {
    key: 'rename',
    value: function rename(fileName, newName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].moveFile(this.__filePath(fileName), this.__filePath(newName, true));
    }
  }, {
    key: 'metadata',
    value: function metadata(fileName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].getMetadata(this.__filePath(fileName));
    }
  }, {
    key: '__filePath',
    value: function __filePath(fileName, forceCheck) {
      if (forceCheck) {
        this.checkFileName(fileName);
      }

      return this.baseDir + '/' + fileName.toLowerCase();
    }
  }]);

  return FileMan;
}();

/* harmony default export */ __webpack_exports__["default"] = (FileMan);

/***/ }),

/***/ "./src/common/filesystem.js":
/*!**********************************!*\
  !*** ./src/common/filesystem.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var idb_filesystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb.filesystem.js */ "./node_modules/idb.filesystem.js/src/idb.filesystem.js");
/* harmony import */ var idb_filesystem_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(idb_filesystem_js__WEBPACK_IMPORTED_MODULE_0__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();



var fs = function () {
  var requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;

  if (!requestFileSystem) {
    throw new Error('requestFileSystem not supported');
  }

  var dumbSize = 1024 * 1024;
  var maxSize = 5 * 1024 * 1024;
  var getFS = function getFS(size) {
    size = size || maxSize;

    return new Promise(function (resolve, reject) {
      requestFileSystem(window.TEMPORARY, size, resolve, reject);
    });
  };

  var getDirectory = function getDirectory(dir, shouldCreate, fs) {
    var parts = (Array.isArray(dir) ? dir : dir.split('/')).filter(function (p) {
      return p && p.length;
    });
    var getDir = function getDir(parts, directoryEntry) {
      if (!parts || !parts.length) return Promise.resolve(directoryEntry);

      return new Promise(function (resolve, reject) {
        directoryEntry.getDirectory(parts[0], { create: !!shouldCreate }, function (dirEntry) {
          return resolve(dirEntry);
        }, function (e) {
          return reject(e);
        });
      }).then(function (entry) {
        return getDir(parts.slice(1), entry);
      });
    };

    var pFS = fs ? Promise.resolve(fs) : getFS(dumbSize);
    return pFS.then(function (fs) {
      return getDir(parts, fs.root);
    });
  };

  // @return a Promise of [FileSystemEntries]
  var list = function list() {
    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';

    return getFS(dumbSize).then(function (fs) {
      return new Promise(function (resolve, reject) {
        getDirectory(dir).then(function (dirEntry) {
          var result = [];
          var dirReader = dirEntry.createReader();
          var read = function read() {
            dirReader.readEntries(function (entries) {
              if (entries.length === 0) {
                resolve(result.sort());
              } else {
                result = result.concat(Array.from(entries));
                read();
              }
            }, reject);
          };

          read();
        }).catch(reject);
      });
    });
  };

  var fileLocator = function fileLocator(filePath, fs) {
    var parts = filePath.split('/');
    return getDirectory(parts.slice(0, -1), false, fs).then(function (directoryEntry) {
      return {
        directoryEntry: directoryEntry,
        fileName: parts.slice(-1)[0]
      };
    });
  };

  var readFile = function readFile(filePath, type) {
    if (['ArrayBuffer', 'BinaryString', 'DataURL', 'Text'].indexOf(type) === -1) {
      throw new Error('invalid readFile type, \'' + type + '\'');
    }

    return getFS().then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref) {
        var directoryEntry = _ref.directoryEntry,
            fileName = _ref.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, {}, function (fileEntry) {
            fileEntry.file(function (file) {
              var reader = new FileReader();

              reader.onerror = reject;
              reader.onloadend = function () {
                resolve(this.result);
              };

              switch (type) {
                case 'ArrayBuffer':
                  return reader.readAsArrayBuffer(file);
                case 'BinaryString':
                  return reader.readAsBinaryString(file);
                case 'DataURL':
                  return reader.readAsDataURL(file);
                case 'Text':
                  return reader.readAsText(file);
                default:
                  throw new Error('unsupported data type, \'' + type);
              }
            }, reject);
          }, reject);
        });
      });
    });
  };

  var writeFile = function writeFile(filePath, blob, size) {
    return getFS(size).then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref2) {
        var directoryEntry = _ref2.directoryEntry,
            fileName = _ref2.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, { create: true }, function (fileEntry) {
            fileEntry.createWriter(function (fileWriter) {
              fileWriter.onwriteend = function () {
                return resolve(fileEntry.toURL());
              };
              fileWriter.onerror = reject;

              fileWriter.write(blob);
            });
          }, reject);
        });
      });
    });
  };

  var removeFile = function removeFile(filePath) {
    return getFS().then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref3) {
        var directoryEntry = _ref3.directoryEntry,
            fileName = _ref3.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, { create: true }, function (fileEntry) {
            fileEntry.remove(resolve, reject);
          }, reject);
        });
      });
    });
  };

  var moveFile = function moveFile(srcPath, targetPath) {
    return getFS().then(function (fs) {
      return Promise.all([fileLocator(srcPath, fs), fileLocator(targetPath, fs)]).then(function (tuple) {
        var srcDirEntry = tuple[0].directoryEntry;
        var srcFileName = tuple[0].fileName;
        var tgtDirEntry = tuple[1].directoryEntry;
        var tgtFileName = tuple[1].fileName;

        return new Promise(function (resolve, reject) {
          srcDirEntry.getFile(srcFileName, {}, function (fileEntry) {
            fileEntry.moveTo(tgtDirEntry, tgtFileName, resolve, reject);
          }, reject);
        });
      });
    });
  };

  var getMetadata = function getMetadata(filePath) {
    return getFS().then(function (fs) {
      if (filePath.getMetadata) {
        return new Promise(function (resolve, reject) {
          return filePath.getMetadata(resolve);
        });
      }

      return fileLocator(filePath, fs).then(function (_ref4) {
        var directoryEntry = _ref4.directoryEntry,
            fileName = _ref4.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, { create: true }, function (fileEntry) {
            fileEntry.getMetadata(resolve);
          }, reject);
        });
      });
    });
  };

  var exists = function exists(filePath) {
    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        type = _ref5.type;

    return getFS().then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref6) {
        var directoryEntry = _ref6.directoryEntry,
            fileName = _ref6.fileName;

        var isSomeEntry = function isSomeEntry(getMethodName) {
          return new Promise(function (resolve) {
            directoryEntry[getMethodName](fileName, { create: false }, function () {
              return resolve(true);
            }, function () {
              return resolve(false);
            });
          });
        };

        var pIsFile = isSomeEntry('getFile');
        var pIsDir = isSomeEntry('getDirectory');

        return Promise.all([pIsFile, pIsDir]).then(function (_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2),
              isFile = _ref8[0],
              isDir = _ref8[1];

          switch (type) {
            case 'file':
              return isFile;
            case 'directory':
              return isDir;
            default:
              return isFile || isDir;
          }
        });
      });
    });
  };

  return {
    list: list,
    readFile: readFile,
    writeFile: writeFile,
    removeFile: removeFile,
    moveFile: moveFile,
    getDirectory: getDirectory,
    getMetadata: getMetadata,
    exists: exists
  };
}();

// For test only
window.fs = fs;

/* harmony default export */ __webpack_exports__["default"] = (fs);

/***/ }),

/***/ "./src/common/inspector.js":
/*!*********************************!*\
  !*** ./src/common/inspector.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "./src/common/log.js");
/* harmony import */ var _command_runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./command_runner */ "./src/common/command_runner.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




/*
 * Basic tool function
 */

var extend = function extend() {
  var args = Array.from(arguments);
  var len = args.length;

  if (len <= 0) return {};
  if (len === 1) return args[0];

  var head = args[0];
  var rest = args.slice(1);

  return rest.reduce(function (prev, cur) {
    for (var i = 0, keys = Object.keys(cur), len = keys.length; i < len; i++) {
      prev[keys[i]] = cur[keys[i]];
    }

    return prev;
  }, head);
};

var isArray = Array.isArray;

var id = function id(x) {
  return x;
};

var trim = function trim(str) {
  return str.replace(/^\s*|\s*$/g, '');
};

var flatten = function flatten(list) {
  return [].concat.apply([], list);
};

var sum = function sum() {
  var list = Array.from(arguments);
  return list.reduce(function (prev, cur) {
    return prev + cur;
  }, 0);
};

var last = function last(list) {
  return list[list.length - 1];
};

var or = function or(list) {
  return (list || []).reduce(function (prev, cur) {
    return prev || cur;
  }, false);
};

var and = function and(list) {
  return (list || []).reduce(function (prev, cur) {
    return prev && cur;
  }, true);
};

var zipWith = function zipWith(fn) {
  if (arguments.length < 3) return null;

  var list = Array.from(arguments).slice(1);
  var len = list.reduce(function (min, cur) {
    return cur.length < min ? cur.length : min;
  }, Infinity);
  var ret = [];

  for (var i = 0; i < len; i++) {
    ret.push(fn.apply(null, list.map(function (item) {
      return item[i];
    })));
  }

  return ret;
};

var intersect = function intersect() {
  var list = Array.from(arguments);
  var len = Math.max.apply(null, list.map(function (item) {
    return item.length;
  }));
  var result = [];

  for (var i = 0; i < len; i++) {
    var val = list[0][i];
    var no = list.filter(function (item) {
      return item[i] !== val;
    });

    if (no && no.length) break;

    result.push(val);
  }

  return result;
};

var deepEqual = function deepEqual(a, b) {
  if (isArray(a) && isArray(b)) {
    return a.length === b.length && and(zipWith(deepEqual, a, b));
  }

  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {
    // TODO
    return false;
  }

  return a === b;
};

/*
 * Dom helper function
 */

var pixel = function pixel(num) {
  if ((num + '').indexOf('px') !== -1) return num;
  return (num || 0) + 'px';
};

var getStyle = function getStyle(dom, styleName) {
  if (!dom) throw new Error('getStyle: dom does not exist');
  return getComputedStyle(dom)[styleName];
};

var setStyle = function setStyle(dom, style) {
  if (!dom) throw new Error('setStyle: dom does not exist');

  for (var i = 0, keys = Object.keys(style), len = keys.length; i < len; i++) {
    dom.style[keys[i]] = style[keys[i]];
  }

  return dom;
};

var cssSum = function cssSum(dom, list) {
  var isInline = getStyle(dom, 'display') === 'inline';

  return list.reduce(function (prev, cur) {
    var val = isInline && ['width', 'height'].indexOf(cur) !== -1 ? dom.getClientRects()[0][cur] : getStyle(dom, cur);

    return prev + parseInt(val || '0', 10);
  }, 0);
};

var offset = function offset(dom, noPx) {
  if (!dom) return { left: 0, top: 0 };

  var rect = dom.getBoundingClientRect();
  var fn = noPx ? id : pixel;

  return {
    left: fn(rect.left + window.scrollX),
    top: fn(rect.top + window.scrollY)
  };
};

var rect = function rect(dom, noPx) {
  var pos = offset(dom, noPx);
  var isInline = getStyle(dom, 'display') === 'inline';
  var w = isInline ? dom.getClientRects()[0]['width'] : getStyle(dom, 'width');
  var h = isInline ? dom.getClientRects()[0]['height'] : getStyle(dom, 'height');
  var fn = noPx ? id : pixel;

  return extend({ width: fn(w), height: fn(h) }, pos);
};

// Reference: http://ryanve.com/lab/dimensions/
var clientWidth = function clientWidth(document) {
  return document.documentElement.clientWidth;
};

var clientHeight = function clientHeight(document) {
  return document.documentElement.clientHeight;
};

var removeChildren = function removeChildren(dom, predicate) {
  var pred = predicate || function () {
    return true;
  };
  var children = dom.childNodes;

  for (var i = children.length - 1; i >= 0; i--) {
    if (pred(children[i])) {
      dom.removeChild(children[i]);
    }
  }
};

var inDom = function inDom($outer, $el) {
  if (!$el) return false;
  if ($outer === $el) return true;
  return inDom($outer, $el.parentNode);
};

var inDomList = function inDomList(list, $el) {
  return or(list.map(function ($outer) {
    return inDom($outer, $el);
  }));
};

var parentWithTag = function parentWithTag(tag, $el) {
  var lowerTag = tag.toLowerCase();
  var $dom = $el;

  while ($dom) {
    if ($dom.tagName.toLowerCase() === lowerTag) {
      return $dom;
    }

    $dom = $dom.parentNode;
  }

  return null;
};

var parentWithClass = function parentWithClass(className, $el) {
  var $dom = $el;

  while ($dom) {
    // Note: In Firefox, HTML Document object doesn't have `classList` property
    if ($dom.classList !== undefined && $dom.classList.contains(className)) {
      return $dom;
    }

    $dom = $dom.parentNode;
  }

  return null;
};

var selector = function selector(dom) {
  if (dom.nodeType !== 1) return '';
  if (dom.tagName === 'BODY') return 'body';
  if (dom.id) return '#' + dom.id;

  var classes = (dom.getAttribute('class') || '').split(/\s+/g).filter(function (item) {
    return item && item.length;
  });

  var children = Array.from(dom.parentNode.childNodes).filter(function ($el) {
    return $el.nodeType === 1;
  });

  var sameTag = children.filter(function ($el) {
    return $el.tagName === dom.tagName;
  });

  var sameClass = children.filter(function ($el) {
    var cs = ($el.getAttribute('class') || '').split(/\s+/g);

    return and(classes.map(function (c) {
      return cs.indexOf(c) !== -1;
    }));
  });

  var extra = '';

  if (sameTag.length === 1) {
    extra = '';
  } else if (classes.length && sameClass.length === 1) {
    extra = '.' + classes.join('.');
  } else {
    extra = ':nth-child(' + (1 + children.findIndex(function (item) {
      return item === dom;
    })) + ')';
  }

  var me = dom.tagName.toLowerCase() + extra;

  // Note: browser will add an extra 'tbody' when tr directly in table, which will cause an wrong selector,
  // so the hack is to remove all tbody here
  var ret = selector(dom.parentNode) + ' > ' + me;
  return ret;
  // return ret.replace(/\s*>\s*tbody\s*>?/g, ' ')
};

var xpath = function xpath(dom, cur, list) {
  var getTagIndex = function getTagIndex(dom) {
    return Array.from(dom.parentNode.childNodes).filter(function (item) {
      return item.nodeType === dom.nodeType && item.tagName === dom.tagName;
    }).reduce(function (prev, node, i) {
      if (prev !== null) return prev;
      return node === dom ? i + 1 : prev;
    }, null);
  };

  var name = function name(dom) {
    if (!dom) return null;
    if (dom.nodeType === 3) return '@text';

    var index = getTagIndex(dom);
    var count = Array.from(dom.parentNode.childNodes).filter(function (item) {
      return item.nodeType === dom.nodeType && item.tagName === dom.tagName;
    }).length;
    var tag = dom.tagName.toLowerCase();

    return count > 1 ? tag + '[' + index + ']' : tag;
  };

  var helper = function helper(dom, cur, list) {
    if (!dom) return null;

    if (!cur) {
      if (dom.nodeType === 3) {
        return helper(dom.parentNode);
      } else {
        return helper(dom, dom, []);
      }
    }

    if (!cur.parentNode) {
      return ['html'].concat(list);
    }

    if (cur.tagName === 'BODY') {
      return ['html', 'body'].concat(list);
    }

    if (cur.id) {
      return ['*[@id="' + cur.id + '"]'].concat(list);
    }

    return helper(dom, cur.parentNode, [name(cur)].concat(list));
  };

  var parts = helper(dom, cur, list);
  var prefix = parts[0] === 'html' ? '/' : '//';
  var ret = prefix + parts.join('/');

  return ret;
};

var atXPath = function atXPath(xpath, document) {
  var lower = function lower(str) {
    return str && str.toLowerCase();
  };
  var reg = /^([a-zA-Z0-9]+)(\[(\d+)\])?$/;

  return xpath.reduce(function (prev, cur) {
    if (!prev) return prev;
    if (!prev.childNodes || !prev.childNodes.length) return null;

    var match = cur.match(reg);
    var tag = match[1];
    var index = match[3] ? parseInt(match[3], 10) : 1;
    var list = Array.from(prev.childNodes).filter(function (item) {
      return item.nodeType === 1 && lower(item.tagName) === lower(tag);
    });

    return list[index - 1];
  }, document);
};

var domText = function domText($dom) {
  var it = $dom.innerText && $dom.innerText.trim();
  var tc = $dom.textContent;
  var pos = tc.toUpperCase().indexOf(it.toUpperCase());

  return tc.substr(pos, it.length);
};

var getFirstWorkingLocator = function getFirstWorkingLocator(locators, $el) {
  for (var i = 0, len = locators.length; i < len; i++) {
    if ($el === Object(_command_runner__WEBPACK_IMPORTED_MODULE_1__["getElementByLocator"])(locators[i])) {
      return locators[i];
    }
  }

  return null;
};

// Note: get the locator of a DOM
var getLocator = function getLocator($dom, withAllOptions) {
  var id = $dom.getAttribute('id');
  var name = $dom.getAttribute('name');
  var isLink = $dom.tagName.toLowerCase() === 'a';
  var text = domText($dom);
  var classes = Array.from($dom.classList);
  var candidates = [];

  // link
  if (isLink && text && text.length) {
    var links = [].slice.call(document.getElementsByTagName('a'));
    var matches = links.filter(function ($el) {
      return domText($el) === text;
    });
    var index = matches.findIndex(function ($el) {
      return $el === $dom;
    });

    if (index !== -1) {
      candidates.push(index === 0 ? 'link=' + text : 'link=' + text + '@POS=' + (index + 1));
    }
  }

  // id
  if (id && id.length) {
    candidates.push('id=' + id);
  }

  // name
  if (name && name.length) {
    candidates.push('name=' + name);
  }

  // xpath
  candidates.push(xpath($dom));

  // css
  // Try with simple css selector first. If not unqiue, use full css selector
  /**
   * Below is the old logic with a shorter css selector
   *
    let sel = null
    if (classes.length > 0) {
    sel = $dom.tagName.toLowerCase() + classes.map(c => '.' + c).join('')
      if ($dom !== document.querySelectorAll(sel)[0]) {
      sel = null
    }
  }
    if (!sel) {
    sel = selector($dom)
  }
  */
  candidates.push('css=' + selector($dom));

  // Get the first one working
  var chosen = getFirstWorkingLocator(candidates, $dom);

  if (withAllOptions) {
    return {
      target: chosen,
      targetOptions: candidates
    };
  }

  return chosen;
};

var checkIframe = function checkIframe(iframeWin) {
  var key = new Date() * 1 + '' + Math.random();

  try {
    iframeWin[key] = 'asd';
    return iframeWin[key] === 'asd';
  } catch (e) {
    return false;
  }
};

// Note: get the locator for frame
var getFrameLocator = function getFrameLocator(frameWin, win) {
  if (checkIframe(frameWin)) {
    var frameDom = frameWin.frameElement;
    var locator = getLocator(frameDom);

    if (/^id=/.test(locator) || /^name=/.test(locator)) {
      return locator;
    }
  }

  for (var i = 0, len = win.frames.length; i < len; i++) {
    if (win.frames[i] === frameWin) {
      return 'index=' + i;
    }
  }

  throw new Error('Frame locator not found');
};

/*
 * Mask related
 */

var maskFactory = function maskFactory() {
  var cache = [];
  var prefix = '__mask__' + new Date() * 1 + Math.round(Math.random() * 1000) + '__';
  var uid = 1;
  var defaultStyle = {
    position: 'absolute',
    zIndex: '999',
    display: 'none',
    boxSizing: 'border-box',
    backgroundColor: 'red',
    opacity: 0.5,
    pointerEvents: 'none'
  };

  var genMask = function genMask(style, dom) {
    var mask = document.createElement('div');

    if (dom) {
      style = extend({}, defaultStyle, style || {}, rect(dom));
    } else {
      style = extend({}, defaultStyle, style || {});
    }

    setStyle(mask, style);
    mask.id = prefix + uid++;
    cache.push(mask);

    return mask;
  };

  var clear = function clear() {
    for (var i = 0, len = cache.length; i < len; i++) {
      var mask = cache[i];

      if (mask && mask.parentNode) {
        mask.parentNode.removeChild(mask);
      }
    }
  };

  return {
    gen: genMask,
    clear: clear
  };
};

var showMaskOver = function showMaskOver(mask, el) {
  var pos = offset(el);
  var w = cssSum(el, ['width', 'paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth']);
  var h = cssSum(el, ['height', 'paddingTop', 'paddingBottom', 'borderTopWidth', ' borderBottomWidth']);

  setStyle(mask, extend(pos, {
    width: pixel(w),
    height: pixel(h),
    display: 'block'
  }));
};

var isVisible = function isVisible(el) {
  if (el === window.document) return true;
  if (!el) return true;

  var style = window.getComputedStyle(el);
  if (style.display === 'none' || style.opacity === '0' || style.visibility === 'hidden') return false;

  return isVisible(el.parentNode);
};

/* harmony default export */ __webpack_exports__["default"] = ({
  offset: offset,
  setStyle: setStyle,
  selector: selector,
  xpath: xpath,
  atXPath: atXPath,
  domText: domText,
  getLocator: getLocator,
  getFrameLocator: getFrameLocator,
  maskFactory: maskFactory,
  showMaskOver: showMaskOver,
  inDom: inDom,
  isVisible: isVisible,
  parentWithTag: parentWithTag,
  parentWithClass: parentWithClass
});

/***/ }),

/***/ "./src/common/ipc/cs_postmessage.js":
/*!******************************************!*\
  !*** ./src/common/ipc/cs_postmessage.js ***!
  \******************************************/
/*! exports provided: postMessage, onMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postMessage", function() { return postMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onMessage", function() { return onMessage; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var TYPE = 'SELENIUM_IDE_CS_MSG';

var postMessage = function postMessage(targetWin, myWin, payload) {
  var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '*';
  var timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 60000;

  return new Promise(function (resolve, reject) {
    if (!targetWin || !targetWin.postMessage) {
      throw new Error('csPostMessage: targetWin is not a window', targetWin);
    }

    if (!myWin || !myWin.addEventListener || !myWin.removeEventListener) {
      throw new Error('csPostMessage: myWin is not a window', myWin);
    }

    var secret = Math.random();
    var type = TYPE;

    // Note: create a listener with a corresponding secret every time
    var onMsg = function onMsg(e) {
      if (e.data && e.data.type === TYPE && !e.data.isRequest && e.data.secret === secret) {
        myWin.removeEventListener('message', onMsg);
        var _e$data = e.data,
            _payload = _e$data.payload,
            error = _e$data.error;


        if (error) return reject(new Error(error));
        if (_payload !== undefined) return resolve(_payload);

        reject(new Error('csPostMessage: No payload nor error found'));
      }
    };

    myWin.addEventListener('message', onMsg);

    // Note:
    // * `type` to make sure we check our own msg only
    // * `secret` is for 1 to 1 relationship between a msg and a listener
    // * `payload` is the real data you want to send
    // * `isRequest` is to mark that it's not an answer to some previous request
    targetWin.postMessage({
      type: type,
      secret: secret,
      payload: payload,
      isRequest: true
    }, target);

    setTimeout(function () {
      reject(new Error('csPostMessage: timeout ' + timeout + ' ms'));
    }, timeout);
  });
};

var onMessage = function onMessage(win, fn) {
  if (!win || !win.addEventListener || !win.removeEventListener) {
    throw new Error('csOnMessage: not a window', win);
  }

  var onMsg = function onMsg(e) {
    // Note: only respond to msg with `isRequest` as true
    if (e && e.data && e.data.type === TYPE && e.data.isRequest && e.data.secret) {
      var tpl = {
        type: TYPE,
        secret: e.data.secret

        // Note: wrapped with a new Promise to catch any exception during the execution of fn
      };new Promise(function (resolve, reject) {
        var ret = void 0;

        try {
          ret = fn(e.data.payload, {
            source: e.source
          });
        } catch (err) {
          reject(err);
        }

        // Note: only resolve if returned value is not undefined. With this, we can have multiple
        // listeners added to onMessage, and each one takes care of what it really cares
        if (ret !== undefined) {
          resolve(ret);
        }
      }).then(function (res) {
        e.source.postMessage(_extends({}, tpl, {
          payload: res
        }), '*');
      }, function (err) {
        e.source.postMessage(_extends({}, tpl, {
          error: err.message
        }), '*');
      });
    }
  };

  win.addEventListener('message', onMsg);
  return function () {
    return win.removeEventListener('message', onMsg);
  };
};

/***/ }),

/***/ "./src/common/ipc/ipc_bg_cs.js":
/*!*************************************!*\
  !*** ./src/common/ipc/ipc_bg_cs.js ***!
  \*************************************/
/*! exports provided: openBgWithCs, csInit, bgInit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openBgWithCs", function() { return openBgWithCs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csInit", function() { return csInit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bgInit", function() { return bgInit; });
/* harmony import */ var _ipc_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ipc_promise */ "./src/common/ipc/ipc_promise.js");
/* harmony import */ var _ipc_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ipc_promise__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ipc_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ipc_cache */ "./src/common/ipc/ipc_cache.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../log */ "./src/common/log.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./src/common/utils.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };







var TIMEOUT = -1;

// Note: `cuid` is a kind of unique id so that you can create multiple
// ipc promise instances between the same two end points
var openBgWithCs = function openBgWithCs(cuid) {
  var wrap = function wrap(str) {
    return str + '_' + cuid;
  };

  // factory function to generate ipc promise instance for background
  // `tabId` is needed to identify which tab to send messages to
  var ipcBg = function ipcBg(tabId) {
    var bgListeners = [];

    // `sender` contains tab info. Background may need this to store the corresponding
    // relationship between tabId and ipc instance
    var addSender = function addSender(obj, sender) {
      if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return obj;

      obj.sender = sender;
      return obj;
    };

    _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.onMessage.addListener(function (req, sender, sendResponse) {
      bgListeners.forEach(function (listener) {
        return listener(req, sender, sendResponse);
      });
      return true;
    });

    return _ipc_promise__WEBPACK_IMPORTED_MODULE_0___default()({
      timeout: TIMEOUT,
      ask: function ask(uid, cmd, args) {
        _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.tabs.sendMessage(tabId, {
          type: wrap('BG_ASK_CS'),
          uid: uid,
          cmd: cmd,
          args: args
        });
      },
      onAnswer: function onAnswer(fn) {
        bgListeners.push(function (req, sender, response) {
          if (req.type !== wrap('CS_ANSWER_BG')) return;
          fn(req.uid, req.err, addSender(req.data, sender));
        });
      },
      onAsk: function onAsk(fn) {
        bgListeners.push(function (req, sender, response) {
          if (req.type !== wrap('CS_ASK_BG')) return;
          fn(req.uid, req.cmd, addSender(req.args, sender));
        });
      },
      answer: function answer(uid, err, data) {
        _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.tabs.sendMessage(tabId, {
          type: wrap('BG_ANSWER_CS'),
          uid: uid,
          err: err,
          data: data
        });
      },
      destroy: function destroy() {
        bgListeners = [];
      }
    });
  };

  // factory function to generate ipc promise for content scripts
  var ipcCs = function ipcCs(checkReady) {
    var csListeners = [];

    _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.onMessage.addListener(function (req, sender, sendResponse) {
      csListeners.forEach(function (listener) {
        return listener(req, sender, sendResponse);
      });
      return true;
    });

    return _ipc_promise__WEBPACK_IMPORTED_MODULE_0___default()({
      timeout: TIMEOUT,
      checkReady: checkReady,
      ask: function ask(uid, cmd, args) {
        // log('cs ask', uid, cmd, args)
        _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.sendMessage({
          type: wrap('CS_ASK_BG'),
          uid: uid,
          cmd: cmd,
          args: args
        });
      },
      onAnswer: function onAnswer(fn) {
        csListeners.push(function (req, sender, response) {
          if (req.type !== wrap('BG_ANSWER_CS')) return;
          fn(req.uid, req.err, req.data);
        });
      },
      onAsk: function onAsk(fn) {
        csListeners.push(function (req, sender, response) {
          if (req.type !== wrap('BG_ASK_CS')) return;
          fn(req.uid, req.cmd, req.args);
        });
      },
      answer: function answer(uid, err, data) {
        _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.sendMessage({
          type: wrap('CS_ANSWER_BG'),
          uid: uid,
          err: err,
          data: data
        });
      },
      destroy: function destroy() {
        csListeners = [];
      }
    });
  };

  return {
    ipcCs: ipcCs,
    ipcBg: ipcBg
  };
};

// Helper function to init ipc promise instance for content scripts
// The idea here is to send CONNECT message to background when initializing
var csInit = function csInit() {
  var cuid = '' + Math.floor(Math.random() * 10000);

  Object(_log__WEBPACK_IMPORTED_MODULE_3__["default"])('sending Connect...');

  // Note: Ext.extension.getURL is available in content script, but not injected js
  // We use it here to detect whether it is loaded by content script or injected
  // Calling runtime.sendMessage in injected js will cause an uncatchable exception
  if (!_web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.extension.getURL) return;

  // try this process in case we're in none-src frame
  try {
    // let connected     = false
    // const checkReady  = () => {
    //   if (connected)  return Promise.resolve(true)
    //   return Promise.reject(new Error('cs not connected with bg yet'))
    // }
    var reconnect = function reconnect() {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_4__["withTimeout"])(500, function () {
        return _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.sendMessage({
          type: 'RECONNECT'
        }).then(function (cuid) {
          Object(_log__WEBPACK_IMPORTED_MODULE_3__["default"])('got existing cuid', cuid);
          if (cuid) return openBgWithCs(cuid).ipcCs();
          throw new Error('failed to reconnect');
        });
      });
    };
    var connectBg = function connectBg() {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_4__["withTimeout"])(1000, function () {
        return _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.sendMessage({
          type: 'CONNECT',
          cuid: cuid
        }).then(function (done) {
          if (done) return openBgWithCs(cuid).ipcCs();
          throw new Error('not done');
        });
      });
    };
    var tryConnect = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["retry"])(connectBg, {
      shouldRetry: function shouldRetry() {
        return true;
      },
      retryInterval: 0,
      timeout: 5000
    });

    // Note: Strategy here
    // 1. Try to recover connection with background (get the existing cuid)
    // 2. If cuid not found, try to create new connection (cuid) with background
    // 3. Both of these two steps above are async, but this api itself is synchronous,
    //    so we have to create a mock API and return it first
    return Object(_utils__WEBPACK_IMPORTED_MODULE_4__["mockAPIWith"])(function () {
      return reconnect().catch(function () {
        return tryConnect();
      }).catch(function (e) {
        _log__WEBPACK_IMPORTED_MODULE_3__["default"].error('Failed to create cs ipc');
        throw e;
      });
    }, {
      ask: function ask() {
        return Promise.reject(new Error('mock ask'));
      },
      onAsk: function onAsk() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _log__WEBPACK_IMPORTED_MODULE_3__["default"].apply(undefined, ['mock onAsk'].concat(args));
      },
      destroy: function destroy() {}
    }, ['ask']);
  } catch (e) {
    _log__WEBPACK_IMPORTED_MODULE_3__["default"].error(e.stack);
  }
};

// Helper function to init ipc promise instance for background
// it accepts a `fn` function to handle CONNECT message from content scripts
var bgInit = function bgInit(fn) {
  _web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.runtime.onMessage.addListener(function (req, sender, sendResponse) {
    switch (req.type) {
      case 'CONNECT':
        {
          if (req.cuid) {
            fn(sender.tab.id, req.cuid, openBgWithCs(req.cuid).ipcBg(sender.tab.id));
            sendResponse(true);
          }
          break;
        }

      case 'RECONNECT':
        {
          var cuid = Object(_ipc_cache__WEBPACK_IMPORTED_MODULE_1__["getIpcCache"])().getCuid(sender.tab.id);

          if (cuid) {
            Object(_ipc_cache__WEBPACK_IMPORTED_MODULE_1__["getIpcCache"])().enable(sender.tab.id);
          }

          sendResponse(cuid || null);
          break;
        }
    }

    return true;
  });
};

/***/ }),

/***/ "./src/common/ipc/ipc_cache.js":
/*!*************************************!*\
  !*** ./src/common/ipc/ipc_cache.js ***!
  \*************************************/
/*! exports provided: IpcCache, getIpcCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IpcCache", function() { return IpcCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIpcCache", function() { return getIpcCache; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/common/utils.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var IpcCache = function () {
  function IpcCache() {
    _classCallCheck(this, IpcCache);

    this.cache = {};
  }

  _createClass(IpcCache, [{
    key: 'get',
    value: function get(tabId) {
      var _this = this;

      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
      var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;

      return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["until"])('ipc by tab id', function () {
        var ipcObj = _this.cache[tabId];
        var enabled = ipcObj && ipcObj.status === 1;
        var ipc = ipcObj && ipcObj.ipc;

        return {
          pass: enabled && !!ipc && (before === Infinity || before > ipcObj.timestamp),
          result: ipc
        };
      }, 100, timeout);
    }
  }, {
    key: 'set',
    value: function set(tabId, ipc, cuid) {
      this.cache[tabId] = {
        ipc: ipc,
        cuid: cuid,
        status: 1,
        timestamp: new Date().getTime()
      };
    }
  }, {
    key: 'setStatus',
    value: function setStatus(tabId, status) {
      var updateTimestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var found = this.cache[tabId];
      if (!found) return false;

      found.status = status;

      if (updateTimestamp) {
        found.timestamp = new Date().getTime();
      }

      return true;
    }
  }, {
    key: 'enable',
    value: function enable(tabId) {
      return this.setStatus(tabId, 1, true);
    }
  }, {
    key: 'disable',
    value: function disable(tabId) {
      return this.setStatus(tabId, 0);
    }
  }, {
    key: 'getCuid',
    value: function getCuid(tabId) {
      var found = this.cache[tabId];
      if (!found) return null;
      return found.cuid;
    }
  }, {
    key: 'del',
    value: function del(tabId) {
      delete this.cache[tabId];
    }
  }]);

  return IpcCache;
}();

var instance = void 0;

function getIpcCache() {
  if (instance) return instance;
  instance = new IpcCache();
  return instance;
}

/***/ }),

/***/ "./src/common/ipc/ipc_cs.js":
/*!**********************************!*\
  !*** ./src/common/ipc/ipc_cs.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ipc_bg_cs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ipc_bg_cs */ "./src/common/ipc/ipc_bg_cs.js");


var throwNotTop = function throwNotTop() {
  throw new Error('You are not a top window, not allowed to initialize/use csIpc');
};

// Note: csIpc is only available to top window
var ipc = window.top === window ? Object(_ipc_bg_cs__WEBPACK_IMPORTED_MODULE_0__["csInit"])() : {
  ask: throwNotTop,
  send: throwNotTop,
  onAsk: throwNotTop,
  destroy: throwNotTop

  // Note: one ipc singleton per content script
};/* harmony default export */ __webpack_exports__["default"] = (ipc);

/***/ }),

/***/ "./src/common/ipc/ipc_promise.js":
/*!***************************************!*\
  !*** ./src/common/ipc/ipc_promise.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(/*! ../utils */ "./src/common/utils.js"),
    retry = _require.retry;

var TO_BE_REMOVED = false;

var log = function log(msg) {
  if (console && console.log) console.log(msg);
};

var transformError = function transformError(err) {
  if (err instanceof Error) {
    return {
      isError: true,
      name: err.name,
      message: err.message,
      stack: err.stack
    };
  }

  return err;
};

// Note: The whole idea of ipc promise is about transforming the callback style
// ipc communication API to a Promise style
//
// eg. Orignial:    `chrome.runtime.sendMessage({}, () => {})`
//     ipcPromise:  `ipc.ask({}).then(() => {})`
//
// The benifit is
// 1. You can chain this promise with others
// 2. Create kind of connected channels between two ipc ends
//
// This is a generic interface to define a ipc promise utility
// All you need to declare is 4 functions
//
// e.g.
// ```
// ipcPromise({
//   ask: function (uid, cmd, args) { ... },
//   answer: function (uid, err, data) { ... },
//   onAsk: function (fn) { ... },
//   onAnswer: function (fn) { ... },
// })
// ```
function ipcPromise(options) {
  var ask = options.ask;
  var answer = options.answer;
  var timeout = options.timeout;
  var onAnswer = options.onAnswer;
  var onAsk = options.onAsk;
  var userDestroy = options.destroy;
  var checkReady = options.checkReady || function () {
    return Promise.resolve(true);
  };

  var askCache = {};
  var unhandledAsk = [];
  var markUnhandled = function markUnhandled(uid, cmd, args) {
    unhandledAsk.push({ uid: uid, cmd: cmd, args: args });
  };
  var handler = markUnhandled;

  var runHandlers = function runHandlers(handlers, cmd, args, resolve, reject) {
    for (var i = 0, len = handlers.length; i < len; i++) {
      var res;

      try {
        res = handlers[i](cmd, args);
      } catch (e) {
        return reject(e);
      }

      if (res !== undefined) {
        return resolve(res);
      }
    }
    // Note: DO NOT resolve anything if all handlers return undefined
  };

  // both for ask and unhandledAsk
  timeout = timeout || -1;

  onAnswer(function (uid, err, data) {
    if (uid && askCache[uid] === TO_BE_REMOVED) {
      delete askCache[uid];
      return;
    }

    if (!uid || !askCache[uid]) {
      // log('ipcPromise: response uid invalid: ' + uid);
      return;
    }

    var resolve = askCache[uid][0];
    var reject = askCache[uid][1];

    delete askCache[uid];

    if (err) {
      reject(transformError(err));
    } else {
      resolve(data);
    }
  });

  onAsk(function (uid, cmd, args) {
    if (timeout > 0) {
      setTimeout(function () {
        var found = unhandledAsk && unhandledAsk.find(function (item) {
          return item.uid === uid;
        });

        if (!found) return;

        answer(uid, new Error('ipcPromise: answer timeout ' + timeout + ' for cmd "' + cmd + '", args "' + args + '"'));
      }, timeout);
    }

    if (handler === markUnhandled) {
      markUnhandled(uid, cmd, args);
      return;
    }

    return new Promise(function (resolve, reject) {
      runHandlers(handler, cmd, args, resolve, reject);
    }).then(function (data) {
      // note: handler doens't handle the cmd => return undefined, should wait for timeout
      if (data === undefined) return markUnhandled(uid, cmd, args);
      answer(uid, null, data);
    }, function (err) {
      answer(uid, transformError(err), null);
    });
  });

  var wrapAsk = function wrapAsk(cmd, args, timeoutToOverride) {
    var uid = 'ipcp_' + new Date() * 1 + '_' + Math.round(Math.random() * 1000);
    var finalTimeout = timeoutToOverride || timeout;

    // Note: make it possible to disable timeout
    if (finalTimeout > 0) {
      setTimeout(function () {
        var reject;

        if (askCache && askCache[uid]) {
          reject = askCache[uid][1];
          askCache[uid] = TO_BE_REMOVED;
          reject(new Error('ipcPromise: onAsk timeout ' + finalTimeout + ' for cmd "' + cmd + '", args "' + args + '"'));
        }
      }, finalTimeout);
    }

    ask(uid, cmd, args || []);

    return new Promise(function (resolve, reject) {
      askCache[uid] = [resolve, reject];
    });
  };

  var wrapOnAsk = function wrapOnAsk(fn) {
    if (Array.isArray(handler)) {
      handler.push(fn);
    } else {
      handler = [fn];
    }

    var ps = unhandledAsk.map(function (task) {
      return new Promise(function (resolve, reject) {
        runHandlers(handler, task.cmd, task.args, resolve, reject);
      }).then(function (data) {
        // note: handler doens't handle the cmd => return undefined, should wait for timeout
        if (data === undefined) return;
        answer(task.uid, null, data);
        return task.uid;
      }, function (err) {
        answer(task.uid, err, null);
        return task.uid;
      });
    });

    Promise.all(ps).then(function (uids) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = uids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var uid = _step.value;

          if (uid === undefined) continue;

          var index = unhandledAsk.findIndex(function (item) {
            return item.uid === uid;
          });

          unhandledAsk.splice(index, 1);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    });
  };

  var destroy = function destroy(noReject) {
    userDestroy && userDestroy();

    ask = null;
    answer = null;
    onAnswer = null;
    onAsk = null;
    unhandledAsk = null;

    if (!noReject) {
      Object.keys(askCache).forEach(function (uid) {
        var tuple = askCache[uid];
        var reject = tuple[1];
        reject && reject(new Error('IPC Promise has been Destroyed.'));
        delete askCache[uid];
      });
    }
  };

  var waitForReady = function waitForReady(checkReady, fn) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var makeSureReady = retry(checkReady, {
        shouldRetry: function shouldRetry() {
          return true;
        },
        retryInterval: 100,
        timeout: 5000
      });

      return makeSureReady().then(function () {
        return fn.apply(undefined, args);
      });
    };
  };

  return {
    ask: waitForReady(checkReady, wrapAsk),
    onAsk: wrapOnAsk,
    destroy: destroy
  };
}

ipcPromise.serialize = function (obj) {
  return {
    ask: function ask(cmd, args, timeout) {
      return obj.ask(cmd, JSON.stringify(args), timeout);
    },

    onAsk: function onAsk(fn) {
      return obj.onAsk(function (cmd, args) {
        return fn(cmd, JSON.parse(args));
      });
    },

    destroy: obj.destroy
  };
};

module.exports = ipcPromise;

/***/ }),

/***/ "./src/common/lib/keysim.js":
/*!**********************************!*\
  !*** ./src/common/lib/keysim.js ***!
  \**********************************/
/*! exports provided: KeyEvents, Keystroke, Keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyEvents", function() { return KeyEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Keystroke", function() { return Keystroke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Keyboard", function() { return Keyboard; });
/* harmony import */ var dom_element_is_natively_editable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dom-element-is-natively-editable */ "./node_modules/dom-element-is-natively-editable/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var CTRL = 1 << 0;
var META = 1 << 1;
var ALT = 1 << 2;
var SHIFT = 1 << 3;

// Key Events
var KeyEvents = {
  DOWN: 1 << 0,
  PRESS: 1 << 1,
  UP: 1 << 2,
  INPUT: 1 << 3
};
KeyEvents.ALL = KeyEvents.DOWN | KeyEvents.PRESS | KeyEvents.UP | KeyEvents.INPUT;

/**
 * Represents a keystroke, or a single key code with a set of active modifiers.
 *
 * @class Keystroke
 */
var Keystroke =
/**
 * @param {number} modifiers A bitmask formed by CTRL, META, ALT, and SHIFT.
 * @param {number} keyCode
 */
function Keystroke(modifiers, keyCode) {
  _classCallCheck(this, Keystroke);

  this.modifiers = modifiers;
  this.ctrlKey = !!(modifiers & CTRL);
  this.metaKey = !!(modifiers & META);
  this.altKey = !!(modifiers & ALT);
  this.shiftKey = !!(modifiers & SHIFT);
  this.keyCode = keyCode;
}

/**
 * Gets the bitmask value for the "control" modifier.
 *
 * @type {number}
 */


/**
 * Gets the bitmask value for the "meta" modifier.
 *
 * @return {number}
 */


/**
 * Gets the bitmask value for the "alt" modifier.
 *
 * @return {number}
 */


/**
 * Gets the bitmask value for the "shift" modifier.
 *
 * @return {number}
 */
;

/**
 * Simulates a keyboard with a particular key-to-character and key-to-action
 * mapping. Use `US_ENGLISH` to get a pre-configured keyboard.
 */
Keystroke.CTRL = CTRL;
Keystroke.META = META;
Keystroke.ALT = ALT;
Keystroke.SHIFT = SHIFT;
var Keyboard = function () {
  /**
   * @param {Object.<number, Keystroke>} charCodeKeyCodeMap
   * @param {Object.<string, number>} actionKeyCodeMap
   */
  function Keyboard(charCodeKeyCodeMap, actionKeyCodeMap) {
    _classCallCheck(this, Keyboard);

    this._charCodeKeyCodeMap = charCodeKeyCodeMap;
    this._actionKeyCodeMap = actionKeyCodeMap;
  }

  /**
   * Determines the character code generated by pressing the given keystroke.
   *
   * @param {Keystroke} keystroke
   * @return {?number}
   */


  _createClass(Keyboard, [{
    key: 'charCodeForKeystroke',
    value: function charCodeForKeystroke(keystroke) {
      var map = this._charCodeKeyCodeMap;
      for (var charCode in map) {
        if (Object.prototype.hasOwnProperty.call(map, charCode)) {
          var keystrokeForCharCode = map[charCode];
          if (keystroke.keyCode === keystrokeForCharCode.keyCode && keystroke.modifiers === keystrokeForCharCode.modifiers) {
            return parseInt(charCode, 10);
          }
        }
      }
      return null;
    }

    /**
     * Creates an event ready for dispatching onto the given target.
     *
     * @param {string} type One of "keydown", "keypress", "keyup", "textInput" or "input".
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @return {Event}
     */

  }, {
    key: 'createEventFromKeystroke',
    value: function createEventFromKeystroke(type, keystroke, target) {
      var document = target.ownerDocument;
      var window = document.defaultView;
      var Event = window.Event;

      var event = void 0;

      try {
        event = new Event(type);
      } catch (e) {
        event = document.createEvent('UIEvents');
      }

      event.initEvent(type, true, true);

      switch (type) {
        case 'textInput':
          event.data = String.fromCharCode(this.charCodeForKeystroke(keystroke));
          break;

        case 'keydown':
        case 'keypress':
        case 'keyup':
          event.shiftKey = keystroke.shiftKey;
          event.altKey = keystroke.altKey;
          event.metaKey = keystroke.metaKey;
          event.ctrlKey = keystroke.ctrlKey;
          event.keyCode = type === 'keypress' ? this.charCodeForKeystroke(keystroke) : keystroke.keyCode;
          event.charCode = type === 'keypress' ? event.keyCode : 0;
          event.which = event.keyCode;
          break;
      }

      return event;
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * action was undertaken by a human.
     *
     * @param {string} action e.g. "alt+shift+left" or "backspace"
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForAction',
    value: function dispatchEventsForAction(action, target) {
      var keystroke = this.keystrokeForAction(action);
      this.dispatchEventsForKeystroke(keystroke, target);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * input had been typed by a human.
     *
     * @param {string} input
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForInput',
    value: function dispatchEventsForInput(input, target) {
      var currentModifierState = 0;
      for (var i = 0, length = input.length; i < length; i++) {
        var keystroke = this.keystrokeForCharCode(input.charCodeAt(i));
        if (!keystroke) continue;

        this.dispatchModifierStateTransition(target, currentModifierState, keystroke.modifiers);
        this.dispatchEventsForKeystroke(keystroke, target, false);
        currentModifierState = keystroke.modifiers;
      }
      this.dispatchModifierStateTransition(target, currentModifierState, 0);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * keystroke was performed by a human. When simulating, for example, typing
     * the letter "A" (assuming a U.S. English keyboard) then the sequence will
     * look like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0      shiftKey=true
     *   keydown   keyCode=65 (A)     charCode=0      shiftKey=true
     *   keypress  keyCode=65 (A)     charCode=65 (A) shiftKey=true
     *   textInput data=A
     *   input
     *   keyup     keyCode=65 (A)     charCode=0      shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0      shiftKey=false
     *
     * If the keystroke would not cause a character to be input, such as when
     * pressing alt+shift+left, the sequence looks like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=true
     *   keydown   keyCode=18 (ALT)   charCode=0 altKey=true  shiftKey=true
     *   keydown   keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=18 (ALT)   charCode=0 altKey=false shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=false
     *
     * To disable handling of modifier keys, call with `transitionModifers` set
     * to false. Doing so will omit the keydown and keyup events associated with
     * shift, ctrl, alt, and meta keys surrounding the actual keystroke.
     *
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @param {boolean=} transitionModifiers
     * @param {number} events
     */

  }, {
    key: 'dispatchEventsForKeystroke',
    value: function dispatchEventsForKeystroke(keystroke, target) {
      var transitionModifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      if (!keystroke) return;

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, 0, keystroke.modifiers, events);
      }

      var keydownEvent = void 0;
      if (events & KeyEvents.DOWN) {
        keydownEvent = this.createEventFromKeystroke('keydown', keystroke, target);
      }

      if (keydownEvent && target.dispatchEvent(keydownEvent) && this.targetCanReceiveTextInput(target)) {
        var keypressEvent = void 0;
        if (events & KeyEvents.PRESS) {
          keypressEvent = this.createEventFromKeystroke('keypress', keystroke, target);
        }
        if (keypressEvent && keypressEvent.charCode && target.dispatchEvent(keypressEvent)) {
          if (events & KeyEvents.INPUT) {
            var textinputEvent = this.createEventFromKeystroke('textInput', keystroke, target);
            target.dispatchEvent(textinputEvent);

            var inputEvent = this.createEventFromKeystroke('input', keystroke, target);
            target.dispatchEvent(inputEvent);
          }
        }
      }

      if (events & KeyEvents.UP) {
        var keyupEvent = this.createEventFromKeystroke('keyup', keystroke, target);
        target.dispatchEvent(keyupEvent);
      }

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, keystroke.modifiers, 0);
      }
    }

    /**
     * Transitions from one modifier state to another by dispatching key events.
     *
     * @param {EventTarget} target
     * @param {number} fromModifierState
     * @param {number} toModifierState
     * @param {number} events
     * @private
     */

  }, {
    key: 'dispatchModifierStateTransition',
    value: function dispatchModifierStateTransition(target, fromModifierState, toModifierState) {
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      var currentModifierState = fromModifierState;
      var didHaveMeta = (fromModifierState & META) === META;
      var willHaveMeta = (toModifierState & META) === META;
      var didHaveCtrl = (fromModifierState & CTRL) === CTRL;
      var willHaveCtrl = (toModifierState & CTRL) === CTRL;
      var didHaveShift = (fromModifierState & SHIFT) === SHIFT;
      var willHaveShift = (toModifierState & SHIFT) === SHIFT;
      var didHaveAlt = (fromModifierState & ALT) === ALT;
      var willHaveAlt = (toModifierState & ALT) === ALT;

      var includeKeyUp = events & KeyEvents.UP;
      var includeKeyDown = events & KeyEvents.DOWN;

      if (includeKeyUp && didHaveMeta === true && willHaveMeta === false) {
        // Release the meta key.
        currentModifierState &= ~META;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyUp && didHaveCtrl === true && willHaveCtrl === false) {
        // Release the ctrl key.
        currentModifierState &= ~CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyUp && didHaveShift === true && willHaveShift === false) {
        // Release the shift key.
        currentModifierState &= ~SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyUp && didHaveAlt === true && willHaveAlt === false) {
        // Release the alt key.
        currentModifierState &= ~ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (includeKeyDown && didHaveMeta === false && willHaveMeta === true) {
        // Press the meta key.
        currentModifierState |= META;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyDown && didHaveCtrl === false && willHaveCtrl === true) {
        // Press the ctrl key.
        currentModifierState |= CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyDown && didHaveShift === false && willHaveShift === true) {
        // Press the shift key.
        currentModifierState |= SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyDown && didHaveAlt === false && willHaveAlt === true) {
        // Press the alt key.
        currentModifierState |= ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (currentModifierState !== toModifierState) {
        throw new Error('internal error, expected modifier state: ' + toModifierState + (', got: ' + currentModifierState));
      }
    }

    /**
     * Returns the keystroke associated with the given action.
     *
     * @param {string} action
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForAction',
    value: function keystrokeForAction(action) {
      var keyCode = null;
      var modifiers = 0;

      // Note: when it comes to a single character as '+',
      // should not take it as a key combiniation (no action.split)
      var parts = action.length === 1 ? [action] : action.split('+');
      var lastPart = parts.pop();

      parts.forEach(function (part) {
        switch (part.toUpperCase()) {
          case 'CTRL':
            modifiers |= CTRL;
            break;
          case 'META':
            modifiers |= META;
            break;
          case 'ALT':
            modifiers |= ALT;
            break;
          case 'SHIFT':
            modifiers |= SHIFT;
            break;
          default:
            console.error('parts', parts);
            throw new Error('in "' + action + '", invalid modifier: ' + part);
        }
      });

      if (lastPart.toUpperCase() in this._actionKeyCodeMap) {
        keyCode = this._actionKeyCodeMap[lastPart.toUpperCase()];
      } else if (lastPart.length === 1) {
        var lastPartKeystroke = this.keystrokeForCharCode(lastPart.charCodeAt(0));
        if (!lastPartKeystroke) return null;

        modifiers |= lastPartKeystroke.modifiers;
        keyCode = lastPartKeystroke.keyCode;
      } else {
        throw new Error('in "' + action + '", invalid action: ' + lastPart);
      }

      return new Keystroke(modifiers, keyCode);
    }

    /**
     * Gets the keystroke used to generate the given character code.
     *
     * @param {number} charCode
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForCharCode',
    value: function keystrokeForCharCode(charCode) {
      return this._charCodeKeyCodeMap[charCode] || null;
    }

    /**
     * @param {EventTarget} target
     * @private
     */

  }, {
    key: 'targetCanReceiveTextInput',
    value: function targetCanReceiveTextInput(target) {
      if (!target) {
        return false;
      }

      return Object(dom_element_is_natively_editable__WEBPACK_IMPORTED_MODULE_0__["default"])(target);
    }
  }]);

  return Keyboard;
}();

var US_ENGLISH_CHARCODE_KEYCODE_MAP = {
  32: new Keystroke(0, 32), // <space>
  33: new Keystroke(SHIFT, 49), // !
  34: new Keystroke(SHIFT, 222), // "
  35: new Keystroke(SHIFT, 51), // #
  36: new Keystroke(SHIFT, 52), // $
  37: new Keystroke(SHIFT, 53), // %
  38: new Keystroke(SHIFT, 55), // &
  39: new Keystroke(0, 222), // '
  40: new Keystroke(SHIFT, 57), // (
  41: new Keystroke(SHIFT, 48), // )
  42: new Keystroke(SHIFT, 56), // *
  43: new Keystroke(SHIFT, 187), // +
  44: new Keystroke(0, 188), // ,
  45: new Keystroke(0, 189), // -
  46: new Keystroke(0, 190), // .
  47: new Keystroke(0, 191), // /
  48: new Keystroke(0, 48), // 0
  49: new Keystroke(0, 49), // 1
  50: new Keystroke(0, 50), // 2
  51: new Keystroke(0, 51), // 3
  52: new Keystroke(0, 52), // 4
  53: new Keystroke(0, 53), // 5
  54: new Keystroke(0, 54), // 6
  55: new Keystroke(0, 55), // 7
  56: new Keystroke(0, 56), // 8
  57: new Keystroke(0, 57), // 9
  58: new Keystroke(SHIFT, 186), // :
  59: new Keystroke(0, 186), // ;
  60: new Keystroke(SHIFT, 188), // <
  61: new Keystroke(0, 187), // =
  62: new Keystroke(SHIFT, 190), // >
  63: new Keystroke(SHIFT, 191), // ?
  64: new Keystroke(SHIFT, 50), // @
  65: new Keystroke(SHIFT, 65), // A
  66: new Keystroke(SHIFT, 66), // B
  67: new Keystroke(SHIFT, 67), // C
  68: new Keystroke(SHIFT, 68), // D
  69: new Keystroke(SHIFT, 69), // E
  70: new Keystroke(SHIFT, 70), // F
  71: new Keystroke(SHIFT, 71), // G
  72: new Keystroke(SHIFT, 72), // H
  73: new Keystroke(SHIFT, 73), // I
  74: new Keystroke(SHIFT, 74), // J
  75: new Keystroke(SHIFT, 75), // K
  76: new Keystroke(SHIFT, 76), // L
  77: new Keystroke(SHIFT, 77), // M
  78: new Keystroke(SHIFT, 78), // N
  79: new Keystroke(SHIFT, 79), // O
  80: new Keystroke(SHIFT, 80), // P
  81: new Keystroke(SHIFT, 81), // Q
  82: new Keystroke(SHIFT, 82), // R
  83: new Keystroke(SHIFT, 83), // S
  84: new Keystroke(SHIFT, 84), // T
  85: new Keystroke(SHIFT, 85), // U
  86: new Keystroke(SHIFT, 86), // V
  87: new Keystroke(SHIFT, 87), // W
  88: new Keystroke(SHIFT, 88), // X
  89: new Keystroke(SHIFT, 89), // Y
  90: new Keystroke(SHIFT, 90), // Z
  91: new Keystroke(0, 219), // [
  92: new Keystroke(0, 220), // \
  93: new Keystroke(0, 221), // ]
  94: new Keystroke(SHIFT, 54), // ^
  95: new Keystroke(SHIFT, 189), // _
  96: new Keystroke(0, 192), // `
  97: new Keystroke(0, 65), // a
  98: new Keystroke(0, 66), // b
  99: new Keystroke(0, 67), // c
  100: new Keystroke(0, 68), // d
  101: new Keystroke(0, 69), // e
  102: new Keystroke(0, 70), // f
  103: new Keystroke(0, 71), // g
  104: new Keystroke(0, 72), // h
  105: new Keystroke(0, 73), // i
  106: new Keystroke(0, 74), // j
  107: new Keystroke(0, 75), // k
  108: new Keystroke(0, 76), // l
  109: new Keystroke(0, 77), // m
  110: new Keystroke(0, 78), // n
  111: new Keystroke(0, 79), // o
  112: new Keystroke(0, 80), // p
  113: new Keystroke(0, 81), // q
  114: new Keystroke(0, 82), // r
  115: new Keystroke(0, 83), // s
  116: new Keystroke(0, 84), // t
  117: new Keystroke(0, 85), // u
  118: new Keystroke(0, 86), // v
  119: new Keystroke(0, 87), // w
  120: new Keystroke(0, 88), // x
  121: new Keystroke(0, 89), // y
  122: new Keystroke(0, 90), // z
  123: new Keystroke(SHIFT, 219), // {
  124: new Keystroke(SHIFT, 220), // |
  125: new Keystroke(SHIFT, 221), // }
  126: new Keystroke(SHIFT, 192) // ~
};

var US_ENGLISH_ACTION_KEYCODE_MAP = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPSLOCK: 20,
  ESCAPE: 27,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  INSERT: 45,
  DELETE: 46,
  META: 91,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123
};

/**
 * Gets a keyboard instance configured as a U.S. English keyboard would be.
 *
 * @return {Keyboard}
 */
Keyboard.US_ENGLISH = new Keyboard(US_ENGLISH_CHARCODE_KEYCODE_MAP, US_ENGLISH_ACTION_KEYCODE_MAP);

/***/ }),

/***/ "./src/common/log.js":
/*!***************************!*\
  !*** ./src/common/log.js ***!
  \***************************/
/*! exports provided: logFactory, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logFactory", function() { return logFactory; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var logFactory = function logFactory(enabled) {
  var isEnabled = !!enabled;

  var obj = ['log', 'info', 'warn', 'error'].reduce(function (prev, method) {
    prev[method] = function () {
      var _console;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (!isEnabled) return;
      (_console = console)[method].apply(_console, [new Date().toISOString(), ' - '].concat(args));
    };
    return prev;
  }, {});

  return _extends(obj.log, obj, {
    enable: function enable() {
      isEnabled = true;
    },
    disable: function disable() {
      isEnabled = false;
    }
  });
};

/* harmony default export */ __webpack_exports__["default"] = (logFactory("development" !== 'production'));

/***/ }),

/***/ "./src/common/screenshot_man.js":
/*!**************************************!*\
  !*** ./src/common/screenshot_man.js ***!
  \**************************************/
/*! exports provided: ScreenshotMan, getScreenshotMan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScreenshotMan", function() { return ScreenshotMan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScreenshotMan", function() { return getScreenshotMan; });
/* harmony import */ var _filesystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filesystem */ "./src/common/filesystem.js");
/* harmony import */ var _file_man__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./file_man */ "./src/common/file_man.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_2__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var ScreenshotMan = function (_FileMan) {
  _inherits(ScreenshotMan, _FileMan);

  function ScreenshotMan() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ScreenshotMan);

    return _possibleConstructorReturn(this, (ScreenshotMan.__proto__ || Object.getPrototypeOf(ScreenshotMan)).call(this, _extends({}, opts, { baseDir: 'screenshots' })));
  }

  _createClass(ScreenshotMan, [{
    key: 'write',
    value: function write(fileName, blob) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].writeFile(this.__filePath(fileName, true), blob);
    }
  }, {
    key: 'read',
    value: function read(fileName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].readFile(this.__filePath(fileName), 'ArrayBuffer');
    }
  }, {
    key: 'readAsDataURL',
    value: function readAsDataURL(fileName) {
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].readFile(this.__filePath(fileName), 'DataURL');
    }
  }, {
    key: 'getLink',
    value: function getLink(fileName) {
      if (!_web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.isFirefox()) return Promise.resolve(_get(ScreenshotMan.prototype.__proto__ || Object.getPrototypeOf(ScreenshotMan.prototype), 'getLink', this).call(this, fileName) + '?' + new Date().getTime());

      // Note: Except for Chrome, the filesystem API we use is a polyfill from idb.filesystem.js
      // idb.filesystem.js works great but the only problem is that you can't use 'filesystem:' schema to retrieve that file
      // so here, we have to convert the file to data url
      return _filesystem__WEBPACK_IMPORTED_MODULE_0__["default"].readFile(this.__filePath(fileName), 'DataURL');
    }
  }]);

  return ScreenshotMan;
}(_file_man__WEBPACK_IMPORTED_MODULE_1__["default"]);

var man = void 0;

function getScreenshotMan() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (opts) {
    man = new ScreenshotMan(opts);
  }

  if (!man) {
    throw new Error('screenshot manager not initialized');
  }

  return man;
}

/***/ }),

/***/ "./src/common/send_keys.js":
/*!*********************************!*\
  !*** ./src/common/send_keys.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sendKeys; });
/* harmony import */ var _lib_keysim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/keysim */ "./src/common/lib/keysim.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/common/utils.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./log */ "./src/common/log.js");




var keyboard = _lib_keysim__WEBPACK_IMPORTED_MODULE_0__["Keyboard"].US_ENGLISH;

var findParentByTag = function findParentByTag(el, tag) {
  var p = el;

  // eslint-disable-next-line no-cond-assign
  while (p = p.parentNode) {
    if (p.tagName === tag.toUpperCase()) {
      return p;
    }
  }

  return null;
};

var splitStringToChars = function splitStringToChars(str) {
  var specialKeys = ['KEY_LEFT', 'KEY_UP', 'KEY_RIGHT', 'KEY_DOWN', 'KEY_PGUP', 'KEY_PAGE_UP', 'KEY_PGDN', 'KEY_PAGE_DOWN', 'KEY_BKSP', 'KEY_BACKSPACE', 'KEY_DEL', 'KEY_DELETE', 'KEY_ENTER', 'KEY_TAB'];
  var reg = new RegExp('\\$\\{(' + specialKeys.join('|') + ')\\}');
  var parts = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["splitKeep"])(reg, str);

  return parts.reduce(function (prev, cur) {
    if (reg.test(cur)) {
      prev.push(cur);
    } else {
      prev = prev.concat(cur.split(''));
    }

    return prev;
  }, []);
};

var getKeyStrokeAction = function getKeyStrokeAction(str) {
  var reg = /^\$\{([^}]+)\}$/;
  var match = void 0;

  // eslint-disable-next-line no-cond-assign
  if (match = str.match(reg)) {
    switch (match[1]) {
      case 'KEY_LEFT':
        return 'LEFT';

      case 'KEY_UP':
        return 'UP';

      case 'KEY_RIGHT':
        return 'RIGHT';

      case 'KEY_DOWN':
        return 'DOWN';

      case 'KEY_PGUP':
      case 'KEY_PAGE_UP':
        return 'PAGEUP';

      case 'KEY_PGDN':
      case 'KEY_PAGE_DOWN':
        return 'PAGEDOWN';

      case 'KEY_BKSP':
      case 'KEY_BACKSPACE':
        return 'BACKSPACE';

      case 'KEY_DEL':
      case 'KEY_DELETE':
        return 'DELETE';

      case 'KEY_ENTER':
        return 'ENTER';

      case 'KEY_TAB':
        return 'TAB';
    }
  }

  return str;
};

var isEditable = function isEditable(el) {
  if (el.getAttribute('readonly') !== null) return false;
  var tag = el.tagName.toUpperCase();
  var type = (el.type || '').toLowerCase();
  var editableTypes = ['text', 'search', 'tel', 'url', 'email', 'password', 'number'];

  if (tag === 'TEXTAREA') return true;
  if (tag === 'INPUT' && editableTypes.indexOf(type) !== -1) return true;

  return false;
};

var maybeEditText = function maybeEditText(target, c) {
  if (!isEditable(target)) return;
  if (c.length === 1) {
    if (!isNil(target.selectionStart)) {
      var lastStart = target.selectionStart;
      target.value = target.value.substring(0, target.selectionStart) + c + target.value.substring(target.selectionEnd);

      setSelection(target, lastStart + 1);
    } else {
      target.value = target.value + c;
    }
  } else {
    switch (c) {
      case 'ENTER':
        target.value = target.value + '\n';
        setSelection(target, target.value.length);
        break;
      case 'TAB':
        target.value = target.value + '\t';
        setSelection(target, target.value.length);
        break;
      case 'LEFT':
        setSelection(target, target.selectionStart - 1);
        break;
      case 'RIGHT':
        setSelection(target, target.selectionEnd + 1);
        break;
      case 'BACKSPACE':
        {
          var pos = target.selectionStart;
          target.value = target.value.substring(0, target.selectionStart - 1) + target.value.substring(target.selectionEnd);
          setSelection(target, pos - 1);
          break;
        }
      case 'DELETE':
        {
          var _pos = target.selectionEnd;
          target.value = target.value.substring(0, target.selectionStart) + target.value.substring(target.selectionEnd + 1);
          setSelection(target, _pos);
          break;
        }
    }
  }
};

var maybeSubmitForm = function maybeSubmitForm(target, key) {
  if (key !== 'ENTER') return;
  if (!isEditable(target)) return;

  var form = findParentByTag(target, 'FORM');
  if (!form) return;

  form.submit();
};

var isNil = function isNil(val) {
  return val === null || val === undefined;
};

var setSelection = function setSelection($el, start, end) {
  // Note: Inputs like number and email, doesn't support selectionEnd
  // for safety, make sure those values are not null or undefined (infers that it's available)
  if (!isNil($el.selectionStart)) {
    $el.selectionStart = start;
  }

  if (!isNil($el.selectionEnd)) {
    $el.selectionEnd = end !== undefined ? end : start;
  }
};

var replaceActionKey = function () {
  var mapping = {
    0: null, // the NULL character
    8: 'BACKSPACE',
    9: 'TAB',
    10: 'ENTER', // \n  new line
    11: null, // \v  vertical tab
    12: null, // \f  form feed
    13: null // \r  carriage return
  };

  return function (c) {
    // Note: it means it's already key stroke action
    if (c.length > 1) return c;
    return mapping[c.charCodeAt(0)] || c;
  };
}();

function sendKeys(target, str, noSpecialKeys) {
  var rawChars = noSpecialKeys ? str.split('') : splitStringToChars(str);
  var chars = rawChars.map(replaceActionKey).filter(function (x) {
    return x && x.length;
  });

  target.focus();
  if (target.value) {
    setSelection(target, target.value.length);
  }

  chars.forEach(function (c) {
    var action = getKeyStrokeAction(c);

    maybeEditText(target, action);
    // Note: This line will take care of KEYDOWN KEYPRESS KEYUP and TEXTINPUT
    keyboard.dispatchEventsForAction(action, target);

    if (!noSpecialKeys) {
      maybeSubmitForm(target, action);
    }
  });
}

/***/ }),

/***/ "./src/common/storage/ext_storage.js":
/*!*******************************************!*\
  !*** ./src/common/storage/ext_storage.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_0__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var local = _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.storage.local;

/* harmony default export */ __webpack_exports__["default"] = ({
  get: function get(key) {
    return local.get(key).then(function (obj) {
      return obj[key];
    });
  },

  set: function set(key, value) {
    return local.set(_defineProperty({}, key, value)).then(function () {
      return true;
    });
  },

  remove: function remove(key) {
    return local.remove(key).then(function () {
      return true;
    });
  },

  clear: function clear() {
    return local.clear().then(function () {
      return true;
    });
  },

  addListener: function addListener(fn) {
    _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.storage.onChanged.addListener(function (changes, areaName) {
      var list = Object.keys(changes).map(function (key) {
        return _extends({}, changes[key], { key: key });
      });
      fn(list);
    });
  }
});

/***/ }),

/***/ "./src/common/storage/index.js":
/*!*************************************!*\
  !*** ./src/common/storage/index.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ext_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ext_storage */ "./src/common/storage/ext_storage.js");



/* harmony default export */ __webpack_exports__["default"] = (_ext_storage__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./src/common/utils.js":
/*!*****************************!*\
  !*** ./src/common/utils.js ***!
  \*****************************/
/*! exports provided: delay, until, range, partial, reduceRight, compose, map, on, updateIn, setIn, getIn, pick, uid, flatten, splitIntoTwo, cn, objMap, formatDate, splitKeep, nameFactory, composePromiseFn, parseQuery, toRegExp, insertScript, withTimeout, retry, dataURItoBlob, randomName, withFileExtension, uniqueName, and, loadCsv, loadImage, ensureExtName, validateStandardName, sanitizeFileName, getScreenDpi, dpiFromFileName, mockAPIWith, withCountDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "until", function() { return until; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return partial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return reduceRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateIn", function() { return updateIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setIn", function() { return setIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIn", function() { return getIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return uid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitIntoTwo", function() { return splitIntoTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cn", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objMap", function() { return objMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatDate", function() { return formatDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitKeep", function() { return splitKeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nameFactory", function() { return nameFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composePromiseFn", function() { return composePromiseFn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseQuery", function() { return parseQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRegExp", function() { return toRegExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertScript", function() { return insertScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withTimeout", function() { return withTimeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retry", function() { return retry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataURItoBlob", function() { return dataURItoBlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomName", function() { return randomName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withFileExtension", function() { return withFileExtension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueName", function() { return uniqueName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "and", function() { return and; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadCsv", function() { return loadCsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ensureExtName", function() { return ensureExtName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateStandardName", function() { return validateStandardName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeFileName", function() { return sanitizeFileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScreenDpi", function() { return getScreenDpi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dpiFromFileName", function() { return dpiFromFileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mockAPIWith", function() { return mockAPIWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withCountDown", function() { return withCountDown; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// delay the call of a function and return a promise
var delay = function delay(fn, timeout) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      try {
        resolve(fn());
      } catch (e) {
        reject(e);
      }
    }, timeout);
  });
};

// Poll on whatever you want to check, and will time out after a specific duration
// `check` should return `{ pass: Boolean, result: Any }`
// `name` is for a meaningful error message
var until = function until(name, check) {
  var interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  var expire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10000;
  var errorMsg = arguments[4];

  var start = new Date();
  var go = function go() {
    if (expire && new Date() - start >= expire) {
      var msg = errorMsg || 'until: ' + name + ' expired!';
      throw new Error(msg);
    }

    var _check = check(),
        pass = _check.pass,
        result = _check.result;

    if (pass) return Promise.resolve(result);
    return delay(go, interval);
  };

  return new Promise(function (resolve, reject) {
    try {
      resolve(go());
    } catch (e) {
      reject(e);
    }
  });
};

var range = function range(start, end) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var ret = [];

  for (var i = start; i < end; i += step) {
    ret.push(i);
  }

  return ret;
};

// create a curry version of the passed in function
var partial = function partial(fn) {
  var len = fn.length;
  var _arbitary = void 0;

  _arbitary = function arbitary(curArgs, leftArgCnt) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args.length >= leftArgCnt) {
        return fn.apply(null, curArgs.concat(args));
      }

      return _arbitary(curArgs.concat(args), leftArgCnt - args.length);
    };
  };

  return _arbitary([], len);
};

var reduceRight = function reduceRight(fn, initial, list) {
  var ret = initial;

  for (var i = list.length - 1; i >= 0; i--) {
    ret = fn(list[i], ret);
  }

  return ret;
};

// compose functions into one
var compose = function compose() {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return reduceRight(function (cur, prev) {
    return function (x) {
      return cur(prev(x));
    };
  }, function (x) {
    return x;
  }, args);
};

var map = partial(function (fn, list) {
  var result = [];

  for (var i = 0, len = list.length; i < len; i++) {
    result.push(fn(list[i]));
  }

  return result;
});

var on = partial(function (key, fn, dict) {
  if (Array.isArray(dict)) {
    return [].concat(_toConsumableArray(dict.slice(0, key)), [fn(dict[key])], _toConsumableArray(dict.slice(key + 1)));
  }

  return _extends({}, dict, _defineProperty({}, key, fn(dict[key])));
});

// immutably update any part in an object
var updateIn = partial(function (keys, fn, obj) {
  var updater = compose.apply(null, keys.map(function (key) {
    return on(key);
  }));
  return updater(fn)(obj);
});

// immutably set any part in an object
// a restricted version of updateIn
var setIn = partial(function (keys, value, obj) {
  var updater = compose.apply(null, keys.map(function (key) {
    return on(key);
  }));
  return updater(function () {
    return value;
  })(obj);
});

// return part of the object with a few keys deep inside
var getIn = partial(function (keys, obj) {
  return keys.reduce(function (prev, key) {
    if (!prev) return prev;
    return prev[key];
  }, obj);
});

// return the passed in object with only certains keys
var pick = function pick(keys, obj) {
  return keys.reduce(function (prev, key) {
    if (obj[key] !== undefined) {
      prev[key] = obj[key];
    }
    return prev;
  }, {});
};

var uid = function uid() {
  return '' + new Date() * 1 + '.' + Math.floor(Math.random() * 10000000).toString(16);
};

var flatten = function flatten(list) {
  return [].concat.apply([], list);
};

var splitIntoTwo = function splitIntoTwo(pattern, str) {
  var index = str.indexOf(pattern);
  if (index === -1) return [str];

  return [str.substr(0, index), str.substr(index + 1)];
};

var cn = function cn() {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return args.reduce(function (prev, cur) {
    if (typeof cur === 'string') {
      prev.push(cur);
    } else {
      Object.keys(cur).forEach(function (key) {
        if (cur[key]) {
          prev.push(key);
        }
      });
    }

    return prev;
  }, []).join(' ');
};

var objMap = function objMap(fn, obj) {
  return Object.keys(obj).reduce(function (prev, key, i) {
    prev[key] = fn(obj[key], key, i);
    return prev;
  }, {});
};

var formatDate = function formatDate(d) {
  var pad = function pad(n) {
    return n >= 10 ? '' + n : '0' + n;
  };
  return [d.getFullYear(), d.getMonth() + 1, d.getDate()].map(pad).join('-');
};

var splitKeep = function splitKeep(pattern, str) {
  var result = [];
  var startIndex = 0;
  var reg = void 0,
      match = void 0,
      lastMatchIndex = void 0;

  if (pattern instanceof RegExp) {
    reg = new RegExp(pattern, pattern.flags.indexOf('g') !== -1 ? pattern.flags : pattern.flags + 'g');
  } else if (typeof pattern === 'string') {
    reg = new RegExp(pattern, 'g');
  }

  // eslint-disable-next-line no-cond-assign
  while (match = reg.exec(str)) {
    if (lastMatchIndex === match.index) {
      break;
    }

    if (match.index > startIndex) {
      result.push(str.substring(startIndex, match.index));
    }

    result.push(match[0]);
    startIndex = match.index + match[0].length;
    lastMatchIndex = match.index;
  }

  if (startIndex < str.length) {
    result.push(str.substr(startIndex));
  }

  return result;
};

var nameFactory = function nameFactory() {
  var all = {};

  return function (str) {
    if (!all[str]) {
      all[str] = true;
      return str;
    }

    var n = 2;
    while (all[str + '-' + n]) {
      n++;
    }

    all[str + '-' + n] = true;
    return str + '-' + n;
  };
};

var composePromiseFn = function composePromiseFn() {
  for (var _len4 = arguments.length, list = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    list[_key4] = arguments[_key4];
  }

  return reduceRight(function (cur, prev) {
    return function (x) {
      return prev(x).then(cur);
    };
  }, function (x) {
    return Promise.resolve(x);
  }, list);
};

var parseQuery = function parseQuery(query) {
  return query.slice(1).split('&').reduce(function (prev, cur) {
    var index = cur.indexOf('=');
    var key = cur.substring(0, index);
    var val = cur.substring(index + 1);

    prev[key] = decodeURIComponent(val);
    return prev;
  }, {});
};

var toRegExp = function toRegExp(str) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$needEncode = _ref.needEncode,
      needEncode = _ref$needEncode === undefined ? false : _ref$needEncode,
      _ref$flag = _ref.flag,
      flag = _ref$flag === undefined ? '' : _ref$flag;

  return new RegExp(needEncode ? str.replace(/[[\](){}^$.*+?|]/g, '\\$&') : str, flag);
};

var insertScript = function insertScript(file) {
  var s = document.constructor.prototype.createElement.call(document, 'script');

  s.setAttribute('type', 'text/javascript');
  s.setAttribute('src', file);

  document.documentElement.appendChild(s);
  s.parentNode.removeChild(s);
};

var withTimeout = function withTimeout(timeout, fn) {
  return new Promise(function (resolve, reject) {
    var cancel = function cancel() {
      return clearTimeout(timer);
    };
    var timer = setTimeout(function () {
      reject(new Error('withTimeout: timeout'));
    }, timeout);

    fn(cancel).then(function (data) {
      cancel();
      resolve(data);
    }, function (e) {
      cancel();
      reject(e);
    });
  });
};

var retry = function retry(fn, options) {
  return function () {
    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    var _timeout$retryInterva = _extends({
      timeout: 5000,
      retryInterval: 1000,
      onFirstFail: function onFirstFail() {},
      onFinal: function onFinal() {},
      shouldRetry: function shouldRetry() {
        return false;
      }
    }, options),
        timeout = _timeout$retryInterva.timeout,
        onFirstFail = _timeout$retryInterva.onFirstFail,
        onFinal = _timeout$retryInterva.onFinal,
        shouldRetry = _timeout$retryInterva.shouldRetry,
        retryInterval = _timeout$retryInterva.retryInterval;

    var retryCount = 0;
    var lastError = null;
    var timerToClear = null;
    var done = false;

    var wrappedOnFinal = function wrappedOnFinal() {
      done = true;

      if (timerToClear) {
        clearTimeout(timerToClear);
      }

      return onFinal.apply(undefined, arguments);
    };

    var intervalMan = function () {
      var lastInterval = null;
      var intervalFactory = function () {
        switch (typeof retryInterval === 'undefined' ? 'undefined' : _typeof(retryInterval)) {
          case 'function':
            return retryInterval;

          case 'number':
            return function () {
              return retryInterval;
            };

          default:
            throw new Error('retryInterval must be either a number or a function');
        }
      }();

      return {
        getLastInterval: function getLastInterval() {
          return lastInterval;
        },
        getInterval: function getInterval() {
          var interval = intervalFactory(retryCount, lastInterval);
          lastInterval = interval;
          return interval;
        }
      };
    }();

    var onError = function onError(e, reject) {
      if (!shouldRetry(e, retryCount)) {
        wrappedOnFinal(e);

        if (reject) return reject(e);else throw e;
      }
      lastError = e;

      return new Promise(function (resolve, reject) {
        if (retryCount++ === 0) {
          onFirstFail(e);
          timerToClear = setTimeout(function () {
            wrappedOnFinal(lastError);
            reject(lastError);
          }, timeout);
        }

        if (done) return;

        delay(run, intervalMan.getInterval()).then(resolve, function (e) {
          return onError(e, reject);
        });
      });
    };

    var run = function run() {
      return fn.apply(undefined, args.concat([{
        retryCount: retryCount,
        retryInterval: intervalMan.getLastInterval()
      }])).catch(onError);
    };

    return run().then(function (result) {
      wrappedOnFinal(null, result);
      return result;
    });
  };
};

// refer to https://stackoverflow.com/questions/12168909/blob-from-dataurl
function dataURItoBlob(dataURI) {
  // convert base64 to raw binary data held in a string
  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
  var byteString = atob(dataURI.split(',')[1]);

  // separate out the mime component
  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

  // write the bytes of the string to an ArrayBuffer
  var ab = new ArrayBuffer(byteString.length);

  // create a view into the buffer
  var ia = new Uint8Array(ab);

  // set the bytes of the buffer to the correct values
  for (var i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }

  // write the ArrayBuffer to a blob, and you're done
  var blob = new Blob([ab], { type: mimeString });
  return blob;
}

var randomName = function randomName() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;

  if (length <= 0 || length > 100) throw new Error('randomName, length must be between 1 and 100');

  var randomChar = function randomChar() {
    var n = Math.floor(62 * Math.random());
    var code = void 0;

    if (n <= 9) {
      code = 48 + n;
    } else if (n <= 35) {
      code = 65 + n - 10;
    } else {
      code = 97 + n - 36;
    }

    return String.fromCharCode(code);
  };

  return range(0, length).map(randomChar).join('');
};

var withFileExtension = function withFileExtension(origName, fn) {
  var reg = /\.\w+$/;
  var m = origName.match(reg);

  var extName = m ? m[0] : '';
  var baseName = m ? origName.replace(reg, '') : origName;
  var result = fn(baseName, function (name) {
    return name + extName;
  });

  if (!result) {
    throw new Error('withFileExtension: should not return null/undefined');
  }

  if (typeof result.then === 'function') {
    return result.then(function (name) {
      return name + extName;
    });
  }

  return result + extName;
};

var uniqueName = function uniqueName(name, options) {
  var opts = _extends({
    generate: function generate(old) {
      var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var reg = /_\((\d+)\)$/;
      var m = old.match(reg);

      if (!m) return old + '_(' + step + ')';
      return old.replace(reg, function (_, n) {
        return '_(' + (parseInt(n, 10) + step) + ')';
      });
    },
    check: function check() {
      return Promise.resolve(true);
    }
  }, options);
  var generate = opts.generate,
      check = opts.check;


  return withFileExtension(name, function (baseName, getFullName) {
    var go = function go(fileName, step) {
      return check(getFullName(fileName)).then(function (pass) {
        if (pass) return fileName;
        return go(generate(fileName, step), step);
      });
    };

    return go(baseName, 1);
  });
};

var and = function and() {
  for (var _len6 = arguments.length, list = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    list[_key6] = arguments[_key6];
  }

  return list.reduce(function (prev, cur) {
    return prev && cur;
  }, true);
};

var loadCsv = function loadCsv(url) {
  return fetch(url).then(function (res) {
    if (!res.ok) throw new Error('failed to load csv - ' + url);
    return res.text();
  });
};

var loadImage = function loadImage(url) {
  return fetch(url).then(function (res) {
    if (!res.ok) throw new Error('failed to load image - ' + url);
    return res.blob();
  });
};

var ensureExtName = function ensureExtName(ext, name) {
  var extName = ext.indexOf('.') === 0 ? ext : '.' + ext;
  if (name.lastIndexOf(extName) + extName.length === name.length) return name;
  return name + extName;
};

var validateStandardName = function validateStandardName(name, isFileName) {
  if (!isFileName && !/^_|[a-zA-Z]/.test(name)) {
    throw new Error('must start with a letter or the underscore character.');
  }

  if (isFileName && !/^_|[a-zA-Z0-9]/.test(name)) {
    throw new Error('must start with alpha-numeric or the underscore character.');
  }

  if (!/^[a-zA-Z0-9_]+$/.test(name)) {
    throw new Error('can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ )');
  }
};

var sanitizeFileName = function sanitizeFileName(fileName) {
  return withFileExtension(fileName, function (baseName) {
    return baseName.replace(/[^a-zA-Z0-9_]/g, '_');
  });
};

var getScreenDpi = function getScreenDpi() {
  var DEFAULT_DPI = 96;
  var matchDpi = function matchDpi(dpi) {
    return window.matchMedia('(max-resolution: ' + dpi + 'dpi)').matches === true;
  };

  // We iteratively scan all possible media query matches.
  // We can't use binary search, because there are "many" correct answer in
  // problem space and we need the very first match.
  // To speed up computation we divide problem space into buckets.
  // We test each bucket's first element and if we found a match,
  // we make a full scan for previous bucket with including first match.
  // Still, we could use "divide-and-conquer" for such problems.
  // Due to common DPI values, it's not worth to implement such algorithm.

  var bucketSize = 24; // common divisor for 72, 96, 120, 144 etc.

  for (var i = bucketSize; i < 3000; i += bucketSize) {
    if (matchDpi(i)) {
      var start = i - bucketSize;
      var end = i;

      for (var k = start; k <= end; ++k) {
        if (matchDpi(k)) {
          return k;
        }
      }
    }
  }

  return DEFAULT_DPI; // default fallback
};

var dpiFromFileName = function dpiFromFileName(fileName) {
  var reg = /_dpi_(\d+)/i;
  var m = fileName.match(reg);
  return m ? parseInt(m[1], 10) : 0;
};

var mockAPIWith = function mockAPIWith(factory, mock) {
  var promiseFunctionKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var real = mock;
  var exported = objMap(function (val, key) {
    if (typeof val === 'function') {
      if (promiseFunctionKeys.indexOf(key) !== -1) {
        return function () {
          for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }

          return p.then(function () {
            var _real;

            return (_real = real)[key].apply(_real, args);
          });
        };
      } else {
        return function () {
          var _real3;

          for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }

          p.then(function () {
            var _real2;

            return (_real2 = real)[key].apply(_real2, args);
          });
          return (_real3 = real)[key].apply(_real3, args);
        };
      }
    } else {
      return val;
    }
  }, mock);

  var p = Promise.resolve(factory()).then(function (api) {
    real = api;
  });

  return exported;
};

var withCountDown = function withCountDown(options) {
  var interval = options.interval,
      timeout = options.timeout,
      onTick = options.onTick;

  var past = 0;

  return new Promise(function (resolve, reject) {
    var timer = setInterval(function () {
      past += interval;

      try {
        onTick({ past: past, total: timeout });
      } catch (e) {
        console.error(e);
      }

      if (past >= timeout) clearInterval(timer);
    }, interval);

    var p = delay(function () {}, timeout).then(function () {
      return clearInterval(timer);
    });

    resolve(p);
  });
};

/***/ }),

/***/ "./src/common/web_extension.js":
/*!*************************************!*\
  !*** ./src/common/web_extension.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/* global chrome browser */

// Note: it's an adapter for both chrome and web extension API
// chrome and web extension API have almost the same API signatures
// except that chrome accepts callback while web extension returns promises
//
// The whole idea here is to make sure all callback style API of chrome
// also return promises
//
// Important: You need to specify whatever API you need to use in `UsedAPI` below

(function () {
  var adaptChrome = function adaptChrome(obj, chrome) {
    var adapt = function adapt(src, ret, obj, fn) {
      return Object.keys(obj).reduce(function (prev, key) {
        var keyParts = key.split('.');

        var _keyParts$reduce = keyParts.reduce(function (tuple, subkey) {
          var tar = tuple[0];
          var src = tuple[1];

          tar[subkey] = tar[subkey] || {};
          return [tar[subkey], src && src[subkey]];
        }, [prev, src]),
            _keyParts$reduce2 = _slicedToArray(_keyParts$reduce, 2),
            target = _keyParts$reduce2[0],
            source = _keyParts$reduce2[1];

        obj[key].forEach(function (method) {
          fn(method, source, target);
        });

        return prev;
      }, ret);
    };

    var promisify = function promisify(method, source, target) {
      if (!source) return;
      var reg = /The message port closed before a res?ponse was received/;

      target[method] = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new Promise(function (resolve, reject) {
          var callback = function callback(result) {
            // Note: The message port closed before a reponse was received.
            // Ignore this message
            if (chrome.runtime.lastError && !reg.test(chrome.runtime.lastError.message)) {
              console.error(chrome.runtime.lastError.message + ', ' + method + ', ' + JSON.stringify(args));
              return reject(chrome.runtime.lastError);
            }
            resolve(result);
          };

          source[method].apply(source, args.concat(callback));
        });
      };
    };

    var copy = function copy(method, source, target) {
      if (!source) return;
      target[method] = source[method];
    };

    return [[obj.toPromisify, promisify], [obj.toCopy, copy]].reduce(function (prev, tuple) {
      return adapt(chrome, prev, tuple[0], tuple[1]);
    }, {});
  };

  var UsedAPI = {
    toPromisify: {
      tabs: ['create', 'sendMessage', 'get', 'update', 'query', 'captureVisibleTab', 'remove'],
      windows: ['update', 'getLastFocused', 'getCurrent', 'getAll', 'remove', 'create', 'get'],
      runtime: ['sendMessage', 'setUninstallURL'],
      cookies: ['get', 'getAll', 'set', 'remove'],
      notifications: ['create', 'clear'],
      browserAction: ['getBadgeText'],
      bookmarks: ['create', 'getTree'],
      debugger: ['attach', 'detach', 'sendCommand', 'getTargets'],
      'storage.local': ['get', 'set']
    },
    toCopy: {
      tabs: ['onActivated', 'onUpdated'],
      windows: ['onFocusChanged'],
      runtime: ['onMessage', 'onInstalled', 'getManifest'],
      storage: ['onChanged'],
      browserAction: ['setBadgeText', 'setBadgeBackgroundColor', 'onClicked'],
      extension: ['getURL'],
      debugger: ['onEvent', 'onDetach'],
      downloads: ['onCreated', 'onChanged', 'onDeterminingFilename']
    }
  };

  var Ext = typeof chrome !== 'undefined' ? adaptChrome(UsedAPI, chrome) : browser;

  _extends(Ext, {
    isFirefox: function isFirefox() {
      return (/Firefox/.test(window.navigator.userAgent)
      );
    }
  });

  if (true) {
    module.exports = Ext;
  } else {}
})();

/***/ }),

/***/ "./src/ext/content_script/index.js":
/*!*****************************************!*\
  !*** ./src/ext/content_script/index.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_web_extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _common_web_extension__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_common_web_extension__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/storage */ "./src/common/storage/index.js");
/* harmony import */ var _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/ipc/ipc_cs */ "./src/common/ipc/ipc_cs.js");
/* harmony import */ var _common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ipc/cs_postmessage */ "./src/common/ipc/cs_postmessage.js");
/* harmony import */ var _common_inspector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/inspector */ "./src/common/inspector.js");
/* harmony import */ var _common_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/constant */ "./src/common/constant.js");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/utils */ "./src/common/utils.js");
/* harmony import */ var _common_dom_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/dom_utils */ "./src/common/dom_utils.js");
/* harmony import */ var _common_command_runner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/command_runner */ "./src/common/command_runner.js");
/* harmony import */ var _common_capture_screenshot__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/capture_screenshot */ "./src/common/capture_screenshot.js");
/* harmony import */ var _common_encrypt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/encrypt */ "./src/common/encrypt.js");
/* harmony import */ var _common_log__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../common/log */ "./src/common/log.js");
/* harmony import */ var _select_area__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./select_area */ "./src/ext/content_script/select_area.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }















var MASK_CLICK_FADE_TIMEOUT = 2000;
var oops =  false ? undefined : function (e) {
  return _common_log__WEBPACK_IMPORTED_MODULE_11__["default"].error(e.stack);
};

var state = {
  status: _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].NORMAL,
  // Note: it decides whether we're running commands
  // in the current window or some iframe/frame
  playingFrame: window,
  // Note: current frame stack when recording, it helps
  // to generate `selectFrame` commands
  recordingFrameStack: [],
  // Note: snapshot of extension config (content script cares about click/clickAt when recording)
  // It is supposed to be updated when user activates that page
  config: {}

  // Note: Whether it's top or inner window, a content script has the need
  // to send IPC message to background. But in our design, only the top window
  // has access to the real csIpc, while inner frames have to bubble up the messages
  // to the top window.
  // So inner windows are provided with a fake csIpc, which post messages to its parent
};var superCsIpc = window.top === window ? _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"] : {
  ask: function ask(ipcAction, ipcData) {
    return Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
      action: 'IPC_CALL',
      data: { ipcAction: ipcAction, ipcData: ipcData }
    });
  }
};

var calcSelectFrameCmds = function calcSelectFrameCmds(frameStack) {
  var xs = state.recordingFrameStack;
  var ys = frameStack;
  var len = Math.min(xs.length, ys.length);
  var tpl = { cmd: 'selectFrame', url: window.location.href };
  var ret = [];
  var i = 0;

  for (i = 0; i < len; i++) {
    if (xs[i] !== ys[i]) {
      break;
    }
  }

  if (i === 0) {
    // No need for relative=top, if state.recordingFrameStack is empty
    if (xs.length !== 0) {
      ret.push(_extends({}, tpl, { target: 'relative=top' }));
    }
  } else if (i < len) {
    for (var j = i; j < xs.length; j++) {
      ret.push(_extends({}, tpl, { target: 'relative=parent' }));
    }
  }

  for (var _j = i; _j < ys.length; _j++) {
    ret.push(_extends({}, tpl, { target: ys[_j] }));
  }

  return ret;
};

// Two masks to show on page
// 1. mask on click
// 2. mask on hover
var getMask = function () {
  var mask = void 0,
      factory = void 0;

  var addLogoImg = function addLogoImg($dom) {
    var $img = createLogoImg();

    _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($img, {
      position: 'absolute',
      top: '-25px',
      left: '0',
      width: '20px',
      height: '20px'
    });

    $dom.appendChild($img);
  };

  return function (remove) {
    if (remove && factory) return factory.clear();
    if (mask) return mask;

    factory = _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].maskFactory();

    var maskClick = factory.gen({ background: 'green', border: '2px solid purple' });
    var maskHover = factory.gen({ background: '#ffa800', border: '2px solid purple' });

    addLogoImg(maskClick);
    addLogoImg(maskHover);

    console.log('maskClick', maskClick);

    mask = { maskClick: maskClick, maskHover: maskHover };

    document.body.appendChild(maskClick);
    document.body.appendChild(maskHover);

    return mask;
  };
}();

var createLogoImg = function createLogoImg() {
  // Note: Ext.extension.getURL is available in content script, but not injected js
  // So there are cases when content_script.js is run as injected js, where `Ext.extension.getURL`
  // is not available
  // Weird enough, `Ext.extension.getURL` always works well in macOS
  var url = _common_web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.extension.getURL ? _common_web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.extension.getURL('logo.png') : '';
  var img = new Image();

  img.src = url;
  return img;
};

var addWaitInCommand = function addWaitInCommand(cmdObj) {
  var cmd = cmdObj.cmd;


  switch (cmd) {
    case 'click':
    case 'clickAt':
      return _extends({}, cmdObj, { cmd: 'clickAndWait', value: '' });

    case 'select':
      return _extends({}, cmdObj, { cmd: 'selectAndWait' });

    default:
      return cmdObj;
  }
};

// report recorded commands to background.
// transform `leave` event to clickAndWait / selectAndWait event based on the last command
var reportCommand = function () {
  var LEAVE_INTERVAL = 500;
  var last = null;
  var lastTime = null;
  var timer = null;

  return function (obj) {
    obj = _extends({}, obj, { url: window.location.href });

    Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('to report', obj);

    // Change back to top frame if it was recording inside
    if (state.recordingFrameStack.length > 0) {
      state.recordingFrameStack = [];

      superCsIpc.ask('CS_RECORD_ADD_COMMAND', {
        cmd: 'selectFrame',
        target: 'relative=top',
        url: window.location.href
      }).catch(oops);
    }

    switch (obj.cmd) {
      case 'leave':
        {
          if (timer) {
            clearTimeout(timer);
          }

          if (new Date() - lastTime < LEAVE_INTERVAL) {
            obj = addWaitInCommand(last);
          } else {
            return;
          }

          break;
        }
      case 'click':
      case 'clickAt':
      case 'select':
        {
          timer = setTimeout(function () {
            superCsIpc.ask('CS_RECORD_ADD_COMMAND', obj).catch(oops);
          }, LEAVE_INTERVAL);

          last = obj;
          lastTime = new Date();

          return;
        }

      default:
        break;
    }

    last = obj;
    lastTime = new Date();

    superCsIpc.ask('CS_RECORD_ADD_COMMAND', obj).catch(oops);
  };
}();

var isValidClick = function isValidClick(el) {
  // Note: all elements are allowed to be recorded when clicked
  return true;

  // if (el === document.body) return false
  //
  // const tag   = el.tagName.toLowerCase()
  // const type  = el.getAttribute('type')
  // const role  = el.getAttribute('role')
  //
  // if (tag === 'a' || tag === 'button')  return true
  // if (tag === 'input' && ['radio', 'checkbox'].indexOf(type) !== -1)  return true
  // if (['link', 'button', 'checkbox', 'radio'].indexOf(role) !== -1)   return true
  //
  // return isValidClick(el.parentNode)
};

var isValidSelect = function isValidSelect(el) {
  var tag = el.tagName.toLowerCase();

  if (['option', 'select'].indexOf(tag) !== -1) return true;
  return false;
};

var isValidType = function isValidType(el) {
  var tag = el.tagName.toLowerCase();
  var type = el.getAttribute('type');

  if (tag === 'textarea') return true;
  if (tag === 'input' && ['radio, checkbox'].indexOf(type) === -1) return true;

  return false;
};

var highlightDom = function highlightDom($dom, timeout) {
  var mask = getMask();

  _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].showMaskOver(mask.maskClick, $dom);

  setTimeout(function () {
    _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle(mask.maskClick, { display: 'none' });
  }, timeout || MASK_CLICK_FADE_TIMEOUT);
};

var createHighlightRect = function createHighlightRect() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var $mask = document.createElement('div');
  var $text = document.createElement('div');
  var timer = void 0;

  _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($mask, {
    position: 'absolute',
    zIndex: 110001,
    border: '1px solid orange',
    color: 'orange',
    display: 'none',
    pointerEvents: 'none'
  });

  _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($text, {
    position: 'absolute',
    top: 0,
    left: 0,
    transform: 'translate(-100%, -100%)',
    fontSize: '14px'
  });

  $mask.appendChild($text);

  return function (rect, timeout) {
    clearTimeout(timer);
    $text.innerText = parseFloat(rect.score).toFixed(2);

    _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($mask, _extends({
      display: 'block',
      top: rect.top + 'px',
      left: rect.left + 'px',
      width: rect.width + 'px',
      height: rect.height + 'px'
    }, opts.rectStyle || {}));

    _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($text, opts.textStyle || {});

    if (!$mask.parentNode) {
      document.body.appendChild($mask);
    }

    if (opts.scrollIntoView) {
      $mask.scrollIntoView({ block: 'center', behavior: 'smooth' });
    }

    if (timeout && timeout > 0) {
      timer = setTimeout(function () {
        _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($mask, { display: 'none' });
      }, timeout);
    }

    return function () {
      _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle($mask, { display: 'none' });
      $mask.remove();
    };
  };
};

var highlightRect = createHighlightRect();

var highlightRects = function () {
  var topMatchedOptions = {
    rectStyle: {
      borderColor: '#ff00ff',
      color: '#ff00ff'
    }
  };
  var destroy = void 0;

  return function (rects, timeout) {
    if (destroy) destroy();
    var destroyFns = rects.map(function (rect, i) {
      return createHighlightRect(i === 0 ? topMatchedOptions : {})(rect, timeout);
    });
    destroy = function destroy() {
      return destroyFns.forEach(function (destroy) {
        return destroy();
      });
    };
    return destroy;
  };
}();

var onClick = function onClick(e) {
  if (!isValidClick(e.target)) return;

  var targetInfo = _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true);

  Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('onClick, switch  case', state.config.recordClickType);
  switch (state.config.recordClickType) {
    case 'clickAt':
      reportCommand(_extends({}, targetInfo, {
        cmd: 'clickAt',
        value: function () {
          var clientX = e.clientX,
              clientY = e.clientY;

          var _e$target$getBounding = e.target.getBoundingClientRect(),
              top = _e$target$getBounding.top,
              left = _e$target$getBounding.left;

          var x = Math.round(clientX - left);
          var y = Math.round(clientY - top);

          return x + ',' + y;
        }()
      }));
      break;

    case 'click':
    default:
      reportCommand(_extends({}, targetInfo, {
        cmd: 'click'
      }));
      break;
  }
};

var onChange = function onChange(e) {
  if (isValidSelect(e.target)) {
    var value = e.target.value;
    var $option = Array.from(e.target.children).find(function ($op) {
      return $op.value === value;
    });

    reportCommand(_extends({
      cmd: 'select',
      value: 'label=' + _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].domText($option).trim()
    }, _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true)));
  } else if (isValidType(e.target)) {
    var _value = (e.target.value || '').replace(/\n/g, '\\n');

    Object(_common_encrypt__WEBPACK_IMPORTED_MODULE_10__["encryptIfNeeded"])(_value, e.target).then(function (realValue) {
      reportCommand(_extends({
        cmd: 'type',
        value: realValue
      }, _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true)));
    });
  }
};

var onContentEditableChange = function onContentEditableChange(e) {
  reportCommand(_extends({
    cmd: 'editContent',
    value: e.target.innerHTML
  }, _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true)));
};

var onDragDrop = function () {
  var dragStart = null;

  return function (e) {
    switch (e.type) {
      case 'dragstart':
        {
          dragStart = _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true);
          break;
        }
      case 'drop':
        {
          if (!dragStart) return;
          var tmp = _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true);
          var drop = {
            value: tmp.target,
            valueOptions: tmp.targetOptions
          };

          reportCommand(_extends({
            cmd: 'dragAndDropToObject'
          }, dragStart, drop));

          dragStart = null;
        }
    }
  };
}();

var onLeave = function onLeave(e) {
  reportCommand({
    cmd: 'leave',
    target: null,
    value: null
  });

  setTimeout(function () {
    reportCommand({
      cmd: 'pullback',
      target: null,
      value: null
    });
  }, 800);
};

var unbindContentEditableEvents = void 0;

var bindEventsToRecord = function bindEventsToRecord() {
  document.addEventListener('click', onClick, true);
  document.addEventListener('change', onChange, true);
  document.addEventListener('dragstart', onDragDrop, true);
  document.addEventListener('drop', onDragDrop, true);
  window.addEventListener('beforeunload', onLeave, true);

  unbindContentEditableEvents = Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_7__["bindContentEditableChange"])({ onChange: onContentEditableChange });
};

var unbindEventsToRecord = function unbindEventsToRecord() {
  document.removeEventListener('click', onClick, true);
  document.removeEventListener('change', onChange, true);
  document.removeEventListener('dragstart', onDragDrop, true);
  document.removeEventListener('drop', onDragDrop, true);
  window.removeEventListener('beforeunload', onLeave, true);

  if (unbindContentEditableEvents) {
    unbindContentEditableEvents();
  }
};

var waitForDomReady = function waitForDomReady(accurate) {
  return Object(_common_utils__WEBPACK_IMPORTED_MODULE_6__["until"])('dom ready', function () {
    return {
      pass: ['complete', 'interactive'].slice(0, accurate ? 1 : 2).indexOf(document.readyState) !== -1,
      result: true
    };
  }, 1000, 6000 * 10);
};

var broadcastToAllFrames = function broadcastToAllFrames(action, data) {
  // IMPORTANT: broadcast status change to all frames inside
  var frames = window.frames;

  for (var i = 0, len = frames.length; i < len; i++) {
    Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(frames[i], window, {
      action: action,
      data: data
    });
  }
};

var updateStatus = function updateStatus(args) {
  if (!args.status) {
    throw new Error('SET_STATUS: missing args.status');
  }
  if (!_common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"][args.status]) {
    throw new Error('SET_STATUS: invalid args.status - ' + args.status);
  }

  _extends(state, {
    status: args.status
  });

  if (args.status === _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].NORMAL || args.status === _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].RECORDING) {
    bindEventsToRecord();
  } else {
    unbindEventsToRecord();
  }

  // replace alert/confirm/prompt with our version when playing
  if (args.status === _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].PLAYING) {
    hackAlertConfirmPrompt();
  } else {
    restoreAlertConfirmPrompt();
  }

  // Note: clear recording frame stack whenever it stops recording
  if (args.status === _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].NORMAL) {
    state.recordingFrameStack = [];
    state.playingFrame = window;
  }

  // IMPORTANT: broadcast status change to all frames inside
  broadcastToAllFrames('SET_STATUS', args);
};

var bindIPCListener = function bindIPCListener() {
  // Note: need to check csIpc in case it's a none-src iframe into which we
  // inject content_script.js. It has no access to chrome api, thus no csIpc available
  if (!_common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"]) return;

  // Note: csIpc instead of superIpc, because only top window is able
  // to listen to ipc events from bg
  _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].onAsk(function (cmd, args) {
    Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])(cmd, args);

    switch (cmd) {
      case 'HEART_BEAT':
        return true;

      case 'SET_STATUS':
        {
          updateStatus(args);
          return true;
        }

      case 'DOM_READY':
        return waitForDomReady(false);

      case 'RUN_COMMAND':
        return runCommand(args.command).catch(function (e) {
          // Mark that there is already at least one command run
          window.noCommandsYet = false;

          _common_log__WEBPACK_IMPORTED_MODULE_11__["default"].error(e.stack);
          throw e;
        }).then(function (data) {
          // Mark that there is already at least one command run
          window.noCommandsYet = false;

          if (state.playingFrame !== window) {
            return { data: data, isIFrame: true };
          }

          return { data: data };
        });

      case 'FIND_DOM':
        {
          try {
            var $el = Object(_common_command_runner__WEBPACK_IMPORTED_MODULE_8__["getElementByLocator"])(args.locator);
            return true;
          } catch (e) {
            return false;
          }
        }

      case 'HIGHLIGHT_DOM':
        {
          var _$el = Object(_common_command_runner__WEBPACK_IMPORTED_MODULE_8__["getElementByLocator"])(args.locator);

          if (_$el) {
            _$el.scrollIntoView({ block: 'center' });
            highlightDom(_$el);
          }

          return true;
        }

      case 'HIGHLIGHT_RECT':
        {
          highlightRect(args.scoredRect);
          return true;
        }

      case 'HIGHLIGHT_RECTS':
        {
          highlightRects(args.scoredRects);
          return true;
        }

      case 'CLEAR_VISION_RECTS':
        {
          // Note: it will clear previous rects
          highlightRects([]);
          return true;
        }

      case 'HACK_ALERT':
        {
          hackAlertConfirmPrompt();
          return true;
        }

      case 'MARK_NO_COMMANDS_YET':
        {
          window.noCommandsYet = true;
          return true;
        }

      case 'SCREENSHOT_PAGE_INFO':
        {
          return _common_capture_screenshot__WEBPACK_IMPORTED_MODULE_9__["captureClientAPI"].getPageInfo();
        }

      case 'START_CAPTURE_FULL_SCREENSHOT':
        {
          return _common_capture_screenshot__WEBPACK_IMPORTED_MODULE_9__["captureClientAPI"].startCapture(args || {});
        }

      case 'END_CAPTURE_FULL_SCREENSHOT':
        {
          return _common_capture_screenshot__WEBPACK_IMPORTED_MODULE_9__["captureClientAPI"].endCapture(args.pageInfo);
        }

      case 'SCROLL_PAGE':
        {
          return _common_capture_screenshot__WEBPACK_IMPORTED_MODULE_9__["captureClientAPI"].scrollPage(args.offset);
        }

      case 'TAB_ACTIVATED':
        {
          loadConfig();
          return;
        }

      case 'SELECT_SCREEN_AREA':
        {
          return Object(_select_area__WEBPACK_IMPORTED_MODULE_12__["selectArea"])({
            promise: true,
            done: function done(rect, boundingRect) {
              Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('SELECT_SCREEN_AREA  - selectArea', rect, boundingRect);
              return _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].ask('CS_SCREEN_AREA_SELECTED', {
                rect: {
                  x: boundingRect.x,
                  y: boundingRect.y,
                  width: boundingRect.width,
                  height: boundingRect.height
                },
                devicePixelRatio: window.devicePixelRatio
              });
            }
          });
        }

      default:
        throw new Error('cmd not supported: ' + cmd);
    }
  });
};

var bindEventsToInspect = function bindEventsToInspect() {
  // Bind click events for inspecting
  document.addEventListener('click', function (e) {
    switch (state.status) {
      case _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].INSPECTING:
        {
          e.preventDefault();

          var mask = getMask();

          _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle(mask.maskHover, { display: 'none' });
          _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].showMaskOver(mask.maskClick, e.target);

          setTimeout(function () {
            _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].setStyle(mask.maskClick, { display: 'none' });
          }, MASK_CLICK_FADE_TIMEOUT);

          _extends(state, {
            status: _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].NORMAL
          });

          return superCsIpc.ask('CS_DONE_INSPECTING', {
            locatorInfo: _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getLocator(e.target, true)
          }).catch(oops);
        }

      default:
        break;
    }
  });

  // bind mouse over event for applying for a inspector role
  document.addEventListener('mouseover', function (e) {
    if (state.status === _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].NORMAL) {
      return superCsIpc.ask('CS_ACTIVATE_ME', {}).catch(oops);
    }
  });

  // bind mouse move event to show hover mask in inspecting
  document.addEventListener('mousemove', function (e) {
    if (state.status !== _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].INSPECTING) return;

    var mask = getMask();
    _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].showMaskOver(mask.maskHover, e.target);
  });
};

var bindOnMessage = function bindOnMessage() {
  Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["onMessage"])(window, function (_ref, _ref2) {
    var action = _ref.action,
        data = _ref.data;
    var source = _ref2.source;

    Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('onMessage', action, data, source);

    switch (action) {
      case 'SET_STATUS':
        updateStatus(data);
        return true;

      case 'UPDATE_CONFIG':
        {
          state.config = data;
          return true;
        }

      // inner frames may receive this message when there are
      // some previous `selectFrame` command
      case 'RUN_COMMAND':
        // runCommand will decide whether to run in this window or pass on
        return runCommand(data);

      // inner frames send IPC_CALL to background,
      // It will go step by step up to the topmost frame, which has
      // the access to csIpc
      case 'IPC_CALL':
        // When recording, need to calculate `selectFrame` by ourselves
        // * for inner frames, add current frame locator to frame stack
        // * for top frame, send `selectFrame` commands before the original command
        //   and keep track of the latest frame stack
        if (data.ipcAction === 'CS_RECORD_ADD_COMMAND' && data.ipcData.cmd !== 'pullback') {
          // Note: Do not send any RECORD_ADD_COMMAND in playing mode
          if (state.status === _common_constant__WEBPACK_IMPORTED_MODULE_5__["CONTENT_SCRIPT_STATUS"].PLAYING) {
            return false;
          }

          data = Object(_common_utils__WEBPACK_IMPORTED_MODULE_6__["updateIn"])(['ipcData', 'frameStack'], function () {
            var stack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            return [_common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].getFrameLocator(source, window)].concat(_toConsumableArray(stack));
          }, data);

          if (window.top === window) {
            calcSelectFrameCmds(data.ipcData.frameStack).forEach(function (cmd) {
              _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].ask('CS_RECORD_ADD_COMMAND', cmd).catch(oops);
            });

            state.recordingFrameStack = data.ipcData.frameStack;
          }
        }

        if (window.top === window) {
          return _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].ask(data.ipcAction, data.ipcData).catch(oops);
        } else {
          return Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, { action: action, data: data });
        }

      case 'RESET_PLAYING_FRAME':
        {
          state.playingFrame = window;

          // pass on RESET_PLAYING_FRAME to parent, all the way till top window
          if (data === 'TOP' && window.top !== window) {
            Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
              action: 'RESET_PLAYING_FRAME',
              data: 'TOP'
            });
          }

          return true;
        }

      case 'SOURCE_PAGE_OFFSET':
        {
          var $frames = [].concat(_toConsumableArray(Array.from(document.getElementsByTagName('iframe'))), _toConsumableArray(Array.from(document.getElementsByTagName('frame'))));
          var $frameElement = $frames.find(function ($frame) {
            return $frame.contentWindow === source;
          });
          var offset = _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].offset($frameElement, true);
          var x = offset.left;
          var y = offset.top;
          Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('SOURCE_PAGE_OFFSET, iframeDOM', $frameElement);

          if (window.top === window) {
            return { x: x, y: y };
          }

          return Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
            action: 'SOURCE_PAGE_OFFSET',
            data: {}
          }).then(function (parentOffset) {
            return {
              x: x + parentOffset.x,
              y: y + parentOffset.y
            };
          });
        }

      case 'SOURCE_BOUNDING_BOX_OFFSET':
        {
          var _$frames = [].concat(_toConsumableArray(Array.from(document.getElementsByTagName('iframe'))), _toConsumableArray(Array.from(document.getElementsByTagName('frame'))));
          var _$frameElement = _$frames.find(function ($frame) {
            return $frame.contentWindow === source;
          });
          var rect = _$frameElement.getBoundingClientRect();

          if (window.top === window) {
            return {
              x: rect.x,
              y: rect.y
            };
          }

          return Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
            action: 'SOURCE_BOUNDING_BOX_OFFSET',
            data: {}
          }).then(function (parentOffset) {
            return {
              x: rect.x + parentOffset.x,
              y: rect.y + parentOffset.y
            };
          });
        }
    }
  });
};

var bindInvokeEvent = function bindInvokeEvent() {
  // Macros
  window.addEventListener('kantuRunMacro', function (e) {
    Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('invoke event', e);
    window.dispatchEvent(new CustomEvent('kantuInvokeSuccess'));

    var queries = Object(_common_utils__WEBPACK_IMPORTED_MODULE_6__["parseQuery"])(window.location.search);
    _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].ask('CS_INVOKE', { testCase: e.detail, options: queries }).catch(function (e) {
      return alert('[kantu] ' + e.message);
    });
  });

  window.addEventListener('kantuSaveAndRunMacro', function (e) {
    Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('save and run macro event', e);
    window.dispatchEvent(new CustomEvent('kantuInvokeSuccess'));

    var queries = Object(_common_utils__WEBPACK_IMPORTED_MODULE_6__["parseQuery"])(window.location.search);
    var direct = window.location.protocol === 'file:' && !!queries['direct'];
    var agree = direct || confirm('Kantu: Do you want to import and run this macro?\n\nNote: To run the macro without this confirmation box, add the \'?direct=1\' switch to the URL. Example: file:///xx/xx/macro.html?direct=1');

    if (agree) {
      _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].ask('CS_IMPORT_HTML_AND_INVOKE', _extends({}, e.detail, { from: 'html', options: queries })).catch(function (e) {
        return alert('[kantu] ' + e.message);
      });
    }
  });

  // Test Suites
  window.addEventListener('kantuRunTestSuite', function (e) {
    Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('invoke event', e);
    window.dispatchEvent(new CustomEvent('kantuInvokeSuccess'));

    var queries = Object(_common_utils__WEBPACK_IMPORTED_MODULE_6__["parseQuery"])(window.location.search);
    _common_ipc_ipc_cs__WEBPACK_IMPORTED_MODULE_2__["default"].ask('CS_INVOKE', { testSuite: e.detail, options: queries }).catch(function (e) {
      return alert('[kantu] ' + e.message);
    });
  });
};

var hackAlertConfirmPrompt = function hackAlertConfirmPrompt() {
  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

  var script = '\n    if (!window.oldAlert)     window.oldAlert   = window.alert\n    if (!window.oldConfirm)   window.oldConfirm = window.confirm\n    if (!window.oldPrompt)    window.oldPrompt  = window.prompt\n\n    window.alert = function (str) {\n      document.body.setAttribute(\'data-alert\', str)\n    }\n\n    window.confirm = function (str) {\n      document.body.setAttribute(\'data-confirm\', str)\n      return true\n    }\n\n    window.prompt = function (str) {\n      var answer = document.body.getAttribute(\'data-prompt-answer\')\n      document.body.setAttribute(\'data-prompt\', str)\n      document.body.setAttribute(\'data-prompt-answer\', \'\')\n      return answer\n    }\n  ';
  var s = doc.constructor.prototype.createElement.call(doc, 'script');

  s.setAttribute('type', 'text/javascript');
  s.text = script;

  doc.documentElement.appendChild(s);
  s.parentNode.removeChild(s);
};

var restoreAlertConfirmPrompt = function restoreAlertConfirmPrompt() {
  var script = '\n    if (window.oldAlert)    window.alert = window.oldAlert\n    if (window.oldConfirm)  window.confirm = window.oldConfirm\n    if (window.oldPrompt)   window.prompt = window.oldPrompt\n  ';
  var s = document.constructor.prototype.createElement.call(document, 'script');

  s.setAttribute('type', 'text/javascript');
  s.text = script;

  document.documentElement.appendChild(s);
  s.parentNode.removeChild(s);
};

var init = function init() {
  unbindEventsToRecord();
  bindEventsToRecord();

  bindEventsToInspect();
  bindOnMessage();
  loadConfig();

  // Note: only bind ipc events if it's the top window
  if (window.top === window) {
    bindIPCListener();
    bindInvokeEvent();
  } else {
    onUrlChange(init);
  }
};

var runCommand = function runCommand(command) {
  if (!command.cmd) {
    throw new Error('runCommand: must provide cmd');
  }

  // if it's an 'open' command, it must be executed in the top window
  if (state.playingFrame === window || command.cmd === 'open') {
    // Note: both top and inner frames could run commands here
    // So must use superCsIpc instead of csIpc
    var ret = Object(_common_command_runner__WEBPACK_IMPORTED_MODULE_8__["run"])(command, superCsIpc, {
      highlightDom: highlightDom,
      hackAlertConfirmPrompt: hackAlertConfirmPrompt,
      xpath: _common_inspector__WEBPACK_IMPORTED_MODULE_4__["default"].xpath
    });

    // Note: `run` returns the contentWindow of the selected frame
    if (command.cmd === 'selectFrame') {
      return ret.then(function (_ref3) {
        var frame = _ref3.frame;

        // let outside window know that playingFrame has been changed, if it's parent or top
        if (frame !== window && (frame === window.top || frame === window.parent)) {
          Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(window.parent, window, {
            action: 'RESET_PLAYING_FRAME',
            data: frame === window.top ? 'TOP' : 'PARENT'
          });

          // set playingFrame to own window, get ready for later commands if any
          state.playingFrame = window;
        } else {
          state.playingFrame = frame;
        }

        return Promise.resolve({
          pageUrl: window.location.href,
          extra: command.extra
        });
      });
    }

    // Extra info passed on to background, it contains timeout info
    var wrapResult = function wrapResult(ret) {
      return _extends({}, (typeof ret === 'undefined' ? 'undefined' : _typeof(ret)) === 'object' ? ret : {}, {
        pageUrl: window.location.href,
        extra: command.extra,
        // Note: undefined value in an Object will be eliminated during message passing,
        // Have to transform it into an object first, and convert it back in front end
        vars: !ret.vars ? undefined : Object(_common_utils__WEBPACK_IMPORTED_MODULE_6__["objMap"])(function (val) {
          return val !== undefined ? val : { __undefined__: true };
        }, ret.vars)
      });
    };

    return Promise.resolve(ret).then(wrapResult);
  } else {
    // log('passing command to frame...', state.playingFrame, '...', window.location.href)
    // Note: pass on the command if our window is not the current playing one
    return Object(_common_ipc_cs_postmessage__WEBPACK_IMPORTED_MODULE_3__["postMessage"])(state.playingFrame, window, {
      action: 'RUN_COMMAND',
      data: command
    });
  }
};

// Note: for cases like https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_onblur
// There is a kind of strange refresh in the iframe on right hand side,
// while content script is not reloaded in the mean time, it causes that iframe not able to be recorded
// So we have to listen to url change in iframes for this case.
var onUrlChange = function () {
  var callback = function callback() {};
  var lastUrl = window.location.href;
  var check = function check() {
    if (window.location.href !== lastUrl) {
      Object(_common_log__WEBPACK_IMPORTED_MODULE_11__["default"])('url changed', lastUrl, window.location.href);
      lastUrl = window.location.href;
      callback();
    }
  };

  if (window.top === window) {
    return function () {};
  }

  setInterval(check, 2000);

  return function (fn) {
    callback = fn;
  };
}();

var loadConfig = function loadConfig() {
  _common_storage__WEBPACK_IMPORTED_MODULE_1__["default"].get('config').then(function (config) {
    state.config = config;

    // IMPORTANT: broadcast status change to all frames inside
    broadcastToAllFrames('UPDATE_CONFIG', config);
  });
};

init();

/***/ }),

/***/ "./src/ext/content_script/select_area.js":
/*!***********************************************!*\
  !*** ./src/ext/content_script/select_area.js ***!
  \***********************************************/
/*! exports provided: commonStyle, createEl, createRect, selectArea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonStyle", function() { return commonStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEl", function() { return createEl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRect", function() { return createRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectArea", function() { return selectArea; });
/* harmony import */ var _common_dom_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/dom_utils */ "./src/common/dom_utils.js");
/* harmony import */ var _common_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/box */ "./src/common/box.js");
/* harmony import */ var _common_web_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/web_extension */ "./src/common/web_extension.js");
/* harmony import */ var _common_web_extension__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_common_web_extension__WEBPACK_IMPORTED_MODULE_2__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var commonStyle = {
  boxSizing: 'border-box',
  fontFamily: 'Arial'
};

var createEl = function createEl(_ref) {
  var _ref$tag = _ref.tag,
      tag = _ref$tag === undefined ? 'div' : _ref$tag,
      _ref$attrs = _ref.attrs,
      attrs = _ref$attrs === undefined ? {} : _ref$attrs,
      _ref$style = _ref.style,
      style = _ref$style === undefined ? {} : _ref$style,
      text = _ref.text;

  var $el = document.createElement(tag);

  Object.keys(attrs).forEach(function (key) {
    $el.setAttribute(key, attrs[key]);
  });

  if (text && text.length) {
    $el.innerText = text;
  }

  Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["setStyle"])($el, style);
  return $el;
};

var createRect = function createRect(opts) {
  var containerStyle = _extends({}, commonStyle, {
    position: 'absolute',
    zIndex: 100000,
    top: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(opts.top),
    left: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(opts.left),
    width: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(opts.width),
    height: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(opts.height)
  }, opts.containerStyle || {});
  var rectStyle = _extends({}, commonStyle, {
    width: '100%',
    height: '100%',
    border: opts.rectBorderWidth + 'px solid rgb(239, 93, 143)',
    cursor: 'move',
    background: 'transparent'
  }, opts.rectStyle || {});

  var $container = createEl({ style: containerStyle });
  var $rectangle = createEl({ style: rectStyle });

  $container.appendChild($rectangle);
  document.body.appendChild($container);

  return {
    $container: $container,
    $rectangle: $rectangle,
    destroy: function destroy() {
      $container.remove();
    },
    hide: function hide() {
      Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["setStyle"])($container, { display: 'none' });
    },
    show: function show() {
      Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["setStyle"])($container, { display: 'block' });
    }
  };
};

var createOverlay = function createOverlay() {
  var $overlay = createEl({
    style: {
      position: 'fixed',
      zIndex: 9000,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      background: 'transparent',
      cursor: 'crosshair'
    }
  });

  document.body.appendChild($overlay);
  return function () {
    return $overlay.remove();
  };
};

var selectArea = function selectArea(_ref2) {
  var done = _ref2.done,
      _ref2$promise = _ref2.promise,
      promise = _ref2$promise === undefined ? false : _ref2$promise;

  var go = function go(done) {
    var state = {
      box: null,
      activated: false,
      startPos: null,
      rect: null
    };
    var resetBodyStyle = function () {
      var userSelectKey = _common_web_extension__WEBPACK_IMPORTED_MODULE_2___default.a.isFirefox() ? '-moz-user-select' : 'user-select';
      var style = window.getComputedStyle(document.body);
      var oldCursor = style.cursor;
      var oldUserSelect = style[userSelectKey];

      Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["setStyle"])(document.body, _defineProperty({
        cursor: 'crosshair'
      }, userSelectKey, 'none'));
      return function () {
        return Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["setStyle"])(document.body, _defineProperty({ cursor: oldCursor }, userSelectKey, oldUserSelect));
      };
    }();

    var removeOverlay = createOverlay();
    var unbindDrag = Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["bindDrag"])({
      $el: document,
      onDragStart: function onDragStart(e) {
        e.preventDefault();

        state.activated = true;
        state.startPos = {
          x: e.pageX,
          y: e.pageY
        };
      },
      onDragEnd: function onDragEnd(e) {
        e.preventDefault();

        state.activated = false;

        if (state.box) {
          state.box.moveAnchorEnd();

          var boundingRect = rectObj.$container.getBoundingClientRect();
          API.hide();

          // Note: API.hide() takes some time to have effect
          setTimeout(function () {
            done(state.rect, boundingRect);
            API.destroy();
          }, 100);
        }
      },
      onDrag: function onDrag(e, _ref3) {
        var dx = _ref3.dx,
            dy = _ref3.dy;

        e.preventDefault();

        if (!state.activated) return;

        if (!state.box) {
          var rect = {
            x: state.startPos.x,
            y: state.startPos.y,
            width: dx,
            height: dy
          };
          state.rect = rect;
          state.box = new _common_box__WEBPACK_IMPORTED_MODULE_1__["Box"](_extends({}, rect, {
            onStateChange: function onStateChange(_ref4) {
              var rect = _ref4.rect;

              state.rect = rect;
              API.show();
              API.updatePos(rect);
            }
          }));

          state.box.moveAnchorStart({
            anchorPos: _common_box__WEBPACK_IMPORTED_MODULE_1__["BOX_ANCHOR_POS"].BOTTOM_RIGHT
          });
        }

        state.box.moveAnchor({
          x: e.pageX,
          y: e.pageY
        });
      }
    });

    var rectObj = createRect({
      top: -999,
      left: -999,
      width: 0,
      height: 0,
      rectStyle: {
        border: '1px solid #ff00ff',
        background: 'rgba(0, 0, 255, 0.1)'
      }
    });
    var API = {
      updatePos: function updatePos(rect) {
        Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["setStyle"])(rectObj.$container, {
          top: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(rect.y),
          left: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(rect.x),
          width: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(rect.width),
          height: Object(_common_dom_utils__WEBPACK_IMPORTED_MODULE_0__["pixel"])(rect.height)
        });
      },
      destroy: function destroy() {
        resetBodyStyle();
        unbindDrag();
        removeOverlay();
        rectObj.destroy();

        setTimeout(function () {
          document.removeEventListener('click', onClick, true);
          document.removeEventListener('keydown', onKeyDown, true);
        }, 0);
      },
      hide: function hide() {
        rectObj.hide();
      },
      show: function show() {
        rectObj.show();
      }
    };

    var onClick = function onClick(e) {
      console.log('trigger select_area onclick');
      e.preventDefault();
      e.stopPropagation();
      API.destroy();
    };
    var onKeyDown = function onKeyDown(e) {
      return e.keyCode === 27 && API.destroy();
    };

    document.addEventListener('click', onClick, true);
    document.addEventListener('keydown', onKeyDown, true);

    API.hide();
    return API;
  };

  if (!promise) return go(done);

  return new Promise(function (resolve, reject) {
    var wrappedDone = function wrappedDone() {
      resolve(done.apply(undefined, arguments));
    };

    go(wrappedDone);
  });
};

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Flcy1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWFrZS1oYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1lbGVtZW50LWlzLW5hdGl2ZWx5LWVkaXRhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLWJhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lkYi5maWxlc3lzdGVtLmpzL3NyYy9pZGIuZmlsZXN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2QtZ2xvYi10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvbGliL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvbGliL2RlZmF1bHQtZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvcHJlY29uZGl0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvbGliL3N5bmMtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ib3guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9jYXB0dXJlX3NjcmVlbnNob3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9jb21tYW5kX3J1bm5lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NvbnN0YW50LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vZG9tX3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vZHJhZ19tb2NrL0RhdGFUcmFuc2Zlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2RyYWdfbW9jay9EcmFnRHJvcEFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2RyYWdfbW9jay9ldmVudEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9kcmFnX21vY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9lbmNyeXB0LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vZmlsZV9tYW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9maWxlc3lzdGVtLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vaW5zcGVjdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vaXBjL2NzX3Bvc3RtZXNzYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vaXBjL2lwY19iZ19jcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2lwYy9pcGNfY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pcGMvaXBjX2NzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vaXBjL2lwY19wcm9taXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vbGliL2tleXNpbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3NjcmVlbnNob3RfbWFuLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vc2VuZF9rZXlzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vc3RvcmFnZS9leHRfc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3N0b3JhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3dlYl9leHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dC9jb250ZW50X3NjcmlwdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0L2NvbnRlbnRfc2NyaXB0L3NlbGVjdF9hcmVhLmpzIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKSJdLCJuYW1lcyI6WyJCT1hfQU5DSE9SX1BPUyIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJmaXRTcXVhcmVQb2ludCIsIm1vdmluZ1BvaW50IiwiZml4ZWRQb2ludCIsIm1wIiwiZnAiLCJ4bGVuIiwiTWF0aCIsImFicyIsIngiLCJ5bGVuIiwieSIsImxlbiIsIm1pbiIsInNpZ24iLCJjYWxjUmVjdEFuZEFuY2hvciIsInBvcyIsInRscCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImFuY2hvclBvcyIsInBvaW50QXRQb3MiLCJkaWFnb25hbFBvcyIsImRpYWdvbmFsUG9pbnQiLCJnZW5HZXRBbmNob3JSZWN0cyIsIkFOQ0hPUl9QT1MiLCJzaXplIiwidmFsdWVzIiwib2JqIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsImNyZWF0ZVJlY3QiLCJwb2ludCIsImdldEFuY2hvclJlY3RzIiwiQm94Iiwib3B0aW9ucyIsInN0YXRlIiwidHlwZSIsImRhdGEiLCJzdHlsZSIsImxvY2FsIiwib3B0cyIsImZpcnN0U2lsZW5jZSIsInRyYW5zZm9ybSIsIm9uU3RhdGVDaGFuZ2UiLCJub3JtYWxpemVSZWN0IiwiX19zZXRTdGF0ZSIsImlkIiwiZ2V0VHlwZSIsImdldERlZmF1bHRTdHlsZSIsImNhdGVnb3J5IiwiZ2V0Q2F0ZWdvcnkiLCJzaWxlbnQiLCJwcm9jZXNzSW5jb21pbmdTdHlsZSIsIl9fc2V0TG9jYWwiLCJvbGRQb2ludCIsIm9sZEFuY2hvclBvcyIsImZpdCIsIm9sZCIsImZpeGVkIiwibW92aW5nIiwicmVzIiwib2xkUmVjdCIsImR4IiwiZHkiLCJ1cGQiLCJsYXN0IiwiZ2V0U3RhdGUiLCJmbiIsImludm9rZSIsIm5leHRUaWNrIiwic2V0VGltZW91dCIsInNldHRpbmdzIiwiZGVmYXVsdEFuY2hvclBvcyIsImdldEFjdGl2ZVRhYkluZm8iLCJFeHQiLCJ3aW5kb3dzIiwiZ2V0TGFzdEZvY3VzZWQiLCJ0aGVuIiwidGFicyIsInF1ZXJ5IiwiYWN0aXZlIiwid2luZG93SWQiLCJ3aW4iLCJpbWFnZVNpemVGcm9tRGF0YVVSSSIsImRhdGFVUkkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwib25sb2FkIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsInNyYyIsImdldFNjcmVlbnNob3RSYXRpbyIsInRhYklkIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImFsbCIsImdldCIsInR1cGxlIiwidGFiIiwic2NhbGVEYXRhVVJJIiwic2NhbGUiLCJjYW52YXMiLCJjcmVhdGVDYW52YXMiLCJkcmF3T25DYW52YXMiLCJ0b0RhdGFVUkwiLCJjYXB0dXJlU2NyZWVuIiwicHJlc2V0U2NyZWVuc2hvdFJhdGlvIiwiaXMybmRBcmdGdW5jdGlvbiIsImhhc1NjcmVlbnNob3RSYXRpbyIsInBEYXRhVVJJIiwiY2FwdHVyZVZpc2libGVUYWIiLCJmb3JtYXQiLCJwUmF0aW8iLCJ3aW5kb3ciLCJzY3JlZW5zaG90UmF0aW8iLCJjcmVhdGVDYXB0dXJlU2NyZWVuV2l0aENhY2hlZFNjcmVlbnNob3RSYXRpbyIsInJhdGlvIiwiY2FwdHVyZVNjcmVlbkJsb2IiLCJkYXRhVVJJdG9CbG9iIiwic2F2ZVNjcmVlbiIsImZpbGVOYW1lIiwiZ2V0U2NyZWVuc2hvdE1hbiIsIm92ZXJ3cml0ZSIsInNjcmVlbkJsb2IiLCJ1cmwiLCJwQ29tcG9zZSIsImxpc3QiLCJyZWR1Y2UiLCJwcmV2IiwiZ2V0QWxsU2Nyb2xsT2Zmc2V0cyIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJ3aW5kb3dXaWR0aCIsIndpbmRvd0hlaWdodCIsInRvcFBhZGRpbmciLCJ0b3BQYWQiLCJ4U3RlcCIsInlTdGVwIiwicmVzdWx0IiwicHVzaCIsImdldEFsbFNjcm9sbE9mZnNldHNGb3JSZWN0Iiwib3JpZ2luYWxYIiwib3JpZ2luYWxZIiwic3kiLCJzeCIsImxlbmd0aCIsInBpeGVsUmF0aW8iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWFnZSIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ3aXRoUGFnZUluZm8iLCJzdGFydENhcHR1cmUiLCJlbmRDYXB0dXJlIiwiY2FsbGJhY2siLCJwYWdlSW5mbyIsInNlbmRlciIsImNhcHR1cmVGdWxsU2NyZWVuIiwiY2FwdHVyZUNsaWVudEFQSSIsInNjcm9sbFBhZ2UiLCJibG9iIiwibWF4U2lkZSIsImZsb29yIiwic2Nyb2xsT2Zmc2V0cyIsInRvZG9zIiwib2Zmc2V0IiwiaSIsImluZGV4IiwidG90YWwiLCJyZWFsT2Zmc2V0IiwiY29udmVydCIsImNhcHR1cmVTY3JlZW5JblNlbGVjdGlvblNpbXBsZSIsImNhcHR1cmVTY3JlZW5JblNlbGVjdGlvbiIsImdldFBhZ2VJbmZvIiwiYm9keSIsIndpZHRocyIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsImhlaWdodHMiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJtYXgiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJoYXNCb2R5Iiwic2Nyb2xsWCIsInNjcm9sbFkiLCJvcmlnaW5hbE92ZXJmbG93U3R5bGUiLCJvdmVyZmxvdyIsIm9yaWdpbmFsQm9keU92ZXJmbG93WVN0eWxlIiwib3ZlcmZsb3dZIiwiaGlkZVNjcm9sbGJhciIsInNjcm9sbFRvIiwiZGVsYXkiLCJzYXZlRnVsbFNjcmVlbiIsImNsaWVudEFQSSIsIkhJR0hMSUdIVF9USU1FT1VUIiwiZ2xvYk1hdGNoIiwicGF0dGVybiIsInRleHQiLCJnbG9iMnJlZyIsInRlc3QiLCJnZXRFbGVtZW50QnlYUGF0aCIsInhwYXRoIiwic25hcHNob3QiLCJldmFsdWF0ZSIsIlhQYXRoUmVzdWx0IiwiT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUiLCJzbmFwc2hvdEl0ZW0iLCJ2aWV3cG9ydE9mZnNldCIsImVsIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwibGVmdCIsInVudGlsSW5qZWN0ZWQiLCJhcGkiLCJldmFsIiwiY29kZSIsImxvZyIsInBvc3RNZXNzYWdlIiwiY21kIiwiYXJncyIsImluamVjdGVkIiwiZ2V0QXR0cmlidXRlIiwiaW5zZXJ0U2NyaXB0IiwiZXh0ZW5zaW9uIiwiZ2V0VVJMIiwicmV0cnkiLCJzaG91bGRSZXRyeSIsInRpbWVvdXQiLCJyZXRyeUludGVydmFsIiwiY2F0Y2giLCJlIiwic3RhY2siLCJFcnJvciIsImlzRWxlbWVudEZyb21Qb2ludCIsInN0ciIsInRyaW0iLCJwYWdlQ29vcmRpbmF0ZUJ5RWxlbWVudEZyb21Qb2ludCIsInJlZyIsIm0iLCJtYXRjaCIsInBhZ2VYIiwicGFyc2VGbG9hdCIsInBhZ2VZIiwidmlld3BvcnRDb29yZGluYXRlQnlFbGVtZW50RnJvbVBvaW50Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImVsZW1lbnRCeUVsZW1lbnRGcm9tUG9pbnQiLCJlbGVtZW50RnJvbVBvaW50IiwiZ2V0RWxlbWVudEJ5TG9jYXRvciIsInNob3VsZFdhaXRGb3JWaXNpYmxlIiwiaW5kZXhPZiIsIm1ldGhvZCIsInN1YnN0ciIsInZhbHVlIiwidG9Mb3dlckNhc2UiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwibGlua3MiLCJzbGljZSIsImNhbGwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInJlYWxWYWwiLCJyZXBsYWNlIiwicGFyc2VJbnQiLCJjYW5kaWRhdGVzIiwiZmlsdGVyIiwiZG9tVGV4dCIsImEiLCJxdWVyeVNlbGVjdG9yIiwiaXNWaXNpYmxlIiwiZ2V0RnJhbWVCeUxvY2F0b3IiLCJoZWxwZXJzIiwiZnJhbWVzIiwiZnJhbWUiLCJwYXJlbnQiLCJmcmFtZURvbSIsImNvbnRlbnRXaW5kb3ciLCJmaWxlIiwiZG9jIiwiY29udGVudERvY3VtZW50IiwicyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJoYWNrQWxlcnRDb25maXJtUHJvbXB0IiwicnVuIiwiY29tbWFuZCIsImNzSXBjIiwidGFyZ2V0IiwiZXh0cmEiLCJ3cmFwIiwiZ2VuT3B0aW9ucyIsImVycm9yTXNnIiwibWVzc2FnZSIsImdldEVsZW1lbnRCeUxvY2F0b3JXaXRoTG9nRm9yRWZwIiwibG9jYXRvciIsImVsWHBhdGgiLCJtc2ciLCJjb25zb2xlIiwiYXNrIiwiaW5mbyIsIl9fZ2V0RnJhbWVCeUxvY2F0b3IiLCJfX2dldEVsZW1lbnRCeUxvY2F0b3IiLCJub0NvbW1hbmRzWWV0IiwidW50aWwiLCJwYXNzIiwibG9jYXRpb24iLCJocmVmIiwicmVsb2FkIiwicGxheVNjcm9sbEVsZW1lbnRzSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwicGxheUhpZ2hsaWdodEVsZW1lbnRzIiwiaGlnaGxpZ2h0RG9tIiwiZXJyb3IiLCJkaXNwYXRjaEV2ZW50IiwiTW91c2VFdmVudCIsImJ1YmJsZXMiLCIkc3JjIiwiJHRndCIsImRyYWdNb2NrIiwidHJpZ2dlckRyYWdFdmVudCIsImdldElmcmFtZU9mZnNldCIsImFjdGlvbiIsImlzRWZwIiwicFRhcmdldCIsImlmcmFtZU9mZnNldCIsIndhaXRGb3JWaXNpYmxlIiwic2Nyb2xsQW5kSGlnaGxpZ2h0Iiwic3BsaXQiLCJvcmlnQ2xpZW50WCIsIm9yaWdDbGllbnRZIiwibGFzdFNjcm9sbFgiLCJsYXN0U2Nyb2xsWSIsImNsaWVudFgiLCJjbGllbnRZIiwiZm9yRWFjaCIsImV2ZW50VHlwZSIsInZpZXciLCJjYW5jZWxhYmxlIiwiY2xpY2siLCJvcHRpb25UeXBlIiwic3Vic3RyaW5nIiwib3B0aW9uVmFsdWUiLCJvcHRpb24iLCJmaW5kIiwib3AiLCJfIiwiRXZlbnQiLCJ0YWciLCJ0YWdOYW1lIiwiaXNGaXJlZm94IiwiZmlsZXMiLCJzZWxlY3RvciIsImNzc1NlbGVjdG9yIiwiZGVjcnlwdElmTmVlZGVkIiwic2VuZEtleXMiLCJyZWFsVmFsdWUiLCJjb250ZW50RWRpdGFibGUiLCJpbm5lckhUTUwiLCJmcmFtZVdpbmRvdyIsInRpdGxlIiwidGltZW91dEVsZW1lbnQiLCJyZXRyeUluZm8iLCJzaG90c0xlZnQiLCJyZXRyeUNvdW50IiwiaXNMYXN0Q2hhbmNlIiwiY2hlY2tlZCIsImxhc3RJbmRleE9mIiwiYXR0ck5hbWUiLCJhdHRyIiwibGFzdENvbW1hbmRPayIsInZhcnMiLCJwIiwidG9VcHBlckNhc2UiLCJnZXRNYXRjaEFuZENhcHR1cmVJbmRleCIsIm5vblplcm9JbmRleCIsIm4iLCJ1bmRlZmluZWQiLCJleGVjIiwicmVzdCIsIm1hdGNoSW5kZXgiLCJjYXB0dXJlSW5kZXgiLCJyZWdleHAiLCJyYXciLCJyZWdleHBUZXh0IiwidG9SZWdFeHAiLCJuZWVkRW5jb2RlIiwiZmxhZyIsInJlZ2V4cEZvclRleHQiLCJjYXB0dXJlIiwiZmxhZ3MiLCJtYXRjaGVzIiwiaHRtbCIsIm91dGVySFRNTCIsImd1YXJkIiwiY2xpZW50UmVjdCIsInBTb3VyY2VPZmZzZXQiLCJzb3VyY2VPZmZzZXQiLCJlbnN1cmVFeHROYW1lIiwiTEFTVF9TQ1JFRU5TSE9UX0ZJTEVfTkFNRSIsInNjcmVlbnNob3QiLCJuYW1lIiwid2FpdCIsInRpbWVvdXREb3dubG9hZCIsInRpbWVvdXRGb3JTdGFydCIsIm9yaWdpbiIsImNvbmRpdGlvbiIsIm1rIiwiQVBQX1NUQVRVUyIsIklOU1BFQ1RPUl9TVEFUVVMiLCJSRUNPUkRFUl9TVEFUVVMiLCJQTEFZRVJfU1RBVFVTIiwiUExBWUVSX01PREUiLCJDT05URU5UX1NDUklQVF9TVEFUVVMiLCJURVNUX0NBU0VfU1RBVFVTIiwiZ2V0U3R5bGUiLCJkb20iLCJnZXRDb21wdXRlZFN0eWxlIiwic2V0U3R5bGUiLCJwaXhlbCIsIm51bSIsImJpbmREcmFnIiwib25EcmFnU3RhcnQiLCJvbkRyYWdFbmQiLCJvbkRyYWciLCIkZWwiLCJpc0RyYWdnaW5nIiwic3RhcnRQb3MiLCJvbk1vdXNlRG93biIsInNjcmVlblgiLCJzY3JlZW5ZIiwib25Nb3VzZVVwIiwib25Nb3VzZU1vdmUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9uQ2xpY2siLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJpbmRDb250ZW50RWRpdGFibGVDaGFuZ2UiLCJvbkNoYW5nZSIsImN1cnJlbnRDRSIsIm9sZENvbnRlbnQiLCJvbkZvY3VzIiwib25CbHVyIiwiJGRvbSIsIml0IiwiaW5uZXJUZXh0IiwidGMiLCJ0ZXh0Q29udGVudCIsImRpc3BsYXkiLCJvcGFjaXR5IiwidmlzaWJpbGl0eSIsIm5vZGVUeXBlIiwiY2xhc3NlcyIsImNsYXNzTmFtZSIsIml0ZW0iLCJjaGlsZHJlbiIsIkFycmF5IiwiZnJvbSIsImNoaWxkTm9kZXMiLCJzYW1lVGFnIiwic2FtZUNsYXNzIiwiY3MiLCJhbmQiLCJjIiwiam9pbiIsImZpbmRJbmRleCIsIm1lIiwicmV0IiwiaXNQb3NpdGlvbkZpeGVkIiwicmVtb3ZlRnJvbUFycmF5IiwiYXJyYXkiLCJzcGxpY2UiLCJEYXRhVHJhbnNmZXIiLCJkYXRhQnlGb3JtYXQiLCJkcm9wRWZmZWN0IiwiZWZmZWN0QWxsb3dlZCIsInR5cGVzIiwiY2xlYXJEYXRhIiwiZGF0YUZvcm1hdCIsImdldERhdGEiLCJzZXREYXRhIiwic2V0RHJhZ0ltYWdlIiwibW9kdWxlIiwiZXhwb3J0cyIsInRtcCIsImV2ZW50RmFjdG9yeSIsInJlcXVpcmUiLCJfbm9vcCIsInBhcnNlUGFyYW1zIiwidGFyZ2V0RWxlbWVudCIsImV2ZW50UHJvcGVydGllcyIsImNvbmZpZ0NhbGxiYWNrIiwiY3VzdG9taXplRXZlbnQiLCJldmVudCIsImlzUHJpbWFyeUV2ZW50IiwiY3JlYXRlQW5kRGlzcGF0Y2hFdmVudHMiLCJldmVudE5hbWVzIiwicHJpbWFyeUV2ZW50TmFtZSIsImRhdGFUcmFuc2ZlciIsImV2ZW50TmFtZSIsImNyZWF0ZUV2ZW50IiwiRHJhZ0Ryb3BBY3Rpb24iLCJsYXN0RHJhZ1NvdXJjZSIsImxhc3REYXRhVHJhbnNmZXIiLCJwZW5kaW5nQWN0aW9uc1F1ZXVlIiwiX3F1ZXVlIiwiX3F1ZXVlRXhlY3V0ZU5leHQiLCJzZWxmIiwiZmlyc3RQZW5kaW5nQWN0aW9uIiwiZG9uZUNhbGxiYWNrIiwic2hpZnQiLCJkcmFnU3RhcnQiLCJwYXJhbXMiLCJldmVudHMiLCJkcmFnRW50ZXIiLCJvdmVyRWxlbWVudCIsImRyYWdPdmVyIiwiZHJhZ0xlYXZlIiwiZHJvcCIsImV2ZW50c09uRHJvcFRhcmdldCIsImV2ZW50c09uRHJhZ1NvdXJjZSIsIndhaXRpbmdUaW1lTXMiLCJkb25lIiwiZGF0YVRyYW5zZmVyRXZlbnRzIiwibWVyZ2VJbnRvIiwiZGVzdE9iaiIsInNyY09iaiIsImhhc093blByb3BlcnR5IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY3JlYXRlTW9kZXJuRXZlbnQiLCJjcmVhdGVMZWdhY3lFdmVudCIsImluaXRFdmVudCIsImluaXRDdXN0b21FdmVudCIsIkV2ZW50RmFjdG9yeSIsImluc3RhbmNlIiwibWV0aG9kTmFtZSIsImFwcGx5IiwiZWxlbWVudCIsImdldFhwYXRoT2ZFbGVtZW50IiwicGFyZW50RWxlbWVudCIsInNpYmxpbmdFbGVtZW50IiwidGFnQ291bnQiLCJ0b3RhbFRhZ0NvdW50IiwiaXNGb3VuZCIsInNjcmlwdCIsInNjcmlwdFRhZyIsImFyZ3VtZW50cyIsIlJBV19QUkVGSVgiLCJDSVBIRVJfUFJFRklYIiwiUkFXX1BSRUZJWF9SRUciLCJSZWdFeHAiLCJDSVBIRVJfUFJFRklYX1JFRyIsImdldEVuY3J5cHRDb25maWciLCJzdG9yYWdlIiwic2hvdWxkRW5jcnlwdCIsImNvbmZpZyIsInNob3VsZEVuY3J5cHRQYXNzd29yZCIsIm1hc3RlclBhc3N3b3JkIiwiYWVzRW5jcnlwdCIsInBhc3N3b3JkIiwicGJrZGYyIiwicGJrZGYyU3luYyIsImVuZ2luZSIsImFlc2pzIiwiTW9kZU9mT3BlcmF0aW9uIiwiY3RyIiwidXRpbHMiLCJoZXgiLCJmcm9tQnl0ZXMiLCJlbmNyeXB0IiwidXRmOCIsInRvQnl0ZXMiLCJhZXNEZWNyeXB0IiwiZGVjcnlwdCIsImVuY3J5cHRJZk5lZWRlZCIsInJlYWRhYmxlU2l6ZSIsImtiIiwibWIiLCJ0b0ZpeGVkIiwiRmlsZU1hbiIsImJhc2VEaXIiLCJmcyIsImdldERpcmVjdG9yeSIsIndpdGhGaWxlRXh0ZW5zaW9uIiwiYmFzZU5hbWUiLCJ2YWxpZGF0ZVN0YW5kYXJkTmFtZSIsIl9fZmlsZVBhdGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwcyIsImZpbGVFbnRyaWVzIiwiZ2V0TWV0YWRhdGEiLCJmaWxlRW50cnkiLCJkaXIiLCJtZXRhIiwibGFzdE1vZGlmaWVkIiwibW9kaWZpY2F0aW9uVGltZSIsImV4aXN0cyIsInJlYWRGaWxlIiwid3JpdGVGaWxlIiwiQmxvYiIsInJlbW92ZSIsIndyaXRlIiwicmVtb3ZlRmlsZSIsIm5ld05hbWUiLCJtb3ZlRmlsZSIsImZvcmNlQ2hlY2siLCJjaGVja0ZpbGVOYW1lIiwicmVxdWVzdEZpbGVTeXN0ZW0iLCJ3ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSIsImR1bWJTaXplIiwibWF4U2l6ZSIsImdldEZTIiwiVEVNUE9SQVJZIiwic2hvdWxkQ3JlYXRlIiwicGFydHMiLCJpc0FycmF5IiwiZ2V0RGlyIiwiZGlyZWN0b3J5RW50cnkiLCJjcmVhdGUiLCJkaXJFbnRyeSIsImVudHJ5IiwicEZTIiwicm9vdCIsImRpclJlYWRlciIsImNyZWF0ZVJlYWRlciIsInJlYWQiLCJyZWFkRW50cmllcyIsImVudHJpZXMiLCJzb3J0IiwiY29uY2F0IiwiZmlsZUxvY2F0b3IiLCJmaWxlUGF0aCIsImdldEZpbGUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25lcnJvciIsIm9ubG9hZGVuZCIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEFzQmluYXJ5U3RyaW5nIiwicmVhZEFzRGF0YVVSTCIsInJlYWRBc1RleHQiLCJjcmVhdGVXcml0ZXIiLCJmaWxlV3JpdGVyIiwib253cml0ZWVuZCIsInRvVVJMIiwic3JjUGF0aCIsInRhcmdldFBhdGgiLCJzcmNEaXJFbnRyeSIsInNyY0ZpbGVOYW1lIiwidGd0RGlyRW50cnkiLCJ0Z3RGaWxlTmFtZSIsIm1vdmVUbyIsImlzU29tZUVudHJ5IiwiZ2V0TWV0aG9kTmFtZSIsInBJc0ZpbGUiLCJwSXNEaXIiLCJpc0ZpbGUiLCJpc0RpciIsImV4dGVuZCIsImhlYWQiLCJjdXIiLCJmbGF0dGVuIiwic3VtIiwib3IiLCJ6aXBXaXRoIiwiSW5maW5pdHkiLCJpbnRlcnNlY3QiLCJ2YWwiLCJubyIsImRlZXBFcXVhbCIsImIiLCJzdHlsZU5hbWUiLCJjc3NTdW0iLCJpc0lubGluZSIsImdldENsaWVudFJlY3RzIiwibm9QeCIsInciLCJoIiwicmVtb3ZlQ2hpbGRyZW4iLCJwcmVkaWNhdGUiLCJwcmVkIiwiaW5Eb20iLCIkb3V0ZXIiLCJpbkRvbUxpc3QiLCJwYXJlbnRXaXRoVGFnIiwibG93ZXJUYWciLCJwYXJlbnRXaXRoQ2xhc3MiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImdldFRhZ0luZGV4Iiwibm9kZSIsImNvdW50IiwiaGVscGVyIiwicHJlZml4IiwiYXRYUGF0aCIsImxvd2VyIiwiZ2V0Rmlyc3RXb3JraW5nTG9jYXRvciIsImxvY2F0b3JzIiwiZ2V0TG9jYXRvciIsIndpdGhBbGxPcHRpb25zIiwiaXNMaW5rIiwiY2hvc2VuIiwidGFyZ2V0T3B0aW9ucyIsImNoZWNrSWZyYW1lIiwiaWZyYW1lV2luIiwiRGF0ZSIsInJhbmRvbSIsImdldEZyYW1lTG9jYXRvciIsImZyYW1lV2luIiwiZnJhbWVFbGVtZW50IiwibWFza0ZhY3RvcnkiLCJjYWNoZSIsInJvdW5kIiwidWlkIiwiZGVmYXVsdFN0eWxlIiwicG9zaXRpb24iLCJ6SW5kZXgiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJwb2ludGVyRXZlbnRzIiwiZ2VuTWFzayIsIm1hc2siLCJjbGVhciIsImdlbiIsInNob3dNYXNrT3ZlciIsIlRZUEUiLCJ0YXJnZXRXaW4iLCJteVdpbiIsInBheWxvYWQiLCJzZWNyZXQiLCJvbk1zZyIsImlzUmVxdWVzdCIsIm9uTWVzc2FnZSIsInRwbCIsInNvdXJjZSIsImVyciIsIlRJTUVPVVQiLCJvcGVuQmdXaXRoQ3MiLCJjdWlkIiwiaXBjQmciLCJiZ0xpc3RlbmVycyIsImFkZFNlbmRlciIsInJ1bnRpbWUiLCJhZGRMaXN0ZW5lciIsInJlcSIsInNlbmRSZXNwb25zZSIsImxpc3RlbmVyIiwiaXBjUHJvbWlzZSIsInNlbmRNZXNzYWdlIiwib25BbnN3ZXIiLCJyZXNwb25zZSIsIm9uQXNrIiwiYW5zd2VyIiwiZGVzdHJveSIsImlwY0NzIiwiY2hlY2tSZWFkeSIsImNzTGlzdGVuZXJzIiwiY3NJbml0IiwicmVjb25uZWN0Iiwid2l0aFRpbWVvdXQiLCJjb25uZWN0QmciLCJ0cnlDb25uZWN0IiwibW9ja0FQSVdpdGgiLCJiZ0luaXQiLCJnZXRJcGNDYWNoZSIsImdldEN1aWQiLCJlbmFibGUiLCJJcGNDYWNoZSIsImJlZm9yZSIsImlwY09iaiIsImVuYWJsZWQiLCJzdGF0dXMiLCJpcGMiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwidXBkYXRlVGltZXN0YW1wIiwiZm91bmQiLCJzZXRTdGF0dXMiLCJ0aHJvd05vdFRvcCIsInNlbmQiLCJUT19CRV9SRU1PVkVEIiwidHJhbnNmb3JtRXJyb3IiLCJpc0Vycm9yIiwidXNlckRlc3Ryb3kiLCJhc2tDYWNoZSIsInVuaGFuZGxlZEFzayIsIm1hcmtVbmhhbmRsZWQiLCJoYW5kbGVyIiwicnVuSGFuZGxlcnMiLCJoYW5kbGVycyIsIndyYXBBc2siLCJ0aW1lb3V0VG9PdmVycmlkZSIsImZpbmFsVGltZW91dCIsIndyYXBPbkFzayIsInRhc2siLCJ1aWRzIiwibm9SZWplY3QiLCJ3YWl0Rm9yUmVhZHkiLCJtYWtlU3VyZVJlYWR5Iiwic2VyaWFsaXplIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlIiwiQ1RSTCIsIk1FVEEiLCJBTFQiLCJTSElGVCIsIktleUV2ZW50cyIsIkRPV04iLCJQUkVTUyIsIlVQIiwiSU5QVVQiLCJBTEwiLCJLZXlzdHJva2UiLCJtb2RpZmllcnMiLCJrZXlDb2RlIiwiY3RybEtleSIsIm1ldGFLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsIktleWJvYXJkIiwiY2hhckNvZGVLZXlDb2RlTWFwIiwiYWN0aW9uS2V5Q29kZU1hcCIsIl9jaGFyQ29kZUtleUNvZGVNYXAiLCJfYWN0aW9uS2V5Q29kZU1hcCIsImtleXN0cm9rZSIsImNoYXJDb2RlIiwia2V5c3Ryb2tlRm9yQ2hhckNvZGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUZvcktleXN0cm9rZSIsIndoaWNoIiwia2V5c3Ryb2tlRm9yQWN0aW9uIiwiZGlzcGF0Y2hFdmVudHNGb3JLZXlzdHJva2UiLCJpbnB1dCIsImN1cnJlbnRNb2RpZmllclN0YXRlIiwiY2hhckNvZGVBdCIsImRpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uTW9kaWZpZXJzIiwia2V5ZG93bkV2ZW50IiwiY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlIiwidGFyZ2V0Q2FuUmVjZWl2ZVRleHRJbnB1dCIsImtleXByZXNzRXZlbnQiLCJ0ZXh0aW5wdXRFdmVudCIsImlucHV0RXZlbnQiLCJrZXl1cEV2ZW50IiwiZnJvbU1vZGlmaWVyU3RhdGUiLCJ0b01vZGlmaWVyU3RhdGUiLCJkaWRIYXZlTWV0YSIsIndpbGxIYXZlTWV0YSIsImRpZEhhdmVDdHJsIiwid2lsbEhhdmVDdHJsIiwiZGlkSGF2ZVNoaWZ0Iiwid2lsbEhhdmVTaGlmdCIsImRpZEhhdmVBbHQiLCJ3aWxsSGF2ZUFsdCIsImluY2x1ZGVLZXlVcCIsImluY2x1ZGVLZXlEb3duIiwibGFzdFBhcnQiLCJwb3AiLCJwYXJ0IiwibGFzdFBhcnRLZXlzdHJva2UiLCJpc0VkaXRhYmxlIiwiVVNfRU5HTElTSF9DSEFSQ09ERV9LRVlDT0RFX01BUCIsIlVTX0VOR0xJU0hfQUNUSU9OX0tFWUNPREVfTUFQIiwiQkFDS1NQQUNFIiwiVEFCIiwiRU5URVIiLCJQQVVTRSIsIkNBUFNMT0NLIiwiRVNDQVBFIiwiUEFHRVVQIiwiUEFHRURPV04iLCJFTkQiLCJIT01FIiwiTEVGVCIsIlJJR0hUIiwiSU5TRVJUIiwiREVMRVRFIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiVVNfRU5HTElTSCIsImxvZ0ZhY3RvcnkiLCJpc0VuYWJsZWQiLCJ0b0lTT1N0cmluZyIsImRpc2FibGUiLCJwcm9jZXNzIiwiU2NyZWVuc2hvdE1hbiIsIm1hbiIsImtleWJvYXJkIiwiS2V5c2ltIiwiZmluZFBhcmVudEJ5VGFnIiwic3BsaXRTdHJpbmdUb0NoYXJzIiwic3BlY2lhbEtleXMiLCJzcGxpdEtlZXAiLCJnZXRLZXlTdHJva2VBY3Rpb24iLCJlZGl0YWJsZVR5cGVzIiwibWF5YmVFZGl0VGV4dCIsImlzTmlsIiwic2VsZWN0aW9uU3RhcnQiLCJsYXN0U3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRTZWxlY3Rpb24iLCJtYXliZVN1Ym1pdEZvcm0iLCJmb3JtIiwic3VibWl0Iiwic3RhcnQiLCJlbmQiLCJyZXBsYWNlQWN0aW9uS2V5IiwibWFwcGluZyIsIm5vU3BlY2lhbEtleXMiLCJyYXdDaGFycyIsImNoYXJzIiwiZm9jdXMiLCJkaXNwYXRjaEV2ZW50c0ZvckFjdGlvbiIsInNldCIsIm9uQ2hhbmdlZCIsImNoYW5nZXMiLCJhcmVhTmFtZSIsIkV4dFN0b3JhZ2UiLCJjaGVjayIsImludGVydmFsIiwiZXhwaXJlIiwiZ28iLCJyYW5nZSIsInN0ZXAiLCJwYXJ0aWFsIiwiYXJiaXRhcnkiLCJjdXJBcmdzIiwibGVmdEFyZ0NudCIsInJlZHVjZVJpZ2h0IiwiaW5pdGlhbCIsImNvbXBvc2UiLCJvbiIsImRpY3QiLCJ1cGRhdGVJbiIsInVwZGF0ZXIiLCJzZXRJbiIsImdldEluIiwicGljayIsInRvU3RyaW5nIiwic3BsaXRJbnRvVHdvIiwiY24iLCJvYmpNYXAiLCJmb3JtYXREYXRlIiwiZCIsInBhZCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwic3RhcnRJbmRleCIsImxhc3RNYXRjaEluZGV4IiwibmFtZUZhY3RvcnkiLCJjb21wb3NlUHJvbWlzZUZuIiwicGFyc2VRdWVyeSIsImRlY29kZVVSSUNvbXBvbmVudCIsImNhbmNlbCIsImNsZWFyVGltZW91dCIsInRpbWVyIiwib25GaXJzdEZhaWwiLCJvbkZpbmFsIiwibGFzdEVycm9yIiwidGltZXJUb0NsZWFyIiwid3JhcHBlZE9uRmluYWwiLCJpbnRlcnZhbE1hbiIsImxhc3RJbnRlcnZhbCIsImludGVydmFsRmFjdG9yeSIsImdldExhc3RJbnRlcnZhbCIsImdldEludGVydmFsIiwib25FcnJvciIsImJ5dGVTdHJpbmciLCJhdG9iIiwibWltZVN0cmluZyIsImFiIiwiQXJyYXlCdWZmZXIiLCJpYSIsIlVpbnQ4QXJyYXkiLCJyYW5kb21OYW1lIiwicmFuZG9tQ2hhciIsIm9yaWdOYW1lIiwiZXh0TmFtZSIsInVuaXF1ZU5hbWUiLCJnZW5lcmF0ZSIsImdldEZ1bGxOYW1lIiwibG9hZENzdiIsImZldGNoIiwib2siLCJsb2FkSW1hZ2UiLCJleHQiLCJpc0ZpbGVOYW1lIiwic2FuaXRpemVGaWxlTmFtZSIsImdldFNjcmVlbkRwaSIsIkRFRkFVTFRfRFBJIiwibWF0Y2hEcGkiLCJkcGkiLCJtYXRjaE1lZGlhIiwiYnVja2V0U2l6ZSIsImsiLCJkcGlGcm9tRmlsZU5hbWUiLCJmYWN0b3J5IiwibW9jayIsInByb21pc2VGdW5jdGlvbktleXMiLCJyZWFsIiwiZXhwb3J0ZWQiLCJ3aXRoQ291bnREb3duIiwib25UaWNrIiwicGFzdCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImFkYXB0Q2hyb21lIiwiY2hyb21lIiwiYWRhcHQiLCJrZXlQYXJ0cyIsInN1YmtleSIsInRhciIsInByb21pc2lmeSIsImNvcHkiLCJ0b1Byb21pc2lmeSIsInRvQ29weSIsIlVzZWRBUEkiLCJjb29raWVzIiwibm90aWZpY2F0aW9ucyIsImJyb3dzZXJBY3Rpb24iLCJib29rbWFya3MiLCJkZWJ1Z2dlciIsImRvd25sb2FkcyIsImJyb3dzZXIiLCJNQVNLX0NMSUNLX0ZBREVfVElNRU9VVCIsIm9vcHMiLCJDIiwiTk9STUFMIiwicGxheWluZ0ZyYW1lIiwicmVjb3JkaW5nRnJhbWVTdGFjayIsInN1cGVyQ3NJcGMiLCJpcGNBY3Rpb24iLCJpcGNEYXRhIiwiY2FsY1NlbGVjdEZyYW1lQ21kcyIsImZyYW1lU3RhY2siLCJ4cyIsInlzIiwiaiIsImdldE1hc2siLCJhZGRMb2dvSW1nIiwiJGltZyIsImNyZWF0ZUxvZ29JbWciLCJpbnNwZWN0b3IiLCJtYXNrQ2xpY2siLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwibWFza0hvdmVyIiwiYWRkV2FpdEluQ29tbWFuZCIsImNtZE9iaiIsInJlcG9ydENvbW1hbmQiLCJMRUFWRV9JTlRFUlZBTCIsImxhc3RUaW1lIiwiaXNWYWxpZENsaWNrIiwiaXNWYWxpZFNlbGVjdCIsImlzVmFsaWRUeXBlIiwiY3JlYXRlSGlnaGxpZ2h0UmVjdCIsIiRtYXNrIiwiJHRleHQiLCJjb2xvciIsImZvbnRTaXplIiwic2NvcmUiLCJyZWN0U3R5bGUiLCJ0ZXh0U3R5bGUiLCJiZWhhdmlvciIsImhpZ2hsaWdodFJlY3QiLCJoaWdobGlnaHRSZWN0cyIsInRvcE1hdGNoZWRPcHRpb25zIiwiYm9yZGVyQ29sb3IiLCJyZWN0cyIsImRlc3Ryb3lGbnMiLCJ0YXJnZXRJbmZvIiwicmVjb3JkQ2xpY2tUeXBlIiwiJG9wdGlvbiIsIiRvcCIsIm9uQ29udGVudEVkaXRhYmxlQ2hhbmdlIiwib25EcmFnRHJvcCIsInZhbHVlT3B0aW9ucyIsIm9uTGVhdmUiLCJ1bmJpbmRDb250ZW50RWRpdGFibGVFdmVudHMiLCJiaW5kRXZlbnRzVG9SZWNvcmQiLCJ1bmJpbmRFdmVudHNUb1JlY29yZCIsIndhaXRGb3JEb21SZWFkeSIsImFjY3VyYXRlIiwicmVhZHlTdGF0ZSIsImJyb2FkY2FzdFRvQWxsRnJhbWVzIiwidXBkYXRlU3RhdHVzIiwiUkVDT1JESU5HIiwiUExBWUlORyIsInJlc3RvcmVBbGVydENvbmZpcm1Qcm9tcHQiLCJiaW5kSVBDTGlzdGVuZXIiLCJydW5Db21tYW5kIiwiaXNJRnJhbWUiLCJzY29yZWRSZWN0Iiwic2NvcmVkUmVjdHMiLCJsb2FkQ29uZmlnIiwic2VsZWN0QXJlYSIsInByb21pc2UiLCJib3VuZGluZ1JlY3QiLCJiaW5kRXZlbnRzVG9JbnNwZWN0IiwiSU5TUEVDVElORyIsImxvY2F0b3JJbmZvIiwiYmluZE9uTWVzc2FnZSIsIiRmcmFtZXMiLCIkZnJhbWVFbGVtZW50IiwiJGZyYW1lIiwicGFyZW50T2Zmc2V0IiwiYmluZEludm9rZUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJxdWVyaWVzIiwic2VhcmNoIiwidGVzdENhc2UiLCJkZXRhaWwiLCJhbGVydCIsImRpcmVjdCIsInByb3RvY29sIiwiYWdyZWUiLCJjb25maXJtIiwidGVzdFN1aXRlIiwiaW5pdCIsIm9uVXJsQ2hhbmdlIiwicGFnZVVybCIsIndyYXBSZXN1bHQiLCJfX3VuZGVmaW5lZF9fIiwibGFzdFVybCIsImNvbW1vblN0eWxlIiwiZm9udEZhbWlseSIsImNyZWF0ZUVsIiwiYXR0cnMiLCJjb250YWluZXJTdHlsZSIsInJlY3RCb3JkZXJXaWR0aCIsImN1cnNvciIsIiRjb250YWluZXIiLCIkcmVjdGFuZ2xlIiwiaGlkZSIsInNob3ciLCJjcmVhdGVPdmVybGF5IiwiJG92ZXJsYXkiLCJib3R0b20iLCJyaWdodCIsImFjdGl2YXRlZCIsInJlc2V0Qm9keVN0eWxlIiwidXNlclNlbGVjdEtleSIsIm9sZEN1cnNvciIsIm9sZFVzZXJTZWxlY3QiLCJyZW1vdmVPdmVybGF5IiwidW5iaW5kRHJhZyIsIm1vdmVBbmNob3JFbmQiLCJyZWN0T2JqIiwiQVBJIiwidXBkYXRlUG9zIiwibW92ZUFuY2hvclN0YXJ0IiwibW92ZUFuY2hvciIsIm9uS2V5RG93biIsIndyYXBwZWREb25lIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxjQUFjOztBQUV2RCx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFHQSw4Q0FBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdCWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDREQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RKQTtBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9iQSw4Q0FBWTtBQUNaLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFRO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixrQkFBa0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw2Q0FBNkM7QUFDN0MscUVBQXFFO0FBQ3JFLHVDQUF1QztBQUN2Qyx5REFBeUQ7O0FBRXpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsS0FBSztBQUNMLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkM7QUFDM0MscUVBQXFFO0FBQ3JFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxpRUFBaUU7O0FBRWpFOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsbUNBQW1DO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxRQUFROzs7Ozs7Ozs7Ozs7QUN0K0JUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0QkEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDLHNDQUFzQztBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxtQkFBTyxDQUFDLDJHQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwwRUFBMEU7O0FBRWhKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQSx3Q0FBd0MsMENBQTBDO0FBQ2xGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7O0FBRUEsaURBQWlEOztBQUVqRCx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7OztBQy8yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjs7QUFFdkM7QUFDQSxXQUFXLG1CQUFPLENBQUMsNkRBQWM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVU7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ25MQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywwRUFBc0I7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDhDQUFRO0FBQzdCOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDZEQUFjO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMseURBQWE7QUFDbEMsR0FBRyxhQUFhO0FBQ2hCLDBCQUEwQixtQkFBTyxDQUFDLCtDQUFRO0FBQzFDO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyw4Q0FBUTs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ25nQkEsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQThCOzs7Ozs7Ozs7Ozs7QUNBdkQ7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyx5REFBYSxFQUFFO0FBQ2xDLEdBQUc7QUFDSCxDQUFDO0FBQ0QsMkJBQTJCLG1CQUFPLENBQUMseUZBQTJCO0FBQzlEO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBMkI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMscUZBQXlCO0FBQ2xELG9CQUFvQixtQkFBTyxDQUFDLDJGQUE0QjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBOEI7Ozs7Ozs7Ozs7OztBQ1g1RCxpQkFBaUIsbUJBQU8sQ0FBQywyRkFBNEI7Ozs7Ozs7Ozs7OztBQ0FyRCxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBMkI7Ozs7Ozs7Ozs7Ozs7QUNBcEQsOENBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG9EQUFXOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxzREFBc0Q7QUFDdEQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3RELHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxvREFBb0Q7QUFDcEQscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxzREFBc0Q7QUFDdEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxzREFBc0Q7QUFDdEQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3RELHFEQUFxRDtBQUNyRCxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxzREFBc0Q7QUFDdEQscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxzREFBc0Q7QUFDdEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxzREFBc0Q7QUFDdEQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3RELHFEQUFxRDtBQUNyRCxvREFBb0Q7QUFDcEQscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHNEQUFzRDtBQUN0RCxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3RELG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2xTQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4Q0FBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pMRCxhQUFhLG1CQUFPLENBQUMsd0RBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsMkNBQU87QUFDN0IsZUFBZSxtQkFBTyxDQUFDLDZDQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLGlEQUFVO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLGlEQUFVO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLGlEQUFVO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLGlEQUFVOzs7Ozs7Ozs7Ozs7QUNkbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMzQixhQUFhLG1CQUFPLENBQUMsd0RBQWE7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLFFBQVEsUUFBUTs7QUFFaEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDZDQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBYTs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLFFBQVEsUUFBUTs7QUFFaEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxpREFBVTtBQUMvQixXQUFXLG1CQUFPLENBQUMsNkNBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHdEQUFhOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMzQixhQUFhLG1CQUFPLENBQUMsd0RBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLFFBQVEsUUFBUTs7QUFFaEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN0SUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxpREFBVTtBQUMvQixXQUFXLG1CQUFPLENBQUMsNkNBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHdEQUFhOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3hEQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDZDQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQywrQ0FBUTtBQUN6QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsK0VBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLCtFQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBMkI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUZBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLHFGQUFnQzs7QUFFN0Q7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsbUJBQU8sQ0FBQyxpRUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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LGdCQUFULENBQTBCLFNBQTFCLEVBQXFDNnRCLFNBQXJDLEVBQWdELElBQWhEOztBQUVBSixRQUFJZixJQUFKO0FBQ0EsV0FBT2UsR0FBUDtBQUNELEdBdklEOztBQXlJQSxNQUFJLENBQUNwRCxPQUFMLEVBQWMsT0FBT2hMLEdBQUc5WixJQUFILENBQVA7O0FBRWQsU0FBTyxJQUFJbmMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUN0QyxRQUFNd2tDLGNBQWMsU0FBZEEsV0FBYyxHQUFhO0FBQy9CemtDLGNBQVFrYyxnQ0FBUjtBQUNELEtBRkQ7O0FBSUE4WixPQUFHeU8sV0FBSDtBQUNELEdBTk0sQ0FBUDtBQU9ELENBbkpNLEM7Ozs7Ozs7Ozs7O0FDcEZQLGUiLCJmaWxlIjoiY29udGVudF9zY3JpcHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9leHQvY29udGVudF9zY3JpcHQvaW5kZXguanNcIik7XG4iLCIvKiEgTUlUIExpY2Vuc2UuIENvcHlyaWdodCAyMDE1LTIwMTggUmljaGFyZCBNb29yZSA8bWVAcmljbW9vLmNvbT4uIFNlZSBMSUNFTlNFLnR4dC4gKi9cbihmdW5jdGlvbihyb290KSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBjaGVja0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHBhcnNlSW50KHZhbHVlKSA9PT0gdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrSW50cyhhcnJheWlzaCkge1xuICAgICAgICBpZiAoIWNoZWNrSW50KGFycmF5aXNoLmxlbmd0aCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheWlzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjaGVja0ludChhcnJheWlzaFtpXSkgfHwgYXJyYXlpc2hbaV0gPCAwIHx8IGFycmF5aXNoW2ldID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29lcmNlQXJyYXkoYXJnLCBjb3B5KSB7XG5cbiAgICAgICAgLy8gQXJyYXlCdWZmZXIgdmlld1xuICAgICAgICBpZiAoYXJnLmJ1ZmZlciAmJiBhcmcubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSB7XG5cbiAgICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5zbGljZSkge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0J3MgYW4gYXJyYXk7IGNoZWNrIGl0IGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tJbnRzKGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWU6ICcgKyBhcmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aGluZyBlbHNlLCBidXQgYmVoYXZlcyBsaWtlIGFuIGFycmF5IChtYXliZSBhIEJ1ZmZlcj8gQXJndW1lbnRzPylcbiAgICAgICAgaWYgKGNoZWNrSW50KGFyZy5sZW5ndGgpICYmIGNoZWNrSW50cyhhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXJyYXktbGlrZSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZUFycmF5LCB0YXJnZXRBcnJheSwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ICE9IG51bGwgfHwgc291cmNlRW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VBcnJheS5zbGljZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gc291cmNlQXJyYXkuc2xpY2Uoc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyYXksIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSwgdGFyZ2V0U3RhcnQpO1xuICAgIH1cblxuXG5cbiAgICB2YXIgY29udmVydFV0ZjggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpID0gMDtcbiAgICAgICAgICAgIHRleHQgPSBlbmNvZGVVUkkodGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgJSBzaWduLCBlbmNvZGUgdGhlIGZvbGxvd2luZyAyIGJ5dGVzIGFzIGEgaGV4IHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHRleHQuc3Vic3RyKGksIDIpLCAxNikpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwganVzdCB0aGUgYWN0dWFsIGJ5dGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZUFycmF5KHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBieXRlc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTkxICYmIGMgPCAyMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFmKSA8PCA2KSB8IChieXRlc1tpICsgMV0gJiAweDNmKSkpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBmKSA8PCAxMikgfCAoKGJ5dGVzW2kgKyAxXSAmIDB4M2YpIDw8IDYpIHwgKGJ5dGVzW2kgKyAyXSAmIDB4M2YpKSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9CeXRlczogdG9CeXRlcyxcbiAgICAgICAgICAgIGZyb21CeXRlczogZnJvbUJ5dGVzLFxuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIHZhciBjb252ZXJ0SGV4ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiB0b0J5dGVzKHRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHRleHQuc3Vic3RyKGksIDIpLCAxNikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2l4dGkubmV0L2RldmVsb3BtZW50L2phdmFzY3JpcHQvMjAxMS8xMS8xMS9iYXNlNjQtZW5jb2RlZGVjb2RlLW9mLXV0ZjgtaW4tYnJvd3Nlci13aXRoLWpzLmh0bWxcbiAgICAgICAgdmFyIEhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICAgICAgICBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChIZXhbKHYgJiAweGYwKSA+PiA0XSArIEhleFt2ICYgMHgwZl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvQnl0ZXM6IHRvQnl0ZXMsXG4gICAgICAgICAgICBmcm9tQnl0ZXM6IGZyb21CeXRlcyxcbiAgICAgICAgfVxuICAgIH0pKCk7XG5cblxuICAgIC8vIE51bWJlciBvZiByb3VuZHMgYnkga2V5c2l6ZVxuICAgIHZhciBudW1iZXJPZlJvdW5kcyA9IHsxNjogMTAsIDI0OiAxMiwgMzI6IDE0fVxuXG4gICAgLy8gUm91bmQgY29uc3RhbnQgd29yZHNcbiAgICB2YXIgcmNvbiA9IFsweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2LCAweDZjLCAweGQ4LCAweGFiLCAweDRkLCAweDlhLCAweDJmLCAweDVlLCAweGJjLCAweDYzLCAweGM2LCAweDk3LCAweDM1LCAweDZhLCAweGQ0LCAweGIzLCAweDdkLCAweGZhLCAweGVmLCAweGM1LCAweDkxXTtcblxuICAgIC8vIFMtYm94IGFuZCBJbnZlcnNlIFMtYm94IChTIGlzIGZvciBTdWJzdGl0dXRpb24pXG4gICAgdmFyIFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG4gICAgdmFyIFNpID1bMHg1MiwgMHgwOSwgMHg2YSwgMHhkNSwgMHgzMCwgMHgzNiwgMHhhNSwgMHgzOCwgMHhiZiwgMHg0MCwgMHhhMywgMHg5ZSwgMHg4MSwgMHhmMywgMHhkNywgMHhmYiwgMHg3YywgMHhlMywgMHgzOSwgMHg4MiwgMHg5YiwgMHgyZiwgMHhmZiwgMHg4NywgMHgzNCwgMHg4ZSwgMHg0MywgMHg0NCwgMHhjNCwgMHhkZSwgMHhlOSwgMHhjYiwgMHg1NCwgMHg3YiwgMHg5NCwgMHgzMiwgMHhhNiwgMHhjMiwgMHgyMywgMHgzZCwgMHhlZSwgMHg0YywgMHg5NSwgMHgwYiwgMHg0MiwgMHhmYSwgMHhjMywgMHg0ZSwgMHgwOCwgMHgyZSwgMHhhMSwgMHg2NiwgMHgyOCwgMHhkOSwgMHgyNCwgMHhiMiwgMHg3NiwgMHg1YiwgMHhhMiwgMHg0OSwgMHg2ZCwgMHg4YiwgMHhkMSwgMHgyNSwgMHg3MiwgMHhmOCwgMHhmNiwgMHg2NCwgMHg4NiwgMHg2OCwgMHg5OCwgMHgxNiwgMHhkNCwgMHhhNCwgMHg1YywgMHhjYywgMHg1ZCwgMHg2NSwgMHhiNiwgMHg5MiwgMHg2YywgMHg3MCwgMHg0OCwgMHg1MCwgMHhmZCwgMHhlZCwgMHhiOSwgMHhkYSwgMHg1ZSwgMHgxNSwgMHg0NiwgMHg1NywgMHhhNywgMHg4ZCwgMHg5ZCwgMHg4NCwgMHg5MCwgMHhkOCwgMHhhYiwgMHgwMCwgMHg4YywgMHhiYywgMHhkMywgMHgwYSwgMHhmNywgMHhlNCwgMHg1OCwgMHgwNSwgMHhiOCwgMHhiMywgMHg0NSwgMHgwNiwgMHhkMCwgMHgyYywgMHgxZSwgMHg4ZiwgMHhjYSwgMHgzZiwgMHgwZiwgMHgwMiwgMHhjMSwgMHhhZiwgMHhiZCwgMHgwMywgMHgwMSwgMHgxMywgMHg4YSwgMHg2YiwgMHgzYSwgMHg5MSwgMHgxMSwgMHg0MSwgMHg0ZiwgMHg2NywgMHhkYywgMHhlYSwgMHg5NywgMHhmMiwgMHhjZiwgMHhjZSwgMHhmMCwgMHhiNCwgMHhlNiwgMHg3MywgMHg5NiwgMHhhYywgMHg3NCwgMHgyMiwgMHhlNywgMHhhZCwgMHgzNSwgMHg4NSwgMHhlMiwgMHhmOSwgMHgzNywgMHhlOCwgMHgxYywgMHg3NSwgMHhkZiwgMHg2ZSwgMHg0NywgMHhmMSwgMHgxYSwgMHg3MSwgMHgxZCwgMHgyOSwgMHhjNSwgMHg4OSwgMHg2ZiwgMHhiNywgMHg2MiwgMHgwZSwgMHhhYSwgMHgxOCwgMHhiZSwgMHgxYiwgMHhmYywgMHg1NiwgMHgzZSwgMHg0YiwgMHhjNiwgMHhkMiwgMHg3OSwgMHgyMCwgMHg5YSwgMHhkYiwgMHhjMCwgMHhmZSwgMHg3OCwgMHhjZCwgMHg1YSwgMHhmNCwgMHgxZiwgMHhkZCwgMHhhOCwgMHgzMywgMHg4OCwgMHgwNywgMHhjNywgMHgzMSwgMHhiMSwgMHgxMiwgMHgxMCwgMHg1OSwgMHgyNywgMHg4MCwgMHhlYywgMHg1ZiwgMHg2MCwgMHg1MSwgMHg3ZiwgMHhhOSwgMHgxOSwgMHhiNSwgMHg0YSwgMHgwZCwgMHgyZCwgMHhlNSwgMHg3YSwgMHg5ZiwgMHg5MywgMHhjOSwgMHg5YywgMHhlZiwgMHhhMCwgMHhlMCwgMHgzYiwgMHg0ZCwgMHhhZSwgMHgyYSwgMHhmNSwgMHhiMCwgMHhjOCwgMHhlYiwgMHhiYiwgMHgzYywgMHg4MywgMHg1MywgMHg5OSwgMHg2MSwgMHgxNywgMHgyYiwgMHgwNCwgMHg3ZSwgMHhiYSwgMHg3NywgMHhkNiwgMHgyNiwgMHhlMSwgMHg2OSwgMHgxNCwgMHg2MywgMHg1NSwgMHgyMSwgMHgwYywgMHg3ZF07XG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGVuY3J5cHRpb25cbiAgICB2YXIgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG4gICAgdmFyIFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xuICAgIHZhciBUMyA9IFsweDYzYTVjNjYzLCAweDdjODRmODdjLCAweDc3OTllZTc3LCAweDdiOGRmNjdiLCAweGYyMGRmZmYyLCAweDZiYmRkNjZiLCAweDZmYjFkZTZmLCAweGM1NTQ5MWM1LCAweDMwNTA2MDMwLCAweDAxMDMwMjAxLCAweDY3YTljZTY3LCAweDJiN2Q1NjJiLCAweGZlMTllN2ZlLCAweGQ3NjJiNWQ3LCAweGFiZTY0ZGFiLCAweDc2OWFlYzc2LCAweGNhNDU4ZmNhLCAweDgyOWQxZjgyLCAweGM5NDA4OWM5LCAweDdkODdmYTdkLCAweGZhMTVlZmZhLCAweDU5ZWJiMjU5LCAweDQ3Yzk4ZTQ3LCAweGYwMGJmYmYwLCAweGFkZWM0MWFkLCAweGQ0NjdiM2Q0LCAweGEyZmQ1ZmEyLCAweGFmZWE0NWFmLCAweDljYmYyMzljLCAweGE0Zjc1M2E0LCAweDcyOTZlNDcyLCAweGMwNWI5YmMwLCAweGI3YzI3NWI3LCAweGZkMWNlMWZkLCAweDkzYWUzZDkzLCAweDI2NmE0YzI2LCAweDM2NWE2YzM2LCAweDNmNDE3ZTNmLCAweGY3MDJmNWY3LCAweGNjNGY4M2NjLCAweDM0NWM2ODM0LCAweGE1ZjQ1MWE1LCAweGU1MzRkMWU1LCAweGYxMDhmOWYxLCAweDcxOTNlMjcxLCAweGQ4NzNhYmQ4LCAweDMxNTM2MjMxLCAweDE1M2YyYTE1LCAweDA0MGMwODA0LCAweGM3NTI5NWM3LCAweDIzNjU0NjIzLCAweGMzNWU5ZGMzLCAweDE4MjgzMDE4LCAweDk2YTEzNzk2LCAweDA1MGYwYTA1LCAweDlhYjUyZjlhLCAweDA3MDkwZTA3LCAweDEyMzYyNDEyLCAweDgwOWIxYjgwLCAweGUyM2RkZmUyLCAweGViMjZjZGViLCAweDI3Njk0ZTI3LCAweGIyY2Q3ZmIyLCAweDc1OWZlYTc1LCAweDA5MWIxMjA5LCAweDgzOWUxZDgzLCAweDJjNzQ1ODJjLCAweDFhMmUzNDFhLCAweDFiMmQzNjFiLCAweDZlYjJkYzZlLCAweDVhZWViNDVhLCAweGEwZmI1YmEwLCAweDUyZjZhNDUyLCAweDNiNGQ3NjNiLCAweGQ2NjFiN2Q2LCAweGIzY2U3ZGIzLCAweDI5N2I1MjI5LCAweGUzM2VkZGUzLCAweDJmNzE1ZTJmLCAweDg0OTcxMzg0LCAweDUzZjVhNjUzLCAweGQxNjhiOWQxLCAweDAwMDAwMDAwLCAweGVkMmNjMWVkLCAweDIwNjA0MDIwLCAweGZjMWZlM2ZjLCAweGIxYzg3OWIxLCAweDViZWRiNjViLCAweDZhYmVkNDZhLCAweGNiNDY4ZGNiLCAweGJlZDk2N2JlLCAweDM5NGI3MjM5LCAweDRhZGU5NDRhLCAweDRjZDQ5ODRjLCAweDU4ZThiMDU4LCAweGNmNGE4NWNmLCAweGQwNmJiYmQwLCAweGVmMmFjNWVmLCAweGFhZTU0ZmFhLCAweGZiMTZlZGZiLCAweDQzYzU4NjQzLCAweDRkZDc5YTRkLCAweDMzNTU2NjMzLCAweDg1OTQxMTg1LCAweDQ1Y2Y4YTQ1LCAweGY5MTBlOWY5LCAweDAyMDYwNDAyLCAweDdmODFmZTdmLCAweDUwZjBhMDUwLCAweDNjNDQ3ODNjLCAweDlmYmEyNTlmLCAweGE4ZTM0YmE4LCAweDUxZjNhMjUxLCAweGEzZmU1ZGEzLCAweDQwYzA4MDQwLCAweDhmOGEwNThmLCAweDkyYWQzZjkyLCAweDlkYmMyMTlkLCAweDM4NDg3MDM4LCAweGY1MDRmMWY1LCAweGJjZGY2M2JjLCAweGI2YzE3N2I2LCAweGRhNzVhZmRhLCAweDIxNjM0MjIxLCAweDEwMzAyMDEwLCAweGZmMWFlNWZmLCAweGYzMGVmZGYzLCAweGQyNmRiZmQyLCAweGNkNGM4MWNkLCAweDBjMTQxODBjLCAweDEzMzUyNjEzLCAweGVjMmZjM2VjLCAweDVmZTFiZTVmLCAweDk3YTIzNTk3LCAweDQ0Y2M4ODQ0LCAweDE3MzkyZTE3LCAweGM0NTc5M2M0LCAweGE3ZjI1NWE3LCAweDdlODJmYzdlLCAweDNkNDc3YTNkLCAweDY0YWNjODY0LCAweDVkZTdiYTVkLCAweDE5MmIzMjE5LCAweDczOTVlNjczLCAweDYwYTBjMDYwLCAweDgxOTgxOTgxLCAweDRmZDE5ZTRmLCAweGRjN2ZhM2RjLCAweDIyNjY0NDIyLCAweDJhN2U1NDJhLCAweDkwYWIzYjkwLCAweDg4ODMwYjg4LCAweDQ2Y2E4YzQ2LCAweGVlMjljN2VlLCAweGI4ZDM2YmI4LCAweDE0M2MyODE0LCAweGRlNzlhN2RlLCAweDVlZTJiYzVlLCAweDBiMWQxNjBiLCAweGRiNzZhZGRiLCAweGUwM2JkYmUwLCAweDMyNTY2NDMyLCAweDNhNGU3NDNhLCAweDBhMWUxNDBhLCAweDQ5ZGI5MjQ5LCAweDA2MGEwYzA2LCAweDI0NmM0ODI0LCAweDVjZTRiODVjLCAweGMyNWQ5ZmMyLCAweGQzNmViZGQzLCAweGFjZWY0M2FjLCAweDYyYTZjNDYyLCAweDkxYTgzOTkxLCAweDk1YTQzMTk1LCAweGU0MzdkM2U0LCAweDc5OGJmMjc5LCAweGU3MzJkNWU3LCAweGM4NDM4YmM4LCAweDM3NTk2ZTM3LCAweDZkYjdkYTZkLCAweDhkOGMwMThkLCAweGQ1NjRiMWQ1LCAweDRlZDI5YzRlLCAweGE5ZTA0OWE5LCAweDZjYjRkODZjLCAweDU2ZmFhYzU2LCAweGY0MDdmM2Y0LCAweGVhMjVjZmVhLCAweDY1YWZjYTY1LCAweDdhOGVmNDdhLCAweGFlZTk0N2FlLCAweDA4MTgxMDA4LCAweGJhZDU2ZmJhLCAweDc4ODhmMDc4LCAweDI1NmY0YTI1LCAweDJlNzI1YzJlLCAweDFjMjQzODFjLCAweGE2ZjE1N2E2LCAweGI0Yzc3M2I0LCAweGM2NTE5N2M2LCAweGU4MjNjYmU4LCAweGRkN2NhMWRkLCAweDc0OWNlODc0LCAweDFmMjEzZTFmLCAweDRiZGQ5NjRiLCAweGJkZGM2MWJkLCAweDhiODYwZDhiLCAweDhhODUwZjhhLCAweDcwOTBlMDcwLCAweDNlNDI3YzNlLCAweGI1YzQ3MWI1LCAweDY2YWFjYzY2LCAweDQ4ZDg5MDQ4LCAweDAzMDUwNjAzLCAweGY2MDFmN2Y2LCAweDBlMTIxYzBlLCAweDYxYTNjMjYxLCAweDM1NWY2YTM1LCAweDU3ZjlhZTU3LCAweGI5ZDA2OWI5LCAweDg2OTExNzg2LCAweGMxNTg5OWMxLCAweDFkMjczYTFkLCAweDllYjkyNzllLCAweGUxMzhkOWUxLCAweGY4MTNlYmY4LCAweDk4YjMyYjk4LCAweDExMzMyMjExLCAweDY5YmJkMjY5LCAweGQ5NzBhOWQ5LCAweDhlODkwNzhlLCAweDk0YTczMzk0LCAweDliYjYyZDliLCAweDFlMjIzYzFlLCAweDg3OTIxNTg3LCAweGU5MjBjOWU5LCAweGNlNDk4N2NlLCAweDU1ZmZhYTU1LCAweDI4Nzg1MDI4LCAweGRmN2FhNWRmLCAweDhjOGYwMzhjLCAweGExZjg1OWExLCAweDg5ODAwOTg5LCAweDBkMTcxYTBkLCAweGJmZGE2NWJmLCAweGU2MzFkN2U2LCAweDQyYzY4NDQyLCAweDY4YjhkMDY4LCAweDQxYzM4MjQxLCAweDk5YjAyOTk5LCAweDJkNzc1YTJkLCAweDBmMTExZTBmLCAweGIwY2I3YmIwLCAweDU0ZmNhODU0LCAweGJiZDY2ZGJiLCAweDE2M2EyYzE2XTtcbiAgICB2YXIgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb25cbiAgICB2YXIgVDUgPSBbMHg1MWY0YTc1MCwgMHg3ZTQxNjU1MywgMHgxYTE3YTRjMywgMHgzYTI3NWU5NiwgMHgzYmFiNmJjYiwgMHgxZjlkNDVmMSwgMHhhY2ZhNThhYiwgMHg0YmUzMDM5MywgMHgyMDMwZmE1NSwgMHhhZDc2NmRmNiwgMHg4OGNjNzY5MSwgMHhmNTAyNGMyNSwgMHg0ZmU1ZDdmYywgMHhjNTJhY2JkNywgMHgyNjM1NDQ4MCwgMHhiNTYyYTM4ZiwgMHhkZWIxNWE0OSwgMHgyNWJhMWI2NywgMHg0NWVhMGU5OCwgMHg1ZGZlYzBlMSwgMHhjMzJmNzUwMiwgMHg4MTRjZjAxMiwgMHg4ZDQ2OTdhMywgMHg2YmQzZjljNiwgMHgwMzhmNWZlNywgMHgxNTkyOWM5NSwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHhkNGJlODMyZCwgMHg1ODc0MjFkMywgMHg0OWUwNjkyOSwgMHg4ZWM5Yzg0NCwgMHg3NWMyODk2YSwgMHhmNDhlNzk3OCwgMHg5OTU4M2U2YiwgMHgyN2I5NzFkZCwgMHhiZWUxNGZiNiwgMHhmMDg4YWQxNywgMHhjOTIwYWM2NiwgMHg3ZGNlM2FiNCwgMHg2M2RmNGExOCwgMHhlNTFhMzE4MiwgMHg5NzUxMzM2MCwgMHg2MjUzN2Y0NSwgMHhiMTY0NzdlMCwgMHhiYjZiYWU4NCwgMHhmZTgxYTAxYywgMHhmOTA4MmI5NCwgMHg3MDQ4Njg1OCwgMHg4ZjQ1ZmQxOSwgMHg5NGRlNmM4NywgMHg1MjdiZjhiNywgMHhhYjczZDMyMywgMHg3MjRiMDJlMiwgMHhlMzFmOGY1NywgMHg2NjU1YWIyYSwgMHhiMmViMjgwNywgMHgyZmI1YzIwMywgMHg4NmM1N2I5YSwgMHhkMzM3MDhhNSwgMHgzMDI4ODdmMiwgMHgyM2JmYTViMiwgMHgwMjAzNmFiYSwgMHhlZDE2ODI1YywgMHg4YWNmMWMyYiwgMHhhNzc5YjQ5MiwgMHhmMzA3ZjJmMCwgMHg0ZTY5ZTJhMSwgMHg2NWRhZjRjZCwgMHgwNjA1YmVkNSwgMHhkMTM0NjIxZiwgMHhjNGE2ZmU4YSwgMHgzNDJlNTM5ZCwgMHhhMmYzNTVhMCwgMHgwNThhZTEzMiwgMHhhNGY2ZWI3NSwgMHgwYjgzZWMzOSwgMHg0MDYwZWZhYSwgMHg1ZTcxOWYwNiwgMHhiZDZlMTA1MSwgMHgzZTIxOGFmOSwgMHg5NmRkMDYzZCwgMHhkZDNlMDVhZSwgMHg0ZGU2YmQ0NiwgMHg5MTU0OGRiNSwgMHg3MWM0NWQwNSwgMHgwNDA2ZDQ2ZiwgMHg2MDUwMTVmZiwgMHgxOTk4ZmIyNCwgMHhkNmJkZTk5NywgMHg4OTQwNDNjYywgMHg2N2Q5OWU3NywgMHhiMGU4NDJiZCwgMHgwNzg5OGI4OCwgMHhlNzE5NWIzOCwgMHg3OWM4ZWVkYiwgMHhhMTdjMGE0NywgMHg3YzQyMGZlOSwgMHhmODg0MWVjOSwgMHgwMDAwMDAwMCwgMHgwOTgwODY4MywgMHgzMjJiZWQ0OCwgMHgxZTExNzBhYywgMHg2YzVhNzI0ZSwgMHhmZDBlZmZmYiwgMHgwZjg1Mzg1NiwgMHgzZGFlZDUxZSwgMHgzNjJkMzkyNywgMHgwYTBmZDk2NCwgMHg2ODVjYTYyMSwgMHg5YjViNTRkMSwgMHgyNDM2MmUzYSwgMHgwYzBhNjdiMSwgMHg5MzU3ZTcwZiwgMHhiNGVlOTZkMiwgMHgxYjliOTE5ZSwgMHg4MGMwYzU0ZiwgMHg2MWRjMjBhMiwgMHg1YTc3NGI2OSwgMHgxYzEyMWExNiwgMHhlMjkzYmEwYSwgMHhjMGEwMmFlNSwgMHgzYzIyZTA0MywgMHgxMjFiMTcxZCwgMHgwZTA5MGQwYiwgMHhmMjhiYzdhZCwgMHgyZGI2YThiOSwgMHgxNDFlYTljOCwgMHg1N2YxMTk4NSwgMHhhZjc1MDc0YywgMHhlZTk5ZGRiYiwgMHhhMzdmNjBmZCwgMHhmNzAxMjY5ZiwgMHg1YzcyZjViYywgMHg0NDY2M2JjNSwgMHg1YmZiN2UzNCwgMHg4YjQzMjk3NiwgMHhjYjIzYzZkYywgMHhiNmVkZmM2OCwgMHhiOGU0ZjE2MywgMHhkNzMxZGNjYSwgMHg0MjYzODUxMCwgMHgxMzk3MjI0MCwgMHg4NGM2MTEyMCwgMHg4NTRhMjQ3ZCwgMHhkMmJiM2RmOCwgMHhhZWY5MzIxMSwgMHhjNzI5YTE2ZCwgMHgxZDllMmY0YiwgMHhkY2IyMzBmMywgMHgwZDg2NTJlYywgMHg3N2MxZTNkMCwgMHgyYmIzMTY2YywgMHhhOTcwYjk5OSwgMHgxMTk0NDhmYSwgMHg0N2U5NjQyMiwgMHhhOGZjOGNjNCwgMHhhMGYwM2YxYSwgMHg1NjdkMmNkOCwgMHgyMjMzOTBlZiwgMHg4NzQ5NGVjNywgMHhkOTM4ZDFjMSwgMHg4Y2NhYTJmZSwgMHg5OGQ0MGIzNiwgMHhhNmY1ODFjZiwgMHhhNTdhZGUyOCwgMHhkYWI3OGUyNiwgMHgzZmFkYmZhNCwgMHgyYzNhOWRlNCwgMHg1MDc4OTIwZCwgMHg2YTVmY2M5YiwgMHg1NDdlNDY2MiwgMHhmNjhkMTNjMiwgMHg5MGQ4YjhlOCwgMHgyZTM5Zjc1ZSwgMHg4MmMzYWZmNSwgMHg5ZjVkODBiZSwgMHg2OWQwOTM3YywgMHg2ZmQ1MmRhOSwgMHhjZjI1MTJiMywgMHhjOGFjOTkzYiwgMHgxMDE4N2RhNywgMHhlODljNjM2ZSwgMHhkYjNiYmI3YiwgMHhjZDI2NzgwOSwgMHg2ZTU5MThmNCwgMHhlYzlhYjcwMSwgMHg4MzRmOWFhOCwgMHhlNjk1NmU2NSwgMHhhYWZmZTY3ZSwgMHgyMWJjY2YwOCwgMHhlZjE1ZThlNiwgMHhiYWU3OWJkOSwgMHg0YTZmMzZjZSwgMHhlYTlmMDlkNCwgMHgyOWIwN2NkNiwgMHgzMWE0YjJhZiwgMHgyYTNmMjMzMSwgMHhjNmE1OTQzMCwgMHgzNWEyNjZjMCwgMHg3NDRlYmMzNywgMHhmYzgyY2FhNiwgMHhlMDkwZDBiMCwgMHgzM2E3ZDgxNSwgMHhmMTA0OTg0YSwgMHg0MWVjZGFmNywgMHg3ZmNkNTAwZSwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg0M2VmYjA0ZCwgMHhjY2FhNGQ1NCwgMHhlNDk2MDRkZiwgMHg5ZWQxYjVlMywgMHg0YzZhODgxYiwgMHhjMTJjMWZiOCwgMHg0NjY1NTE3ZiwgMHg5ZDVlZWEwNCwgMHgwMThjMzU1ZCwgMHhmYTg3NzQ3MywgMHhmYjBiNDEyZSwgMHhiMzY3MWQ1YSwgMHg5MmRiZDI1MiwgMHhlOTEwNTYzMywgMHg2ZGQ2NDcxMywgMHg5YWQ3NjE4YywgMHgzN2ExMGM3YSwgMHg1OWY4MTQ4ZSwgMHhlYjEzM2M4OSwgMHhjZWE5MjdlZSwgMHhiNzYxYzkzNSwgMHhlMTFjZTVlZCwgMHg3YTQ3YjEzYywgMHg5Y2QyZGY1OSwgMHg1NWYyNzMzZiwgMHgxODE0Y2U3OSwgMHg3M2M3MzdiZiwgMHg1M2Y3Y2RlYSwgMHg1ZmZkYWE1YiwgMHhkZjNkNmYxNCwgMHg3ODQ0ZGI4NiwgMHhjYWFmZjM4MSwgMHhiOTY4YzQzZSwgMHgzODI0MzQyYywgMHhjMmEzNDA1ZiwgMHgxNjFkYzM3MiwgMHhiY2UyMjUwYywgMHgyODNjNDk4YiwgMHhmZjBkOTU0MSwgMHgzOWE4MDE3MSwgMHgwODBjYjNkZSwgMHhkOGI0ZTQ5YywgMHg2NDU2YzE5MCwgMHg3YmNiODQ2MSwgMHhkNTMyYjY3MCwgMHg0ODZjNWM3NCwgMHhkMGI4NTc0Ml07XG4gICAgdmFyIFQ2ID0gWzB4NTA1MWY0YTcsIDB4NTM3ZTQxNjUsIDB4YzMxYTE3YTQsIDB4OTYzYTI3NWUsIDB4Y2IzYmFiNmIsIDB4ZjExZjlkNDUsIDB4YWJhY2ZhNTgsIDB4OTM0YmUzMDMsIDB4NTUyMDMwZmEsIDB4ZjZhZDc2NmQsIDB4OTE4OGNjNzYsIDB4MjVmNTAyNGMsIDB4ZmM0ZmU1ZDcsIDB4ZDdjNTJhY2IsIDB4ODAyNjM1NDQsIDB4OGZiNTYyYTMsIDB4NDlkZWIxNWEsIDB4NjcyNWJhMWIsIDB4OTg0NWVhMGUsIDB4ZTE1ZGZlYzAsIDB4MDJjMzJmNzUsIDB4MTI4MTRjZjAsIDB4YTM4ZDQ2OTcsIDB4YzY2YmQzZjksIDB4ZTcwMzhmNWYsIDB4OTUxNTkyOWMsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4MmRkNGJlODMsIDB4ZDM1ODc0MjEsIDB4Mjk0OWUwNjksIDB4NDQ4ZWM5YzgsIDB4NmE3NWMyODksIDB4NzhmNDhlNzksIDB4NmI5OTU4M2UsIDB4ZGQyN2I5NzEsIDB4YjZiZWUxNGYsIDB4MTdmMDg4YWQsIDB4NjZjOTIwYWMsIDB4YjQ3ZGNlM2EsIDB4MTg2M2RmNGEsIDB4ODJlNTFhMzEsIDB4NjA5NzUxMzMsIDB4NDU2MjUzN2YsIDB4ZTBiMTY0NzcsIDB4ODRiYjZiYWUsIDB4MWNmZTgxYTAsIDB4OTRmOTA4MmIsIDB4NTg3MDQ4NjgsIDB4MTk4ZjQ1ZmQsIDB4ODc5NGRlNmMsIDB4Yjc1MjdiZjgsIDB4MjNhYjczZDMsIDB4ZTI3MjRiMDIsIDB4NTdlMzFmOGYsIDB4MmE2NjU1YWIsIDB4MDdiMmViMjgsIDB4MDMyZmI1YzIsIDB4OWE4NmM1N2IsIDB4YTVkMzM3MDgsIDB4ZjIzMDI4ODcsIDB4YjIyM2JmYTUsIDB4YmEwMjAzNmEsIDB4NWNlZDE2ODIsIDB4MmI4YWNmMWMsIDB4OTJhNzc5YjQsIDB4ZjBmMzA3ZjIsIDB4YTE0ZTY5ZTIsIDB4Y2Q2NWRhZjQsIDB4ZDUwNjA1YmUsIDB4MWZkMTM0NjIsIDB4OGFjNGE2ZmUsIDB4OWQzNDJlNTMsIDB4YTBhMmYzNTUsIDB4MzIwNThhZTEsIDB4NzVhNGY2ZWIsIDB4MzkwYjgzZWMsIDB4YWE0MDYwZWYsIDB4MDY1ZTcxOWYsIDB4NTFiZDZlMTAsIDB4ZjkzZTIxOGEsIDB4M2Q5NmRkMDYsIDB4YWVkZDNlMDUsIDB4NDY0ZGU2YmQsIDB4YjU5MTU0OGQsIDB4MDU3MWM0NWQsIDB4NmYwNDA2ZDQsIDB4ZmY2MDUwMTUsIDB4MjQxOTk4ZmIsIDB4OTdkNmJkZTksIDB4Y2M4OTQwNDMsIDB4Nzc2N2Q5OWUsIDB4YmRiMGU4NDIsIDB4ODgwNzg5OGIsIDB4MzhlNzE5NWIsIDB4ZGI3OWM4ZWUsIDB4NDdhMTdjMGEsIDB4ZTk3YzQyMGYsIDB4YzlmODg0MWUsIDB4MDAwMDAwMDAsIDB4ODMwOTgwODYsIDB4NDgzMjJiZWQsIDB4YWMxZTExNzAsIDB4NGU2YzVhNzIsIDB4ZmJmZDBlZmYsIDB4NTYwZjg1MzgsIDB4MWUzZGFlZDUsIDB4MjczNjJkMzksIDB4NjQwYTBmZDksIDB4MjE2ODVjYTYsIDB4ZDE5YjViNTQsIDB4M2EyNDM2MmUsIDB4YjEwYzBhNjcsIDB4MGY5MzU3ZTcsIDB4ZDJiNGVlOTYsIDB4OWUxYjliOTEsIDB4NGY4MGMwYzUsIDB4YTI2MWRjMjAsIDB4Njk1YTc3NGIsIDB4MTYxYzEyMWEsIDB4MGFlMjkzYmEsIDB4ZTVjMGEwMmEsIDB4NDMzYzIyZTAsIDB4MWQxMjFiMTcsIDB4MGIwZTA5MGQsIDB4YWRmMjhiYzcsIDB4YjkyZGI2YTgsIDB4YzgxNDFlYTksIDB4ODU1N2YxMTksIDB4NGNhZjc1MDcsIDB4YmJlZTk5ZGQsIDB4ZmRhMzdmNjAsIDB4OWZmNzAxMjYsIDB4YmM1YzcyZjUsIDB4YzU0NDY2M2IsIDB4MzQ1YmZiN2UsIDB4NzY4YjQzMjksIDB4ZGNjYjIzYzYsIDB4NjhiNmVkZmMsIDB4NjNiOGU0ZjEsIDB4Y2FkNzMxZGMsIDB4MTA0MjYzODUsIDB4NDAxMzk3MjIsIDB4MjA4NGM2MTEsIDB4N2Q4NTRhMjQsIDB4ZjhkMmJiM2QsIDB4MTFhZWY5MzIsIDB4NmRjNzI5YTEsIDB4NGIxZDllMmYsIDB4ZjNkY2IyMzAsIDB4ZWMwZDg2NTIsIDB4ZDA3N2MxZTMsIDB4NmMyYmIzMTYsIDB4OTlhOTcwYjksIDB4ZmExMTk0NDgsIDB4MjI0N2U5NjQsIDB4YzRhOGZjOGMsIDB4MWFhMGYwM2YsIDB4ZDg1NjdkMmMsIDB4ZWYyMjMzOTAsIDB4Yzc4NzQ5NGUsIDB4YzFkOTM4ZDEsIDB4ZmU4Y2NhYTIsIDB4MzY5OGQ0MGIsIDB4Y2ZhNmY1ODEsIDB4MjhhNTdhZGUsIDB4MjZkYWI3OGUsIDB4YTQzZmFkYmYsIDB4ZTQyYzNhOWQsIDB4MGQ1MDc4OTIsIDB4OWI2YTVmY2MsIDB4NjI1NDdlNDYsIDB4YzJmNjhkMTMsIDB4ZTg5MGQ4YjgsIDB4NWUyZTM5ZjcsIDB4ZjU4MmMzYWYsIDB4YmU5ZjVkODAsIDB4N2M2OWQwOTMsIDB4YTk2ZmQ1MmQsIDB4YjNjZjI1MTIsIDB4M2JjOGFjOTksIDB4YTcxMDE4N2QsIDB4NmVlODljNjMsIDB4N2JkYjNiYmIsIDB4MDljZDI2NzgsIDB4ZjQ2ZTU5MTgsIDB4MDFlYzlhYjcsIDB4YTg4MzRmOWEsIDB4NjVlNjk1NmUsIDB4N2VhYWZmZTYsIDB4MDgyMWJjY2YsIDB4ZTZlZjE1ZTgsIDB4ZDliYWU3OWIsIDB4Y2U0YTZmMzYsIDB4ZDRlYTlmMDksIDB4ZDYyOWIwN2MsIDB4YWYzMWE0YjIsIDB4MzEyYTNmMjMsIDB4MzBjNmE1OTQsIDB4YzAzNWEyNjYsIDB4Mzc3NDRlYmMsIDB4YTZmYzgyY2EsIDB4YjBlMDkwZDAsIDB4MTUzM2E3ZDgsIDB4NGFmMTA0OTgsIDB4Zjc0MWVjZGEsIDB4MGU3ZmNkNTAsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4NGQ0M2VmYjAsIDB4NTRjY2FhNGQsIDB4ZGZlNDk2MDQsIDB4ZTM5ZWQxYjUsIDB4MWI0YzZhODgsIDB4YjhjMTJjMWYsIDB4N2Y0NjY1NTEsIDB4MDQ5ZDVlZWEsIDB4NWQwMThjMzUsIDB4NzNmYTg3NzQsIDB4MmVmYjBiNDEsIDB4NWFiMzY3MWQsIDB4NTI5MmRiZDIsIDB4MzNlOTEwNTYsIDB4MTM2ZGQ2NDcsIDB4OGM5YWQ3NjEsIDB4N2EzN2ExMGMsIDB4OGU1OWY4MTQsIDB4ODllYjEzM2MsIDB4ZWVjZWE5MjcsIDB4MzViNzYxYzksIDB4ZWRlMTFjZTUsIDB4M2M3YTQ3YjEsIDB4NTk5Y2QyZGYsIDB4M2Y1NWYyNzMsIDB4NzkxODE0Y2UsIDB4YmY3M2M3MzcsIDB4ZWE1M2Y3Y2QsIDB4NWI1ZmZkYWEsIDB4MTRkZjNkNmYsIDB4ODY3ODQ0ZGIsIDB4ODFjYWFmZjMsIDB4M2ViOTY4YzQsIDB4MmMzODI0MzQsIDB4NWZjMmEzNDAsIDB4NzIxNjFkYzMsIDB4MGNiY2UyMjUsIDB4OGIyODNjNDksIDB4NDFmZjBkOTUsIDB4NzEzOWE4MDEsIDB4ZGUwODBjYjMsIDB4OWNkOGI0ZTQsIDB4OTA2NDU2YzEsIDB4NjE3YmNiODQsIDB4NzBkNTMyYjYsIDB4NzQ0ODZjNWMsIDB4NDJkMGI4NTddO1xuICAgIHZhciBUNyA9IFsweGE3NTA1MWY0LCAweDY1NTM3ZTQxLCAweGE0YzMxYTE3LCAweDVlOTYzYTI3LCAweDZiY2IzYmFiLCAweDQ1ZjExZjlkLCAweDU4YWJhY2ZhLCAweDAzOTM0YmUzLCAweGZhNTUyMDMwLCAweDZkZjZhZDc2LCAweDc2OTE4OGNjLCAweDRjMjVmNTAyLCAweGQ3ZmM0ZmU1LCAweGNiZDdjNTJhLCAweDQ0ODAyNjM1LCAweGEzOGZiNTYyLCAweDVhNDlkZWIxLCAweDFiNjcyNWJhLCAweDBlOTg0NWVhLCAweGMwZTE1ZGZlLCAweDc1MDJjMzJmLCAweGYwMTI4MTRjLCAweDk3YTM4ZDQ2LCAweGY5YzY2YmQzLCAweDVmZTcwMzhmLCAweDljOTUxNTkyLCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDgzMmRkNGJlLCAweDIxZDM1ODc0LCAweDY5Mjk0OWUwLCAweGM4NDQ4ZWM5LCAweDg5NmE3NWMyLCAweDc5NzhmNDhlLCAweDNlNmI5OTU4LCAweDcxZGQyN2I5LCAweDRmYjZiZWUxLCAweGFkMTdmMDg4LCAweGFjNjZjOTIwLCAweDNhYjQ3ZGNlLCAweDRhMTg2M2RmLCAweDMxODJlNTFhLCAweDMzNjA5NzUxLCAweDdmNDU2MjUzLCAweDc3ZTBiMTY0LCAweGFlODRiYjZiLCAweGEwMWNmZTgxLCAweDJiOTRmOTA4LCAweDY4NTg3MDQ4LCAweGZkMTk4ZjQ1LCAweDZjODc5NGRlLCAweGY4Yjc1MjdiLCAweGQzMjNhYjczLCAweDAyZTI3MjRiLCAweDhmNTdlMzFmLCAweGFiMmE2NjU1LCAweDI4MDdiMmViLCAweGMyMDMyZmI1LCAweDdiOWE4NmM1LCAweDA4YTVkMzM3LCAweDg3ZjIzMDI4LCAweGE1YjIyM2JmLCAweDZhYmEwMjAzLCAweDgyNWNlZDE2LCAweDFjMmI4YWNmLCAweGI0OTJhNzc5LCAweGYyZjBmMzA3LCAweGUyYTE0ZTY5LCAweGY0Y2Q2NWRhLCAweGJlZDUwNjA1LCAweDYyMWZkMTM0LCAweGZlOGFjNGE2LCAweDUzOWQzNDJlLCAweDU1YTBhMmYzLCAweGUxMzIwNThhLCAweGViNzVhNGY2LCAweGVjMzkwYjgzLCAweGVmYWE0MDYwLCAweDlmMDY1ZTcxLCAweDEwNTFiZDZlLCAweDhhZjkzZTIxLCAweDA2M2Q5NmRkLCAweDA1YWVkZDNlLCAweGJkNDY0ZGU2LCAweDhkYjU5MTU0LCAweDVkMDU3MWM0LCAweGQ0NmYwNDA2LCAweDE1ZmY2MDUwLCAweGZiMjQxOTk4LCAweGU5OTdkNmJkLCAweDQzY2M4OTQwLCAweDllNzc2N2Q5LCAweDQyYmRiMGU4LCAweDhiODgwNzg5LCAweDViMzhlNzE5LCAweGVlZGI3OWM4LCAweDBhNDdhMTdjLCAweDBmZTk3YzQyLCAweDFlYzlmODg0LCAweDAwMDAwMDAwLCAweDg2ODMwOTgwLCAweGVkNDgzMjJiLCAweDcwYWMxZTExLCAweDcyNGU2YzVhLCAweGZmZmJmZDBlLCAweDM4NTYwZjg1LCAweGQ1MWUzZGFlLCAweDM5MjczNjJkLCAweGQ5NjQwYTBmLCAweGE2MjE2ODVjLCAweDU0ZDE5YjViLCAweDJlM2EyNDM2LCAweDY3YjEwYzBhLCAweGU3MGY5MzU3LCAweDk2ZDJiNGVlLCAweDkxOWUxYjliLCAweGM1NGY4MGMwLCAweDIwYTI2MWRjLCAweDRiNjk1YTc3LCAweDFhMTYxYzEyLCAweGJhMGFlMjkzLCAweDJhZTVjMGEwLCAweGUwNDMzYzIyLCAweDE3MWQxMjFiLCAweDBkMGIwZTA5LCAweGM3YWRmMjhiLCAweGE4YjkyZGI2LCAweGE5YzgxNDFlLCAweDE5ODU1N2YxLCAweDA3NGNhZjc1LCAweGRkYmJlZTk5LCAweDYwZmRhMzdmLCAweDI2OWZmNzAxLCAweGY1YmM1YzcyLCAweDNiYzU0NDY2LCAweDdlMzQ1YmZiLCAweDI5NzY4YjQzLCAweGM2ZGNjYjIzLCAweGZjNjhiNmVkLCAweGYxNjNiOGU0LCAweGRjY2FkNzMxLCAweDg1MTA0MjYzLCAweDIyNDAxMzk3LCAweDExMjA4NGM2LCAweDI0N2Q4NTRhLCAweDNkZjhkMmJiLCAweDMyMTFhZWY5LCAweGExNmRjNzI5LCAweDJmNGIxZDllLCAweDMwZjNkY2IyLCAweDUyZWMwZDg2LCAweGUzZDA3N2MxLCAweDE2NmMyYmIzLCAweGI5OTlhOTcwLCAweDQ4ZmExMTk0LCAweDY0MjI0N2U5LCAweDhjYzRhOGZjLCAweDNmMWFhMGYwLCAweDJjZDg1NjdkLCAweDkwZWYyMjMzLCAweDRlYzc4NzQ5LCAweGQxYzFkOTM4LCAweGEyZmU4Y2NhLCAweDBiMzY5OGQ0LCAweDgxY2ZhNmY1LCAweGRlMjhhNTdhLCAweDhlMjZkYWI3LCAweGJmYTQzZmFkLCAweDlkZTQyYzNhLCAweDkyMGQ1MDc4LCAweGNjOWI2YTVmLCAweDQ2NjI1NDdlLCAweDEzYzJmNjhkLCAweGI4ZTg5MGQ4LCAweGY3NWUyZTM5LCAweGFmZjU4MmMzLCAweDgwYmU5ZjVkLCAweDkzN2M2OWQwLCAweDJkYTk2ZmQ1LCAweDEyYjNjZjI1LCAweDk5M2JjOGFjLCAweDdkYTcxMDE4LCAweDYzNmVlODljLCAweGJiN2JkYjNiLCAweDc4MDljZDI2LCAweDE4ZjQ2ZTU5LCAweGI3MDFlYzlhLCAweDlhYTg4MzRmLCAweDZlNjVlNjk1LCAweGU2N2VhYWZmLCAweGNmMDgyMWJjLCAweGU4ZTZlZjE1LCAweDliZDliYWU3LCAweDM2Y2U0YTZmLCAweDA5ZDRlYTlmLCAweDdjZDYyOWIwLCAweGIyYWYzMWE0LCAweDIzMzEyYTNmLCAweDk0MzBjNmE1LCAweDY2YzAzNWEyLCAweGJjMzc3NDRlLCAweGNhYTZmYzgyLCAweGQwYjBlMDkwLCAweGQ4MTUzM2E3LCAweDk4NGFmMTA0LCAweGRhZjc0MWVjLCAweDUwMGU3ZmNkLCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGIwNGQ0M2VmLCAweDRkNTRjY2FhLCAweDA0ZGZlNDk2LCAweGI1ZTM5ZWQxLCAweDg4MWI0YzZhLCAweDFmYjhjMTJjLCAweDUxN2Y0NjY1LCAweGVhMDQ5ZDVlLCAweDM1NWQwMThjLCAweDc0NzNmYTg3LCAweDQxMmVmYjBiLCAweDFkNWFiMzY3LCAweGQyNTI5MmRiLCAweDU2MzNlOTEwLCAweDQ3MTM2ZGQ2LCAweDYxOGM5YWQ3LCAweDBjN2EzN2ExLCAweDE0OGU1OWY4LCAweDNjODllYjEzLCAweDI3ZWVjZWE5LCAweGM5MzViNzYxLCAweGU1ZWRlMTFjLCAweGIxM2M3YTQ3LCAweGRmNTk5Y2QyLCAweDczM2Y1NWYyLCAweGNlNzkxODE0LCAweDM3YmY3M2M3LCAweGNkZWE1M2Y3LCAweGFhNWI1ZmZkLCAweDZmMTRkZjNkLCAweGRiODY3ODQ0LCAweGYzODFjYWFmLCAweGM0M2ViOTY4LCAweDM0MmMzODI0LCAweDQwNWZjMmEzLCAweGMzNzIxNjFkLCAweDI1MGNiY2UyLCAweDQ5OGIyODNjLCAweDk1NDFmZjBkLCAweDAxNzEzOWE4LCAweGIzZGUwODBjLCAweGU0OWNkOGI0LCAweGMxOTA2NDU2LCAweDg0NjE3YmNiLCAweGI2NzBkNTMyLCAweDVjNzQ0ODZjLCAweDU3NDJkMGI4XTtcbiAgICB2YXIgVDggPSBbMHhmNGE3NTA1MSwgMHg0MTY1NTM3ZSwgMHgxN2E0YzMxYSwgMHgyNzVlOTYzYSwgMHhhYjZiY2IzYiwgMHg5ZDQ1ZjExZiwgMHhmYTU4YWJhYywgMHhlMzAzOTM0YiwgMHgzMGZhNTUyMCwgMHg3NjZkZjZhZCwgMHhjYzc2OTE4OCwgMHgwMjRjMjVmNSwgMHhlNWQ3ZmM0ZiwgMHgyYWNiZDdjNSwgMHgzNTQ0ODAyNiwgMHg2MmEzOGZiNSwgMHhiMTVhNDlkZSwgMHhiYTFiNjcyNSwgMHhlYTBlOTg0NSwgMHhmZWMwZTE1ZCwgMHgyZjc1MDJjMywgMHg0Y2YwMTI4MSwgMHg0Njk3YTM4ZCwgMHhkM2Y5YzY2YiwgMHg4ZjVmZTcwMywgMHg5MjljOTUxNSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHhiZTgzMmRkNCwgMHg3NDIxZDM1OCwgMHhlMDY5Mjk0OSwgMHhjOWM4NDQ4ZSwgMHhjMjg5NmE3NSwgMHg4ZTc5NzhmNCwgMHg1ODNlNmI5OSwgMHhiOTcxZGQyNywgMHhlMTRmYjZiZSwgMHg4OGFkMTdmMCwgMHgyMGFjNjZjOSwgMHhjZTNhYjQ3ZCwgMHhkZjRhMTg2MywgMHgxYTMxODJlNSwgMHg1MTMzNjA5NywgMHg1MzdmNDU2MiwgMHg2NDc3ZTBiMSwgMHg2YmFlODRiYiwgMHg4MWEwMWNmZSwgMHgwODJiOTRmOSwgMHg0ODY4NTg3MCwgMHg0NWZkMTk4ZiwgMHhkZTZjODc5NCwgMHg3YmY4Yjc1MiwgMHg3M2QzMjNhYiwgMHg0YjAyZTI3MiwgMHgxZjhmNTdlMywgMHg1NWFiMmE2NiwgMHhlYjI4MDdiMiwgMHhiNWMyMDMyZiwgMHhjNTdiOWE4NiwgMHgzNzA4YTVkMywgMHgyODg3ZjIzMCwgMHhiZmE1YjIyMywgMHgwMzZhYmEwMiwgMHgxNjgyNWNlZCwgMHhjZjFjMmI4YSwgMHg3OWI0OTJhNywgMHgwN2YyZjBmMywgMHg2OWUyYTE0ZSwgMHhkYWY0Y2Q2NSwgMHgwNWJlZDUwNiwgMHgzNDYyMWZkMSwgMHhhNmZlOGFjNCwgMHgyZTUzOWQzNCwgMHhmMzU1YTBhMiwgMHg4YWUxMzIwNSwgMHhmNmViNzVhNCwgMHg4M2VjMzkwYiwgMHg2MGVmYWE0MCwgMHg3MTlmMDY1ZSwgMHg2ZTEwNTFiZCwgMHgyMThhZjkzZSwgMHhkZDA2M2Q5NiwgMHgzZTA1YWVkZCwgMHhlNmJkNDY0ZCwgMHg1NDhkYjU5MSwgMHhjNDVkMDU3MSwgMHgwNmQ0NmYwNCwgMHg1MDE1ZmY2MCwgMHg5OGZiMjQxOSwgMHhiZGU5OTdkNiwgMHg0MDQzY2M4OSwgMHhkOTllNzc2NywgMHhlODQyYmRiMCwgMHg4OThiODgwNywgMHgxOTViMzhlNywgMHhjOGVlZGI3OSwgMHg3YzBhNDdhMSwgMHg0MjBmZTk3YywgMHg4NDFlYzlmOCwgMHgwMDAwMDAwMCwgMHg4MDg2ODMwOSwgMHgyYmVkNDgzMiwgMHgxMTcwYWMxZSwgMHg1YTcyNGU2YywgMHgwZWZmZmJmZCwgMHg4NTM4NTYwZiwgMHhhZWQ1MWUzZCwgMHgyZDM5MjczNiwgMHgwZmQ5NjQwYSwgMHg1Y2E2MjE2OCwgMHg1YjU0ZDE5YiwgMHgzNjJlM2EyNCwgMHgwYTY3YjEwYywgMHg1N2U3MGY5MywgMHhlZTk2ZDJiNCwgMHg5YjkxOWUxYiwgMHhjMGM1NGY4MCwgMHhkYzIwYTI2MSwgMHg3NzRiNjk1YSwgMHgxMjFhMTYxYywgMHg5M2JhMGFlMiwgMHhhMDJhZTVjMCwgMHgyMmUwNDMzYywgMHgxYjE3MWQxMiwgMHgwOTBkMGIwZSwgMHg4YmM3YWRmMiwgMHhiNmE4YjkyZCwgMHgxZWE5YzgxNCwgMHhmMTE5ODU1NywgMHg3NTA3NGNhZiwgMHg5OWRkYmJlZSwgMHg3ZjYwZmRhMywgMHgwMTI2OWZmNywgMHg3MmY1YmM1YywgMHg2NjNiYzU0NCwgMHhmYjdlMzQ1YiwgMHg0MzI5NzY4YiwgMHgyM2M2ZGNjYiwgMHhlZGZjNjhiNiwgMHhlNGYxNjNiOCwgMHgzMWRjY2FkNywgMHg2Mzg1MTA0MiwgMHg5NzIyNDAxMywgMHhjNjExMjA4NCwgMHg0YTI0N2Q4NSwgMHhiYjNkZjhkMiwgMHhmOTMyMTFhZSwgMHgyOWExNmRjNywgMHg5ZTJmNGIxZCwgMHhiMjMwZjNkYywgMHg4NjUyZWMwZCwgMHhjMWUzZDA3NywgMHhiMzE2NmMyYiwgMHg3MGI5OTlhOSwgMHg5NDQ4ZmExMSwgMHhlOTY0MjI0NywgMHhmYzhjYzRhOCwgMHhmMDNmMWFhMCwgMHg3ZDJjZDg1NiwgMHgzMzkwZWYyMiwgMHg0OTRlYzc4NywgMHgzOGQxYzFkOSwgMHhjYWEyZmU4YywgMHhkNDBiMzY5OCwgMHhmNTgxY2ZhNiwgMHg3YWRlMjhhNSwgMHhiNzhlMjZkYSwgMHhhZGJmYTQzZiwgMHgzYTlkZTQyYywgMHg3ODkyMGQ1MCwgMHg1ZmNjOWI2YSwgMHg3ZTQ2NjI1NCwgMHg4ZDEzYzJmNiwgMHhkOGI4ZTg5MCwgMHgzOWY3NWUyZSwgMHhjM2FmZjU4MiwgMHg1ZDgwYmU5ZiwgMHhkMDkzN2M2OSwgMHhkNTJkYTk2ZiwgMHgyNTEyYjNjZiwgMHhhYzk5M2JjOCwgMHgxODdkYTcxMCwgMHg5YzYzNmVlOCwgMHgzYmJiN2JkYiwgMHgyNjc4MDljZCwgMHg1OTE4ZjQ2ZSwgMHg5YWI3MDFlYywgMHg0ZjlhYTg4MywgMHg5NTZlNjVlNiwgMHhmZmU2N2VhYSwgMHhiY2NmMDgyMSwgMHgxNWU4ZTZlZiwgMHhlNzliZDliYSwgMHg2ZjM2Y2U0YSwgMHg5ZjA5ZDRlYSwgMHhiMDdjZDYyOSwgMHhhNGIyYWYzMSwgMHgzZjIzMzEyYSwgMHhhNTk0MzBjNiwgMHhhMjY2YzAzNSwgMHg0ZWJjMzc3NCwgMHg4MmNhYTZmYywgMHg5MGQwYjBlMCwgMHhhN2Q4MTUzMywgMHgwNDk4NGFmMSwgMHhlY2RhZjc0MSwgMHhjZDUwMGU3ZiwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHhlZmIwNGQ0MywgMHhhYTRkNTRjYywgMHg5NjA0ZGZlNCwgMHhkMWI1ZTM5ZSwgMHg2YTg4MWI0YywgMHgyYzFmYjhjMSwgMHg2NTUxN2Y0NiwgMHg1ZWVhMDQ5ZCwgMHg4YzM1NWQwMSwgMHg4Nzc0NzNmYSwgMHgwYjQxMmVmYiwgMHg2NzFkNWFiMywgMHhkYmQyNTI5MiwgMHgxMDU2MzNlOSwgMHhkNjQ3MTM2ZCwgMHhkNzYxOGM5YSwgMHhhMTBjN2EzNywgMHhmODE0OGU1OSwgMHgxMzNjODllYiwgMHhhOTI3ZWVjZSwgMHg2MWM5MzViNywgMHgxY2U1ZWRlMSwgMHg0N2IxM2M3YSwgMHhkMmRmNTk5YywgMHhmMjczM2Y1NSwgMHgxNGNlNzkxOCwgMHhjNzM3YmY3MywgMHhmN2NkZWE1MywgMHhmZGFhNWI1ZiwgMHgzZDZmMTRkZiwgMHg0NGRiODY3OCwgMHhhZmYzODFjYSwgMHg2OGM0M2ViOSwgMHgyNDM0MmMzOCwgMHhhMzQwNWZjMiwgMHgxZGMzNzIxNiwgMHhlMjI1MGNiYywgMHgzYzQ5OGIyOCwgMHgwZDk1NDFmZiwgMHhhODAxNzEzOSwgMHgwY2IzZGUwOCwgMHhiNGU0OWNkOCwgMHg1NmMxOTA2NCwgMHhjYjg0NjE3YiwgMHgzMmI2NzBkNSwgMHg2YzVjNzQ0OCwgMHhiODU3NDJkMF07XG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuICAgIHZhciBVMSA9IFsweDAwMDAwMDAwLCAweDBlMDkwZDBiLCAweDFjMTIxYTE2LCAweDEyMWIxNzFkLCAweDM4MjQzNDJjLCAweDM2MmQzOTI3LCAweDI0MzYyZTNhLCAweDJhM2YyMzMxLCAweDcwNDg2ODU4LCAweDdlNDE2NTUzLCAweDZjNWE3MjRlLCAweDYyNTM3ZjQ1LCAweDQ4NmM1Yzc0LCAweDQ2NjU1MTdmLCAweDU0N2U0NjYyLCAweDVhNzc0YjY5LCAweGUwOTBkMGIwLCAweGVlOTlkZGJiLCAweGZjODJjYWE2LCAweGYyOGJjN2FkLCAweGQ4YjRlNDljLCAweGQ2YmRlOTk3LCAweGM0YTZmZThhLCAweGNhYWZmMzgxLCAweDkwZDhiOGU4LCAweDllZDFiNWUzLCAweDhjY2FhMmZlLCAweDgyYzNhZmY1LCAweGE4ZmM4Y2M0LCAweGE2ZjU4MWNmLCAweGI0ZWU5NmQyLCAweGJhZTc5YmQ5LCAweGRiM2JiYjdiLCAweGQ1MzJiNjcwLCAweGM3MjlhMTZkLCAweGM5MjBhYzY2LCAweGUzMWY4ZjU3LCAweGVkMTY4MjVjLCAweGZmMGQ5NTQxLCAweGYxMDQ5ODRhLCAweGFiNzNkMzIzLCAweGE1N2FkZTI4LCAweGI3NjFjOTM1LCAweGI5NjhjNDNlLCAweDkzNTdlNzBmLCAweDlkNWVlYTA0LCAweDhmNDVmZDE5LCAweDgxNGNmMDEyLCAweDNiYWI2YmNiLCAweDM1YTI2NmMwLCAweDI3Yjk3MWRkLCAweDI5YjA3Y2Q2LCAweDAzOGY1ZmU3LCAweDBkODY1MmVjLCAweDFmOWQ0NWYxLCAweDExOTQ0OGZhLCAweDRiZTMwMzkzLCAweDQ1ZWEwZTk4LCAweDU3ZjExOTg1LCAweDU5ZjgxNDhlLCAweDczYzczN2JmLCAweDdkY2UzYWI0LCAweDZmZDUyZGE5LCAweDYxZGMyMGEyLCAweGFkNzY2ZGY2LCAweGEzN2Y2MGZkLCAweGIxNjQ3N2UwLCAweGJmNmQ3YWViLCAweDk1NTI1OWRhLCAweDliNWI1NGQxLCAweDg5NDA0M2NjLCAweDg3NDk0ZWM3LCAweGRkM2UwNWFlLCAweGQzMzcwOGE1LCAweGMxMmMxZmI4LCAweGNmMjUxMmIzLCAweGU1MWEzMTgyLCAweGViMTMzYzg5LCAweGY5MDgyYjk0LCAweGY3MDEyNjlmLCAweDRkZTZiZDQ2LCAweDQzZWZiMDRkLCAweDUxZjRhNzUwLCAweDVmZmRhYTViLCAweDc1YzI4OTZhLCAweDdiY2I4NDYxLCAweDY5ZDA5MzdjLCAweDY3ZDk5ZTc3LCAweDNkYWVkNTFlLCAweDMzYTdkODE1LCAweDIxYmNjZjA4LCAweDJmYjVjMjAzLCAweDA1OGFlMTMyLCAweDBiODNlYzM5LCAweDE5OThmYjI0LCAweDE3OTFmNjJmLCAweDc2NGRkNjhkLCAweDc4NDRkYjg2LCAweDZhNWZjYzliLCAweDY0NTZjMTkwLCAweDRlNjllMmExLCAweDQwNjBlZmFhLCAweDUyN2JmOGI3LCAweDVjNzJmNWJjLCAweDA2MDViZWQ1LCAweDA4MGNiM2RlLCAweDFhMTdhNGMzLCAweDE0MWVhOWM4LCAweDNlMjE4YWY5LCAweDMwMjg4N2YyLCAweDIyMzM5MGVmLCAweDJjM2E5ZGU0LCAweDk2ZGQwNjNkLCAweDk4ZDQwYjM2LCAweDhhY2YxYzJiLCAweDg0YzYxMTIwLCAweGFlZjkzMjExLCAweGEwZjAzZjFhLCAweGIyZWIyODA3LCAweGJjZTIyNTBjLCAweGU2OTU2ZTY1LCAweGU4OWM2MzZlLCAweGZhODc3NDczLCAweGY0OGU3OTc4LCAweGRlYjE1YTQ5LCAweGQwYjg1NzQyLCAweGMyYTM0MDVmLCAweGNjYWE0ZDU0LCAweDQxZWNkYWY3LCAweDRmZTVkN2ZjLCAweDVkZmVjMGUxLCAweDUzZjdjZGVhLCAweDc5YzhlZWRiLCAweDc3YzFlM2QwLCAweDY1ZGFmNGNkLCAweDZiZDNmOWM2LCAweDMxYTRiMmFmLCAweDNmYWRiZmE0LCAweDJkYjZhOGI5LCAweDIzYmZhNWIyLCAweDA5ODA4NjgzLCAweDA3ODk4Yjg4LCAweDE1OTI5Yzk1LCAweDFiOWI5MTllLCAweGExN2MwYTQ3LCAweGFmNzUwNzRjLCAweGJkNmUxMDUxLCAweGIzNjcxZDVhLCAweDk5NTgzZTZiLCAweDk3NTEzMzYwLCAweDg1NGEyNDdkLCAweDhiNDMyOTc2LCAweGQxMzQ2MjFmLCAweGRmM2Q2ZjE0LCAweGNkMjY3ODA5LCAweGMzMmY3NTAyLCAweGU5MTA1NjMzLCAweGU3MTk1YjM4LCAweGY1MDI0YzI1LCAweGZiMGI0MTJlLCAweDlhZDc2MThjLCAweDk0ZGU2Yzg3LCAweDg2YzU3YjlhLCAweDg4Y2M3NjkxLCAweGEyZjM1NWEwLCAweGFjZmE1OGFiLCAweGJlZTE0ZmI2LCAweGIwZTg0MmJkLCAweGVhOWYwOWQ0LCAweGU0OTYwNGRmLCAweGY2OGQxM2MyLCAweGY4ODQxZWM5LCAweGQyYmIzZGY4LCAweGRjYjIzMGYzLCAweGNlYTkyN2VlLCAweGMwYTAyYWU1LCAweDdhNDdiMTNjLCAweDc0NGViYzM3LCAweDY2NTVhYjJhLCAweDY4NWNhNjIxLCAweDQyNjM4NTEwLCAweDRjNmE4ODFiLCAweDVlNzE5ZjA2LCAweDUwNzg5MjBkLCAweDBhMGZkOTY0LCAweDA0MDZkNDZmLCAweDE2MWRjMzcyLCAweDE4MTRjZTc5LCAweDMyMmJlZDQ4LCAweDNjMjJlMDQzLCAweDJlMzlmNzVlLCAweDIwMzBmYTU1LCAweGVjOWFiNzAxLCAweGUyOTNiYTBhLCAweGYwODhhZDE3LCAweGZlODFhMDFjLCAweGQ0YmU4MzJkLCAweGRhYjc4ZTI2LCAweGM4YWM5OTNiLCAweGM2YTU5NDMwLCAweDljZDJkZjU5LCAweDkyZGJkMjUyLCAweDgwYzBjNTRmLCAweDhlYzljODQ0LCAweGE0ZjZlYjc1LCAweGFhZmZlNjdlLCAweGI4ZTRmMTYzLCAweGI2ZWRmYzY4LCAweDBjMGE2N2IxLCAweDAyMDM2YWJhLCAweDEwMTg3ZGE3LCAweDFlMTE3MGFjLCAweDM0MmU1MzlkLCAweDNhMjc1ZTk2LCAweDI4M2M0OThiLCAweDI2MzU0NDgwLCAweDdjNDIwZmU5LCAweDcyNGIwMmUyLCAweDYwNTAxNWZmLCAweDZlNTkxOGY0LCAweDQ0NjYzYmM1LCAweDRhNmYzNmNlLCAweDU4NzQyMWQzLCAweDU2N2QyY2Q4LCAweDM3YTEwYzdhLCAweDM5YTgwMTcxLCAweDJiYjMxNjZjLCAweDI1YmExYjY3LCAweDBmODUzODU2LCAweDAxOGMzNTVkLCAweDEzOTcyMjQwLCAweDFkOWUyZjRiLCAweDQ3ZTk2NDIyLCAweDQ5ZTA2OTI5LCAweDViZmI3ZTM0LCAweDU1ZjI3MzNmLCAweDdmY2Q1MDBlLCAweDcxYzQ1ZDA1LCAweDYzZGY0YTE4LCAweDZkZDY0NzEzLCAweGQ3MzFkY2NhLCAweGQ5MzhkMWMxLCAweGNiMjNjNmRjLCAweGM1MmFjYmQ3LCAweGVmMTVlOGU2LCAweGUxMWNlNWVkLCAweGYzMDdmMmYwLCAweGZkMGVmZmZiLCAweGE3NzliNDkyLCAweGE5NzBiOTk5LCAweGJiNmJhZTg0LCAweGI1NjJhMzhmLCAweDlmNWQ4MGJlLCAweDkxNTQ4ZGI1LCAweDgzNGY5YWE4LCAweDhkNDY5N2EzXTtcbiAgICB2YXIgVTIgPSBbMHgwMDAwMDAwMCwgMHgwYjBlMDkwZCwgMHgxNjFjMTIxYSwgMHgxZDEyMWIxNywgMHgyYzM4MjQzNCwgMHgyNzM2MmQzOSwgMHgzYTI0MzYyZSwgMHgzMTJhM2YyMywgMHg1ODcwNDg2OCwgMHg1MzdlNDE2NSwgMHg0ZTZjNWE3MiwgMHg0NTYyNTM3ZiwgMHg3NDQ4NmM1YywgMHg3ZjQ2NjU1MSwgMHg2MjU0N2U0NiwgMHg2OTVhNzc0YiwgMHhiMGUwOTBkMCwgMHhiYmVlOTlkZCwgMHhhNmZjODJjYSwgMHhhZGYyOGJjNywgMHg5Y2Q4YjRlNCwgMHg5N2Q2YmRlOSwgMHg4YWM0YTZmZSwgMHg4MWNhYWZmMywgMHhlODkwZDhiOCwgMHhlMzllZDFiNSwgMHhmZThjY2FhMiwgMHhmNTgyYzNhZiwgMHhjNGE4ZmM4YywgMHhjZmE2ZjU4MSwgMHhkMmI0ZWU5NiwgMHhkOWJhZTc5YiwgMHg3YmRiM2JiYiwgMHg3MGQ1MzJiNiwgMHg2ZGM3MjlhMSwgMHg2NmM5MjBhYywgMHg1N2UzMWY4ZiwgMHg1Y2VkMTY4MiwgMHg0MWZmMGQ5NSwgMHg0YWYxMDQ5OCwgMHgyM2FiNzNkMywgMHgyOGE1N2FkZSwgMHgzNWI3NjFjOSwgMHgzZWI5NjhjNCwgMHgwZjkzNTdlNywgMHgwNDlkNWVlYSwgMHgxOThmNDVmZCwgMHgxMjgxNGNmMCwgMHhjYjNiYWI2YiwgMHhjMDM1YTI2NiwgMHhkZDI3Yjk3MSwgMHhkNjI5YjA3YywgMHhlNzAzOGY1ZiwgMHhlYzBkODY1MiwgMHhmMTFmOWQ0NSwgMHhmYTExOTQ0OCwgMHg5MzRiZTMwMywgMHg5ODQ1ZWEwZSwgMHg4NTU3ZjExOSwgMHg4ZTU5ZjgxNCwgMHhiZjczYzczNywgMHhiNDdkY2UzYSwgMHhhOTZmZDUyZCwgMHhhMjYxZGMyMCwgMHhmNmFkNzY2ZCwgMHhmZGEzN2Y2MCwgMHhlMGIxNjQ3NywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHhkMTliNWI1NCwgMHhjYzg5NDA0MywgMHhjNzg3NDk0ZSwgMHhhZWRkM2UwNSwgMHhhNWQzMzcwOCwgMHhiOGMxMmMxZiwgMHhiM2NmMjUxMiwgMHg4MmU1MWEzMSwgMHg4OWViMTMzYywgMHg5NGY5MDgyYiwgMHg5ZmY3MDEyNiwgMHg0NjRkZTZiZCwgMHg0ZDQzZWZiMCwgMHg1MDUxZjRhNywgMHg1YjVmZmRhYSwgMHg2YTc1YzI4OSwgMHg2MTdiY2I4NCwgMHg3YzY5ZDA5MywgMHg3NzY3ZDk5ZSwgMHgxZTNkYWVkNSwgMHgxNTMzYTdkOCwgMHgwODIxYmNjZiwgMHgwMzJmYjVjMiwgMHgzMjA1OGFlMSwgMHgzOTBiODNlYywgMHgyNDE5OThmYiwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg4Njc4NDRkYiwgMHg5YjZhNWZjYywgMHg5MDY0NTZjMSwgMHhhMTRlNjllMiwgMHhhYTQwNjBlZiwgMHhiNzUyN2JmOCwgMHhiYzVjNzJmNSwgMHhkNTA2MDViZSwgMHhkZTA4MGNiMywgMHhjMzFhMTdhNCwgMHhjODE0MWVhOSwgMHhmOTNlMjE4YSwgMHhmMjMwMjg4NywgMHhlZjIyMzM5MCwgMHhlNDJjM2E5ZCwgMHgzZDk2ZGQwNiwgMHgzNjk4ZDQwYiwgMHgyYjhhY2YxYywgMHgyMDg0YzYxMSwgMHgxMWFlZjkzMiwgMHgxYWEwZjAzZiwgMHgwN2IyZWIyOCwgMHgwY2JjZTIyNSwgMHg2NWU2OTU2ZSwgMHg2ZWU4OWM2MywgMHg3M2ZhODc3NCwgMHg3OGY0OGU3OSwgMHg0OWRlYjE1YSwgMHg0MmQwYjg1NywgMHg1ZmMyYTM0MCwgMHg1NGNjYWE0ZCwgMHhmNzQxZWNkYSwgMHhmYzRmZTVkNywgMHhlMTVkZmVjMCwgMHhlYTUzZjdjZCwgMHhkYjc5YzhlZSwgMHhkMDc3YzFlMywgMHhjZDY1ZGFmNCwgMHhjNjZiZDNmOSwgMHhhZjMxYTRiMiwgMHhhNDNmYWRiZiwgMHhiOTJkYjZhOCwgMHhiMjIzYmZhNSwgMHg4MzA5ODA4NiwgMHg4ODA3ODk4YiwgMHg5NTE1OTI5YywgMHg5ZTFiOWI5MSwgMHg0N2ExN2MwYSwgMHg0Y2FmNzUwNywgMHg1MWJkNmUxMCwgMHg1YWIzNjcxZCwgMHg2Yjk5NTgzZSwgMHg2MDk3NTEzMywgMHg3ZDg1NGEyNCwgMHg3NjhiNDMyOSwgMHgxZmQxMzQ2MiwgMHgxNGRmM2Q2ZiwgMHgwOWNkMjY3OCwgMHgwMmMzMmY3NSwgMHgzM2U5MTA1NiwgMHgzOGU3MTk1YiwgMHgyNWY1MDI0YywgMHgyZWZiMGI0MSwgMHg4YzlhZDc2MSwgMHg4Nzk0ZGU2YywgMHg5YTg2YzU3YiwgMHg5MTg4Y2M3NiwgMHhhMGEyZjM1NSwgMHhhYmFjZmE1OCwgMHhiNmJlZTE0ZiwgMHhiZGIwZTg0MiwgMHhkNGVhOWYwOSwgMHhkZmU0OTYwNCwgMHhjMmY2OGQxMywgMHhjOWY4ODQxZSwgMHhmOGQyYmIzZCwgMHhmM2RjYjIzMCwgMHhlZWNlYTkyNywgMHhlNWMwYTAyYSwgMHgzYzdhNDdiMSwgMHgzNzc0NGViYywgMHgyYTY2NTVhYiwgMHgyMTY4NWNhNiwgMHgxMDQyNjM4NSwgMHgxYjRjNmE4OCwgMHgwNjVlNzE5ZiwgMHgwZDUwNzg5MiwgMHg2NDBhMGZkOSwgMHg2ZjA0MDZkNCwgMHg3MjE2MWRjMywgMHg3OTE4MTRjZSwgMHg0ODMyMmJlZCwgMHg0MzNjMjJlMCwgMHg1ZTJlMzlmNywgMHg1NTIwMzBmYSwgMHgwMWVjOWFiNywgMHgwYWUyOTNiYSwgMHgxN2YwODhhZCwgMHgxY2ZlODFhMCwgMHgyZGQ0YmU4MywgMHgyNmRhYjc4ZSwgMHgzYmM4YWM5OSwgMHgzMGM2YTU5NCwgMHg1OTljZDJkZiwgMHg1MjkyZGJkMiwgMHg0ZjgwYzBjNSwgMHg0NDhlYzljOCwgMHg3NWE0ZjZlYiwgMHg3ZWFhZmZlNiwgMHg2M2I4ZTRmMSwgMHg2OGI2ZWRmYywgMHhiMTBjMGE2NywgMHhiYTAyMDM2YSwgMHhhNzEwMTg3ZCwgMHhhYzFlMTE3MCwgMHg5ZDM0MmU1MywgMHg5NjNhMjc1ZSwgMHg4YjI4M2M0OSwgMHg4MDI2MzU0NCwgMHhlOTdjNDIwZiwgMHhlMjcyNGIwMiwgMHhmZjYwNTAxNSwgMHhmNDZlNTkxOCwgMHhjNTQ0NjYzYiwgMHhjZTRhNmYzNiwgMHhkMzU4NzQyMSwgMHhkODU2N2QyYywgMHg3YTM3YTEwYywgMHg3MTM5YTgwMSwgMHg2YzJiYjMxNiwgMHg2NzI1YmExYiwgMHg1NjBmODUzOCwgMHg1ZDAxOGMzNSwgMHg0MDEzOTcyMiwgMHg0YjFkOWUyZiwgMHgyMjQ3ZTk2NCwgMHgyOTQ5ZTA2OSwgMHgzNDViZmI3ZSwgMHgzZjU1ZjI3MywgMHgwZTdmY2Q1MCwgMHgwNTcxYzQ1ZCwgMHgxODYzZGY0YSwgMHgxMzZkZDY0NywgMHhjYWQ3MzFkYywgMHhjMWQ5MzhkMSwgMHhkY2NiMjNjNiwgMHhkN2M1MmFjYiwgMHhlNmVmMTVlOCwgMHhlZGUxMWNlNSwgMHhmMGYzMDdmMiwgMHhmYmZkMGVmZiwgMHg5MmE3NzliNCwgMHg5OWE5NzBiOSwgMHg4NGJiNmJhZSwgMHg4ZmI1NjJhMywgMHhiZTlmNWQ4MCwgMHhiNTkxNTQ4ZCwgMHhhODgzNGY5YSwgMHhhMzhkNDY5N107XG4gICAgdmFyIFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuICAgIHZhciBVNCA9IFsweDAwMDAwMDAwLCAweDA5MGQwYjBlLCAweDEyMWExNjFjLCAweDFiMTcxZDEyLCAweDI0MzQyYzM4LCAweDJkMzkyNzM2LCAweDM2MmUzYTI0LCAweDNmMjMzMTJhLCAweDQ4Njg1ODcwLCAweDQxNjU1MzdlLCAweDVhNzI0ZTZjLCAweDUzN2Y0NTYyLCAweDZjNWM3NDQ4LCAweDY1NTE3ZjQ2LCAweDdlNDY2MjU0LCAweDc3NGI2OTVhLCAweDkwZDBiMGUwLCAweDk5ZGRiYmVlLCAweDgyY2FhNmZjLCAweDhiYzdhZGYyLCAweGI0ZTQ5Y2Q4LCAweGJkZTk5N2Q2LCAweGE2ZmU4YWM0LCAweGFmZjM4MWNhLCAweGQ4YjhlODkwLCAweGQxYjVlMzllLCAweGNhYTJmZThjLCAweGMzYWZmNTgyLCAweGZjOGNjNGE4LCAweGY1ODFjZmE2LCAweGVlOTZkMmI0LCAweGU3OWJkOWJhLCAweDNiYmI3YmRiLCAweDMyYjY3MGQ1LCAweDI5YTE2ZGM3LCAweDIwYWM2NmM5LCAweDFmOGY1N2UzLCAweDE2ODI1Y2VkLCAweDBkOTU0MWZmLCAweDA0OTg0YWYxLCAweDczZDMyM2FiLCAweDdhZGUyOGE1LCAweDYxYzkzNWI3LCAweDY4YzQzZWI5LCAweDU3ZTcwZjkzLCAweDVlZWEwNDlkLCAweDQ1ZmQxOThmLCAweDRjZjAxMjgxLCAweGFiNmJjYjNiLCAweGEyNjZjMDM1LCAweGI5NzFkZDI3LCAweGIwN2NkNjI5LCAweDhmNWZlNzAzLCAweDg2NTJlYzBkLCAweDlkNDVmMTFmLCAweDk0NDhmYTExLCAweGUzMDM5MzRiLCAweGVhMGU5ODQ1LCAweGYxMTk4NTU3LCAweGY4MTQ4ZTU5LCAweGM3MzdiZjczLCAweGNlM2FiNDdkLCAweGQ1MmRhOTZmLCAweGRjMjBhMjYxLCAweDc2NmRmNmFkLCAweDdmNjBmZGEzLCAweDY0NzdlMGIxLCAweDZkN2FlYmJmLCAweDUyNTlkYTk1LCAweDViNTRkMTliLCAweDQwNDNjYzg5LCAweDQ5NGVjNzg3LCAweDNlMDVhZWRkLCAweDM3MDhhNWQzLCAweDJjMWZiOGMxLCAweDI1MTJiM2NmLCAweDFhMzE4MmU1LCAweDEzM2M4OWViLCAweDA4MmI5NGY5LCAweDAxMjY5ZmY3LCAweGU2YmQ0NjRkLCAweGVmYjA0ZDQzLCAweGY0YTc1MDUxLCAweGZkYWE1YjVmLCAweGMyODk2YTc1LCAweGNiODQ2MTdiLCAweGQwOTM3YzY5LCAweGQ5OWU3NzY3LCAweGFlZDUxZTNkLCAweGE3ZDgxNTMzLCAweGJjY2YwODIxLCAweGI1YzIwMzJmLCAweDhhZTEzMjA1LCAweDgzZWMzOTBiLCAweDk4ZmIyNDE5LCAweDkxZjYyZjE3LCAweDRkZDY4ZDc2LCAweDQ0ZGI4Njc4LCAweDVmY2M5YjZhLCAweDU2YzE5MDY0LCAweDY5ZTJhMTRlLCAweDYwZWZhYTQwLCAweDdiZjhiNzUyLCAweDcyZjViYzVjLCAweDA1YmVkNTA2LCAweDBjYjNkZTA4LCAweDE3YTRjMzFhLCAweDFlYTljODE0LCAweDIxOGFmOTNlLCAweDI4ODdmMjMwLCAweDMzOTBlZjIyLCAweDNhOWRlNDJjLCAweGRkMDYzZDk2LCAweGQ0MGIzNjk4LCAweGNmMWMyYjhhLCAweGM2MTEyMDg0LCAweGY5MzIxMWFlLCAweGYwM2YxYWEwLCAweGViMjgwN2IyLCAweGUyMjUwY2JjLCAweDk1NmU2NWU2LCAweDljNjM2ZWU4LCAweDg3NzQ3M2ZhLCAweDhlNzk3OGY0LCAweGIxNWE0OWRlLCAweGI4NTc0MmQwLCAweGEzNDA1ZmMyLCAweGFhNGQ1NGNjLCAweGVjZGFmNzQxLCAweGU1ZDdmYzRmLCAweGZlYzBlMTVkLCAweGY3Y2RlYTUzLCAweGM4ZWVkYjc5LCAweGMxZTNkMDc3LCAweGRhZjRjZDY1LCAweGQzZjljNjZiLCAweGE0YjJhZjMxLCAweGFkYmZhNDNmLCAweGI2YThiOTJkLCAweGJmYTViMjIzLCAweDgwODY4MzA5LCAweDg5OGI4ODA3LCAweDkyOWM5NTE1LCAweDliOTE5ZTFiLCAweDdjMGE0N2ExLCAweDc1MDc0Y2FmLCAweDZlMTA1MWJkLCAweDY3MWQ1YWIzLCAweDU4M2U2Yjk5LCAweDUxMzM2MDk3LCAweDRhMjQ3ZDg1LCAweDQzMjk3NjhiLCAweDM0NjIxZmQxLCAweDNkNmYxNGRmLCAweDI2NzgwOWNkLCAweDJmNzUwMmMzLCAweDEwNTYzM2U5LCAweDE5NWIzOGU3LCAweDAyNGMyNWY1LCAweDBiNDEyZWZiLCAweGQ3NjE4YzlhLCAweGRlNmM4Nzk0LCAweGM1N2I5YTg2LCAweGNjNzY5MTg4LCAweGYzNTVhMGEyLCAweGZhNThhYmFjLCAweGUxNGZiNmJlLCAweGU4NDJiZGIwLCAweDlmMDlkNGVhLCAweDk2MDRkZmU0LCAweDhkMTNjMmY2LCAweDg0MWVjOWY4LCAweGJiM2RmOGQyLCAweGIyMzBmM2RjLCAweGE5MjdlZWNlLCAweGEwMmFlNWMwLCAweDQ3YjEzYzdhLCAweDRlYmMzNzc0LCAweDU1YWIyYTY2LCAweDVjYTYyMTY4LCAweDYzODUxMDQyLCAweDZhODgxYjRjLCAweDcxOWYwNjVlLCAweDc4OTIwZDUwLCAweDBmZDk2NDBhLCAweDA2ZDQ2ZjA0LCAweDFkYzM3MjE2LCAweDE0Y2U3OTE4LCAweDJiZWQ0ODMyLCAweDIyZTA0MzNjLCAweDM5Zjc1ZTJlLCAweDMwZmE1NTIwLCAweDlhYjcwMWVjLCAweDkzYmEwYWUyLCAweDg4YWQxN2YwLCAweDgxYTAxY2ZlLCAweGJlODMyZGQ0LCAweGI3OGUyNmRhLCAweGFjOTkzYmM4LCAweGE1OTQzMGM2LCAweGQyZGY1OTljLCAweGRiZDI1MjkyLCAweGMwYzU0ZjgwLCAweGM5Yzg0NDhlLCAweGY2ZWI3NWE0LCAweGZmZTY3ZWFhLCAweGU0ZjE2M2I4LCAweGVkZmM2OGI2LCAweDBhNjdiMTBjLCAweDAzNmFiYTAyLCAweDE4N2RhNzEwLCAweDExNzBhYzFlLCAweDJlNTM5ZDM0LCAweDI3NWU5NjNhLCAweDNjNDk4YjI4LCAweDM1NDQ4MDI2LCAweDQyMGZlOTdjLCAweDRiMDJlMjcyLCAweDUwMTVmZjYwLCAweDU5MThmNDZlLCAweDY2M2JjNTQ0LCAweDZmMzZjZTRhLCAweDc0MjFkMzU4LCAweDdkMmNkODU2LCAweGExMGM3YTM3LCAweGE4MDE3MTM5LCAweGIzMTY2YzJiLCAweGJhMWI2NzI1LCAweDg1Mzg1NjBmLCAweDhjMzU1ZDAxLCAweDk3MjI0MDEzLCAweDllMmY0YjFkLCAweGU5NjQyMjQ3LCAweGUwNjkyOTQ5LCAweGZiN2UzNDViLCAweGYyNzMzZjU1LCAweGNkNTAwZTdmLCAweGM0NWQwNTcxLCAweGRmNGExODYzLCAweGQ2NDcxMzZkLCAweDMxZGNjYWQ3LCAweDM4ZDFjMWQ5LCAweDIzYzZkY2NiLCAweDJhY2JkN2M1LCAweDE1ZThlNmVmLCAweDFjZTVlZGUxLCAweDA3ZjJmMGYzLCAweDBlZmZmYmZkLCAweDc5YjQ5MmE3LCAweDcwYjk5OWE5LCAweDZiYWU4NGJiLCAweDYyYTM4ZmI1LCAweDVkODBiZTlmLCAweDU0OGRiNTkxLCAweDRmOWFhODgzLCAweDQ2OTdhMzhkXTtcblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgKGJ5dGVzW2kgICAgXSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8ICA4KSB8XG4gICAgICAgICAgICAgICAgIGJ5dGVzW2kgKyAzXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBBRVMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdrZXknLCB7XG4gICAgICAgICAgICB2YWx1ZTogY29lcmNlQXJyYXkoa2V5LCB0cnVlKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9wcmVwYXJlKCk7XG4gICAgfVxuXG5cbiAgICBBRVMucHJvdG90eXBlLl9wcmVwYXJlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtleSBzaXplIChtdXN0IGJlIDE2LCAyNCBvciAzMiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuY3J5cHRpb24gcm91bmQga2V5c1xuICAgICAgICB0aGlzLl9LZSA9IFtdO1xuXG4gICAgICAgIC8vIGRlY3J5cHRpb24gcm91bmQga2V5c1xuICAgICAgICB0aGlzLl9LZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJvdW5kczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9LZS5wdXNoKFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICB0aGlzLl9LZC5wdXNoKFswLCAwLCAwLCAwXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm91bmRLZXlDb3VudCA9IChyb3VuZHMgKyAxKSAqIDQ7XG4gICAgICAgIHZhciBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XG5cbiAgICAgICAgLy8gY29udmVydCB0aGUga2V5IGludG8gaW50c1xuICAgICAgICB2YXIgdGsgPSBjb252ZXJ0VG9JbnQzMih0aGlzLmtleSk7XG5cbiAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBLQzsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleCA9IGkgPj4gMjtcbiAgICAgICAgICAgIHRoaXMuX0tlW2luZGV4XVtpICUgNF0gPSB0a1tpXTtcbiAgICAgICAgICAgIHRoaXMuX0tkW3JvdW5kcyAtIGluZGV4XVtpICUgNF0gPSB0a1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICB2YXIgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+ICA4KSAmIDB4RkZdIDw8IDE2KSBeXG4gICAgICAgICAgICAgICAgICAgICAgKFNbIHR0ICAgICAgICAmIDB4RkZdIDw8ICA4KSBeXG4gICAgICAgICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdICAgICAgICBeXG4gICAgICAgICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuXG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXG4gICAgICAgICAgICBpZiAoS0MgIT0gOCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgKEtDIC8gMik7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR0ID0gdGtbKEtDIC8gMikgLSAxXTtcblxuICAgICAgICAgICAgICAgIHRrW0tDIC8gMl0gXj0gKFNbIHR0ICAgICAgICAmIDB4RkZdICAgICAgICBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgIDgpIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAxNikgJiAweEZGXSA8PCAxNikgXlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gKEtDIC8gMikgKyAxOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgICAgIHZhciBpID0gMCwgciwgYztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcbiAgICAgICAgICAgICAgICByID0gdCA+PiAyO1xuICAgICAgICAgICAgICAgIGMgPSB0ICUgNDtcbiAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtjXSA9IHRrW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JvdW5kcyAtIHJdW2NdID0gdGtbaSsrXTtcbiAgICAgICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IHRoaXMuX0tkW3JdW2NdO1xuICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVTJbKHR0ID4+IDE2KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVM1sodHQgPj4gIDgpICYgMHhGRl0gXlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFU0WyB0dCAgICAgICAgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBBRVMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYSA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcbiAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSB0aGlzLl9LZVswXVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcbiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gKFQxWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICAgICAgVDNbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgIFQ0WyB0WyhpICsgMykgJSA0XSAgICAgICAgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXJyYXkoMTYpLCB0dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHR0ID0gdGhpcy5fS2Vbcm91bmRzXVtpXTtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSAgICBdID0gKFNbKHRbIGkgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiAgOCkgJiAweGZmXSBeICh0dCA+PiAgOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNbIHRbKGkgKyAzKSAlIDRdICAgICAgICAmIDB4ZmZdIF4gIHR0ICAgICAgICkgJiAweGZmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBBRVMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYSA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcbiAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gdGhpcy5fS2RbMF1baV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAodmFyIHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFsgaSAgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICAgICAgVDhbIHRbKGkgKyAxKSAlIDRdICAgICAgICAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVBcnJheSgxNiksIHR0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICAgIF0gPSAoU2lbKHRbIGkgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgM10gPSAoU2lbIHRbKGkgKyAxKSAlIDRdICAgICAgICAmIDB4ZmZdIF4gIHR0ICAgICAgICkgJiAweGZmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIEVsZWN0b25pYyBDb2RlYm9vayAoRUNCKVxuICAgICAqL1xuICAgIHZhciBNb2RlT2ZPcGVyYXRpb25FQ0IgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkVDQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiRWxlY3Ryb25pYyBDb2RlIEJsb2NrXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiZWNiXCI7XG5cbiAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuICAgIH1cblxuICAgIE1vZGVPZk9wZXJhdGlvbkVDQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuICAgICAgICBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQpO1xuXG4gICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjcmVhdGVBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY29weUFycmF5KHBsYWludGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG4gICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtcbiAgICAgICAgICAgIGNvcHlBcnJheShibG9jaywgY2lwaGVydGV4dCwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG5cbiAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGNpcGhlcnRleHQgPSBjb2VyY2VBcnJheShjaXBoZXJ0ZXh0KTtcblxuICAgICAgICBpZiAoKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWludGV4dCA9IGNyZWF0ZUFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcbiAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO1xuICAgICAgICAgICAgY29weUFycmF5KGJsb2NrLCBwbGFpbnRleHQsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENpcGhlciBCbG9jayBDaGFpbmluZyAoQ0JDKVxuICAgICAqL1xuICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DQkMgPSBmdW5jdGlvbihrZXksIGl2KSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DQkMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkNpcGhlciBCbG9jayBDaGFpbmluZ1wiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcImNiY1wiO1xuXG4gICAgICAgIGlmICghaXYpIHtcbiAgICAgICAgICAgIGl2ID0gY3JlYXRlQXJyYXkoMTYpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdENpcGhlcmJsb2NrID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcbiAgICB9XG5cbiAgICBNb2RlT2ZPcGVyYXRpb25DQkMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcbiAgICAgICAgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkocGxhaW50ZXh0KTtcblxuICAgICAgICBpZiAoKHBsYWludGV4dC5sZW5ndGggJSAxNikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY3JlYXRlQXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGNvcHlBcnJheShwbGFpbnRleHQsIGJsb2NrLCAwLCBpLCBpICsgMTYpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBibG9ja1tqXSBePSB0aGlzLl9sYXN0Q2lwaGVyYmxvY2tbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RDaXBoZXJibG9jayA9IHRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtcbiAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIGNpcGhlcnRleHQsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuICAgICAgICBjaXBoZXJ0ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCk7XG5cbiAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbGFpbnRleHQgPSBjcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG4gICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5kZWNyeXB0KGJsb2NrKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSA9IGJsb2NrW2pdIF4gdGhpcy5fbGFzdENpcGhlcmJsb2NrW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgdGhpcy5fbGFzdENpcGhlcmJsb2NrLCAwLCBpLCBpICsgMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENpcGhlciBGZWVkYmFjayAoQ0ZCKVxuICAgICAqL1xuICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DRkIgPSBmdW5jdGlvbihrZXksIGl2LCBzZWdtZW50U2l6ZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0ZCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDaXBoZXIgRmVlZGJhY2tcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJjZmJcIjtcblxuICAgICAgICBpZiAoIWl2KSB7XG4gICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBzaXplKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWdtZW50U2l6ZSkgeyBzZWdtZW50U2l6ZSA9IDE7IH1cblxuICAgICAgICB0aGlzLnNlZ21lbnRTaXplID0gc2VnbWVudFNpemU7XG5cbiAgICAgICAgdGhpcy5fc2hpZnRSZWdpc3RlciA9IGNvZXJjZUFycmF5KGl2LCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uQ0ZCLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG4gICAgICAgIHZhciB4b3JTZWdtZW50O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY3J5cHRlZC5sZW5ndGg7IGkgKz0gdGhpcy5zZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgeG9yU2VnbWVudCA9IHRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWRbaSArIGpdIF49IHhvclNlZ21lbnRbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuICAgICAgICAgICAgY29weUFycmF5KHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIDAsIHRoaXMuc2VnbWVudFNpemUpO1xuICAgICAgICAgICAgY29weUFycmF5KGVuY3J5cHRlZCwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMTYgLSB0aGlzLnNlZ21lbnRTaXplLCBpLCBpICsgdGhpcy5zZWdtZW50U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuICAgIH1cblxuICAgIE1vZGVPZk9wZXJhdGlvbkNGQi5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgc2VnbWVudFNpemUgYnl0ZXMpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHhvclNlZ21lbnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSB0aGlzLnNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICB4b3JTZWdtZW50ID0gdGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fc2hpZnRSZWdpc3Rlcik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5zZWdtZW50U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaGlmdCB0aGUgcmVnaXN0ZXJcbiAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9zaGlmdFJlZ2lzdGVyLCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAwLCB0aGlzLnNlZ21lbnRTaXplKTtcbiAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAxNiAtIHRoaXMuc2VnbWVudFNpemUsIGksIGkgKyB0aGlzLnNlZ21lbnRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE1vZGUgT2YgT3BlcmF0aW9uIC0gT3V0cHV0IEZlZWRiYWNrIChPRkIpXG4gICAgICovXG4gICAgdmFyIE1vZGVPZk9wZXJhdGlvbk9GQiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbk9GQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiT3V0cHV0IEZlZWRiYWNrXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwib2ZiXCI7XG5cbiAgICAgICAgaWYgKCFpdikge1xuICAgICAgICAgICAgaXYgPSBjcmVhdGVBcnJheSgxNik7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpdi5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVyID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAxNjtcblxuICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFByZWNpcGhlckluZGV4ID09PSAxNikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5jcnlwdGVkW2ldIF49IHRoaXMuX2xhc3RQcmVjaXBoZXJbdGhpcy5fbGFzdFByZWNpcGhlckluZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuY3J5cHRlZDtcbiAgICB9XG5cbiAgICAvLyBEZWNyeXB0aW9uIGlzIHN5bWV0cmljXG4gICAgTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5kZWNyeXB0ID0gTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0O1xuXG5cbiAgICAvKipcbiAgICAgKiAgQ291bnRlciBvYmplY3QgZm9yIENUUiBjb21tb24gbW9kZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB2YXIgQ291bnRlciA9IGZ1bmN0aW9uKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ291bnRlcikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDb3VudGVyIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFsbG93IDAsIGJ1dCBhbnl0aGluZyBmYWxzZS1pc2ggdXNlcyB0aGUgZGVmYXVsdCAxXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IDAgJiYgIWluaXRpYWxWYWx1ZSkgeyBpbml0aWFsVmFsdWUgPSAxOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbml0aWFsVmFsdWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IGNyZWF0ZUFycmF5KDE2KTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoaW5pdGlhbFZhbHVlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRCeXRlcyhpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ291bnRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gJ251bWJlcicgfHwgcGFyc2VJbnQodmFsdWUpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY291bnRlciB2YWx1ZSAobXVzdCBiZSBhbiBpbnRlZ2VyKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgY2Fubm90IHNhZmVseSBoYW5kbGUgbnVtYmVycyBiZXlvbmQgdGhlIHNhZmUgcmFuZ2UgZm9yIGludGVnZXJzXG4gICAgICAgIGlmICh2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVnZXIgdmFsdWUgb3V0IG9mIHNhZmUgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTU7IGluZGV4ID49IDA7IC0taW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ZXJbaW5kZXhdID0gdmFsdWUgJSAyNTY7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlIC8gMjU2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvdW50ZXIucHJvdG90eXBlLnNldEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBjb2VyY2VBcnJheShieXRlcywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvdW50ZXIgYnl0ZXMgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSBieXRlcztcbiAgICB9O1xuXG4gICAgQ291bnRlci5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyW2ldID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2ldID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnRlcltpXSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDb3VudGVyIChDVFIpXG4gICAgICovXG4gICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNUUiA9IGZ1bmN0aW9uKGtleSwgY291bnRlcikge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ1RSKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDb3VudGVyXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiY3RyXCI7XG5cbiAgICAgICAgaWYgKCEoY291bnRlciBpbnN0YW5jZW9mIENvdW50ZXIpKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoY291bnRlcilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSBjb3VudGVyO1xuXG4gICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAxNjtcblxuICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4ID09PSAxNikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9jb3VudGVyLl9jb3VudGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ZXIuaW5jcmVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNyeXB0ZWRbaV0gXj0gdGhpcy5fcmVtYWluaW5nQ291bnRlclt0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXgrK107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuICAgIH1cblxuICAgIC8vIERlY3J5cHRpb24gaXMgc3ltZXRyaWNcbiAgICBNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmRlY3J5cHQgPSBNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmVuY3J5cHQ7XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUGFkZGluZ1xuXG4gICAgLy8gU2VlOmh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMzE1XG4gICAgZnVuY3Rpb24gcGtjczdwYWQoZGF0YSkge1xuICAgICAgICBkYXRhID0gY29lcmNlQXJyYXkoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwYWRkZXIgPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcbiAgICAgICAgY29weUFycmF5KGRhdGEsIHJlc3VsdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGtjczdzdHJpcChkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBjb2VyY2VBcnJheShkYXRhLCB0cnVlKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTsgfVxuXG4gICAgICAgIHZhciBwYWRkZXIgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChwYWRkZXIgPiAxNikgeyB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlJyk7IH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkZGVyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNvcHlBcnJheShkYXRhLCByZXN1bHQsIDAsIDAsIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBFeHBvcnRpbmdcblxuXG4gICAgLy8gVGhlIGJsb2NrIGNpcGhlclxuICAgIHZhciBhZXNqcyA9IHtcbiAgICAgICAgQUVTOiBBRVMsXG4gICAgICAgIENvdW50ZXI6IENvdW50ZXIsXG5cbiAgICAgICAgTW9kZU9mT3BlcmF0aW9uOiB7XG4gICAgICAgICAgICBlY2I6IE1vZGVPZk9wZXJhdGlvbkVDQixcbiAgICAgICAgICAgIGNiYzogTW9kZU9mT3BlcmF0aW9uQ0JDLFxuICAgICAgICAgICAgY2ZiOiBNb2RlT2ZPcGVyYXRpb25DRkIsXG4gICAgICAgICAgICBvZmI6IE1vZGVPZk9wZXJhdGlvbk9GQixcbiAgICAgICAgICAgIGN0cjogTW9kZU9mT3BlcmF0aW9uQ1RSXG4gICAgICAgIH0sXG5cbiAgICAgICAgdXRpbHM6IHtcbiAgICAgICAgICAgIGhleDogY29udmVydEhleCxcbiAgICAgICAgICAgIHV0Zjg6IGNvbnZlcnRVdGY4XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgcGtjczc6IHtcbiAgICAgICAgICAgICAgICBwYWQ6IHBrY3M3cGFkLFxuICAgICAgICAgICAgICAgIHN0cmlwOiBwa2NzN3N0cmlwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FycmF5VGVzdDoge1xuICAgICAgICAgICAgY29lcmNlQXJyYXk6IGNvZXJjZUFycmF5LFxuICAgICAgICAgICAgY3JlYXRlQXJyYXk6IGNyZWF0ZUFycmF5LFxuICAgICAgICAgICAgY29weUFycmF5OiBjb3B5QXJyYXksXG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyBub2RlLmpzXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFlc2pzXG5cbiAgICAvLyBSZXF1aXJlSlMvQU1EXG4gICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EXG4gICAgfSBlbHNlIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBhZXNqczsgfSk7XG5cbiAgICAvLyBXZWIgQnJvd3NlcnNcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IGF0IFwiYWVzanNcIiBtYWtlIHN1cmUgaXQncyBzdGlsbCBhdmFpbGFibGVcbiAgICAgICAgaWYgKHJvb3QuYWVzanMpIHtcbiAgICAgICAgICAgIGFlc2pzLl9hZXNqcyA9IHJvb3QuYWVzanM7XG4gICAgICAgIH1cblxuICAgICAgICByb290LmFlc2pzID0gYWVzanM7XG4gICAgfVxuXG5cbn0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbnRTaXplID0gNFxudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpXG56ZXJvQnVmZmVyLmZpbGwoMClcblxudmFyIGNoYXJTaXplID0gOFxudmFyIGhhc2hTaXplID0gMTZcblxuZnVuY3Rpb24gdG9BcnJheSAoYnVmKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpXG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKVxuICB9XG5cbiAgdmFyIGFyciA9IG5ldyBBcnJheShidWYubGVuZ3RoID4+PiAyKVxuICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUsIGorKykge1xuICAgIGFycltqXSA9IGJ1Zi5yZWFkSW50MzJMRShpKVxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc2ggKGJ1ZiwgZm4pIHtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmKSwgYnVmLmxlbmd0aCAqIGNoYXJTaXplKVxuICBidWYgPSBuZXcgQnVmZmVyKGhhc2hTaXplKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGJ1Zi53cml0ZUludDMyTEUoYXJyW2ldLCBpIDw8IDIsIHRydWUpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuIiwiJ3VzZSBzdHJpY3QnXG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG52YXIgbWFrZUhhc2ggPSByZXF1aXJlKCcuL21ha2UtaGFzaCcpXG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfbWQ1ICh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMilcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuXG5cbiAgdmFyIGEgPSAxNzMyNTg0MTkzXG4gIHZhciBiID0gLTI3MTczMzg3OVxuICB2YXIgYyA9IC0xNzMyNTg0MTk0XG4gIHZhciBkID0gMjcxNzMzODc4XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIHZhciBvbGRhID0gYVxuICAgIHZhciBvbGRiID0gYlxuICAgIHZhciBvbGRjID0gY1xuICAgIHZhciBvbGRkID0gZFxuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAwXSwgNywgLTY4MDg3NjkzNilcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4NilcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KVxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMClcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KVxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KVxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSlcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKVxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KVxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKVxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MClcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpXG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKVxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKVxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKVxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgMF0sIDIwLCAtMzczODk3MzAyKVxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKVxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSlcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OClcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKVxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKVxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKVxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2NylcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNClcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKVxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2MilcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1NilcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MClcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1MylcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMilcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKVxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAwXSwgMTEsIC0zNTg1MzcyMjIpXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KVxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KVxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKVxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKVxuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyAwXSwgNiwgLTE5ODYzMDg0NClcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSlcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KVxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KVxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KVxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKVxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSlcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKVxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSlcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSlcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKVxuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKVxuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKVxuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKVxuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXVxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbiAocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSwgYilcbn1cblxuZnVuY3Rpb24gbWQ1X2ZmIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KVxufVxuXG5mdW5jdGlvbiBtZDVfZ2cgKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpXG59XG5cbmZ1bmN0aW9uIG1kNV9oaCAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpXG59XG5cbmZ1bmN0aW9uIG1kNV9paSAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdClcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkICh4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRilcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpXG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpXG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGJpdF9yb2wgKG51bSwgY250KSB7XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNSAoYnVmKSB7XG4gIHJldHVybiBtYWtlSGFzaChidWYsIGNvcmVfbWQ1KVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKFxuICAgIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZXNpZ25Nb2RlICYmXG4gICAgZWxlbWVudC5vd25lckRvY3VtZW50LmRlc2lnbk1vZGUudG9Mb3dlckNhc2UoKSA9PT0gJ29uJ1xuICApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJldHVybiBpc0VkaXRhYmxlSW5wdXQoZWxlbWVudClcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZSAoZWxlbWVudCkge1xuICBpZiAoXG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiZcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSdcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoXG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiZcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZS50b0xvd2VyQ2FzZSgpID09PSAnaW5oZXJpdCcgJiZcbiAgICBlbGVtZW50LnBhcmVudE5vZGVcbiAgKSB7XG4gICAgcmV0dXJuIGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQucGFyZW50Tm9kZSlcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaXNFZGl0YWJsZUlucHV0IChpbnB1dCkge1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlICd0ZXh0JzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgY2FzZSAnZW1haWwnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGNhc2UgJ3NlYXJjaCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGNhc2UgJ3RlbCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGNhc2UgJ3VybCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgUmVmbGVjdEFwcGx5KHRoaXMubGlzdGVuZXIsIHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gSGFzaEJhc2UgKGJsb2NrU2l6ZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgdGhpcy5fbGVuZ3RoID0gWzAsIDAsIDAsIDBdXG5cbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoSGFzaEJhc2UsIFRyYW5zZm9ybSlcblxuSGFzaEJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgaWYgKGVuY29kaW5nICE9PSAnYnVmZmVyJykgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZylcbiAgICB0aGlzLnVwZGF0ZShjaHVuaylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnJcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9yKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZGlnZXN0KCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nIHx8ICdiaW5hcnknKVxuXG4gIC8vIGNvbnN1bWUgZGF0YVxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgb2Zmc2V0ID0gMFxuICB3aGlsZSAodGhpcy5fYmxvY2tPZmZzZXQgKyBkYXRhLmxlbmd0aCAtIG9mZnNldCA+PSB0aGlzLl9ibG9ja1NpemUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCB0aGlzLl9ibG9ja1NpemU7KSBibG9ja1tpKytdID0gZGF0YVtvZmZzZXQrK11cbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG4gIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkgYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSBkYXRhW29mZnNldCsrXVxuXG4gIC8vIHVwZGF0ZSBsZW5ndGhcbiAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gZGF0YS5sZW5ndGggKiA4OyBjYXJyeSA+IDA7ICsraikge1xuICAgIHRoaXMuX2xlbmd0aFtqXSArPSBjYXJyeVxuICAgIGNhcnJ5ID0gKHRoaXMuX2xlbmd0aFtqXSAvIDB4MDEwMDAwMDAwMCkgfCAwXG4gICAgaWYgKGNhcnJ5ID4gMCkgdGhpcy5fbGVuZ3RoW2pdIC09IDB4MDEwMDAwMDAwMCAqIGNhcnJ5XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuXG4gIHZhciBkaWdlc3QgPSB0aGlzLl9kaWdlc3QoKVxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuICByZXR1cm4gZGlnZXN0XG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ19kaWdlc3QgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoQmFzZVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyAtIEVyaWMgQmlkZWxtYW5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBBIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBIVE1MNSBGaWxlc3lzdGVtIEFQSSB3aGljaCBzaXRzIG9uIHRvcCBvZlxuICogSW5kZXhlZERCIGFzIHN0b3JhZ2UgbGF5ZXIuIEZpbGVzIGFuZCBmb2xkZXJzIGFyZSBzdG9yZWQgYXMgRmlsZUVudHJ5IGFuZFxuICogRm9sZGVyRW50cnkgb2JqZWN0cyBpbiBhIHNpbmdsZSBvYmplY3Qgc3RvcmUuIElEQktleVJhbmdlcyBhcmUgdXNlZCB0byBxdWVyeVxuICogaW50byBhIGZvbGRlci4gQSBzaW5nbGUgb2JqZWN0IHN0b3JlIGlzIHN1ZmZpY2llbnQgYmVjYXVzZSB3ZSBjYW4gdXRpbGl6ZSB0aGVcbiAqIHByb3BlcnRpZXMgb2YgQVNDSUkuIE5hbWVseSwgQVNDSUkgLyBpcyBmb2xsb3dlZCBieSBBU0NJSSAwLiBUaHVzLFxuICogXCIvb25lL3R3by9cIiBjb21lcyBiZWZvcmUgXCIvb25lL3R3by9BTllUSElOR1wiIGNvbWVzIGJlZm9yZSBcIi9vbmUvdHdvLzBcIi5cbiAqXG4gKiBAYXV0aG9yIEVyaWMgQmlkZWxtYW4gKGViaWRlbEBnbWFpbC5jb20pXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4oZnVuY3Rpb24oZXhwb3J0cykge1xuXG4vLyBCb21iIG91dCBpZiB0aGUgRmlsZXN5c3RlbSBBUEkgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LlxuaWYgKGV4cG9ydHMucmVxdWVzdEZpbGVTeXN0ZW0gfHwgZXhwb3J0cy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbSkge1xuICByZXR1cm47XG59XG5cbi8vIEJvbWIgb3V0IGlmIG5vIGluZGV4ZWREQiBhdmFpbGFibGVcbmNvbnN0IGluZGV4ZWREQiA9IGV4cG9ydHMuaW5kZXhlZERCIHx8IGV4cG9ydHMubW96SW5kZXhlZERCIHx8XG4gICAgICAgICAgICAgICAgICBleHBvcnRzLm1zSW5kZXhlZERCO1xuaWYgKCFpbmRleGVkREIpIHtcbiAgcmV0dXJuO1xufVxuXG5sZXQgSURCX1NVUFBPUlRTX0JMT0IgPSB0cnVlO1xuXG4vLyBDaGVjayB0byBzZWUgaWYgSW5kZXhlZERCIHN1cHBvcnQgYmxvYnMuXG5jb25zdCBzdXBwb3J0ID0gbmV3IGZ1bmN0aW9uKCkge1xuICB2YXIgZGJOYW1lID0gXCJibG9iLXN1cHBvcnRcIjtcbiAgaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiTmFtZSkub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihkYk5hbWUsIDEpO1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgSURCX1NVUFBPUlRTX0JMT0IgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW1widGVzdFwiXSwge3R5cGU6IFwidGV4dC9wbGFpblwifSk7XG4gICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFwic3RvcmVcIiwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgIHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFwic3RvcmVcIikucHV0KGJsb2IsIFwia2V5XCIpO1xuICAgICAgICBJREJfU1VQUE9SVFNfQkxPQiA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgSURCX1NVUFBPUlRTX0JMT0IgPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgIGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVzdWx0LmNyZWF0ZU9iamVjdFN0b3JlKFwic3RvcmVcIik7XG4gICAgfTtcbiAgfTtcbn07XG5cbmNvbnN0IEJhc2U2NFRvQmxvYiA9IGZ1bmN0aW9uKGRhdGFVUkwpIHtcbiAgdmFyIEJBU0U2NF9NQVJLRVIgPSAnO2Jhc2U2NCwnO1xuICBpZiAoZGF0YVVSTC5pbmRleE9mKEJBU0U2NF9NQVJLRVIpID09IC0xKSB7XG4gICAgdmFyIHBhcnRzID0gZGF0YVVSTC5zcGxpdCgnLCcpO1xuICAgIHZhciBjb250ZW50VHlwZSA9IHBhcnRzWzBdLnNwbGl0KCc6JylbMV07XG4gICAgdmFyIHJhdyA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW3Jhd10sIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gZGF0YVVSTC5zcGxpdChCQVNFNjRfTUFSS0VSKTtcbiAgdmFyIGNvbnRlbnRUeXBlID0gcGFydHNbMF0uc3BsaXQoJzonKVsxXTtcbiAgdmFyIHJhdyA9IHdpbmRvdy5hdG9iKHBhcnRzWzFdKTtcbiAgdmFyIHJhd0xlbmd0aCA9IHJhdy5sZW5ndGg7XG5cbiAgdmFyIHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShyYXdMZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3TGVuZ3RoOyArK2kpIHtcbiAgICB1SW50OEFycmF5W2ldID0gcmF3LmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoW3VJbnQ4QXJyYXldLCB7dHlwZTogY29udGVudFR5cGV9KTtcbn07XG5cbmNvbnN0IEJsb2JUb0Jhc2U2NCA9IGZ1bmN0aW9uKGJsb2IsIG9ubG9hZCkge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICBvbmxvYWQocmVhZGVyLnJlc3VsdCk7XG4gIH07XG59O1xuXG5pZiAoIWV4cG9ydHMuUEVSU0lTVEVOVCkge1xuICBleHBvcnRzLlRFTVBPUkFSWSA9IDA7XG4gIGV4cG9ydHMuUEVSU0lTVEVOVCA9IDE7XG59XG5cbi8vIFByZXZlbnQgZXJyb3JzIGluIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBGaWxlRXJyb3IuXG4vLyBUT0RPOiBGRiAxMysgc3VwcG9ydHMgRE9NNCBFdmVudHMgKERPTUVycm9yKS4gVXNlIHRoZW0gaW5zdGVhZD9cbmlmIChleHBvcnRzLkZpbGVFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gIHdpbmRvdy5GaWxlRXJyb3IgPSBmdW5jdGlvbigpIHt9O1xuICBGaWxlRXJyb3IucHJvdG90eXBlLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbn1cblxuaWYgKCFGaWxlRXJyb3IuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSKSB7XG4gIEZpbGVFcnJvci5JTlZBTElEX01PRElGSUNBVElPTl9FUlIgPSA5O1xuICBGaWxlRXJyb3IuTk9UX0ZPVU5EX0VSUiAgPSAxO1xufVxuXG5mdW5jdGlvbiBNeUZpbGVFcnJvcihvYmopIHtcbiAgdmFyIGNvZGVfID0gb2JqLmNvZGU7XG4gIHZhciBuYW1lXyA9IG9iai5uYW1lO1xuXG4gICAgLy8gUmVxdWlyZWQgZm9yIEZGIDExLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgc2V0OiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICBjb2RlXyA9IGNvZGU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvZGVfO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgIHNldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgbmFtZV8gPSBuYW1lO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuYW1lXztcbiAgICB9XG4gIH0pO1xufVxuXG5NeUZpbGVFcnJvci5wcm90b3R5cGUgPSBGaWxlRXJyb3IucHJvdG90eXBlO1xuTXlGaWxlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5jb25zdCBJTlZBTElEX01PRElGSUNBVElPTl9FUlIgPSBuZXcgTXlGaWxlRXJyb3Ioe1xuICAgICAgY29kZTogRmlsZUVycm9yLklOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUixcbiAgICAgIG5hbWU6ICdJTlZBTElEX01PRElGSUNBVElPTl9FUlInfSk7XG5jb25zdCBOT1RfSU1QTEVNRU5URURfRVJSID0gbmV3IE15RmlsZUVycm9yKHtjb2RlOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ05vdCBpbXBsZW1lbnRlZCd9KTtcbmNvbnN0IE5PVF9GT1VORF9FUlIgPSBuZXcgTXlGaWxlRXJyb3Ioe2NvZGU6IEZpbGVFcnJvci5OT1RfRk9VTkRfRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ05vdCBmb3VuZCd9KTtcblxubGV0IGZzXyA9IG51bGw7XG5cbi8vIEJyb3dzZXJzIG90aGVyIHRoYW4gQ2hyb21lIGRvbid0IGltcGxlbWVudCBwZXJzaXN0ZW50IHZzLiB0ZW1wb3Jhcnkgc3RvcmFnZS5cbi8vIGJ1dCBkZWZhdWx0IHRvIHRlbXBvcmFyeSBhbnl3YXkuXG5sZXQgc3RvcmFnZVR5cGVfID0gJ3RlbXBvcmFyeSc7XG5jb25zdCBpZGJfID0ge2RiOiBudWxsfTtcbmNvbnN0IEZJTEVfU1RPUkVfID0gJ2VudHJpZXMnO1xuXG5jb25zdCBESVJfU0VQQVJBVE9SID0gJy8nO1xuY29uc3QgRElSX09QRU5fQk9VTkQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKERJUl9TRVBBUkFUT1IuY2hhckNvZGVBdCgwKSArIDEpO1xuXG4vLyBXaGVuIHNhdmluZyBhbiBlbnRyeSwgdGhlIGZ1bGxQYXRoIHNob3VsZCBhbHdheXMgbGVhZCB3aXRoIGEgc2xhc2ggYW5kIG5ldmVyXG4vLyBlbmQgd2l0aCBvbmUgKGUuZy4gYSBkaXJlY3RvcnkpLiBBbHNvLCByZXNvbHZlICcuJyBhbmQgJy4uJyB0byBhbiBhYnNvbHV0ZVxuLy8gb25lLiBUaGlzIG1ldGhvZCBlbnN1cmVzIHBhdGggaXMgbGVnaXQhXG5mdW5jdGlvbiByZXNvbHZlVG9GdWxsUGF0aF8oY3dkRnVsbFBhdGgsIHBhdGgpIHtcbiAgdmFyIGZ1bGxQYXRoID0gcGF0aDtcblxuICB2YXIgcmVsYXRpdmVQYXRoID0gcGF0aFswXSAhPSBESVJfU0VQQVJBVE9SO1xuICBpZiAocmVsYXRpdmVQYXRoKSB7XG4gICAgZnVsbFBhdGggPSBjd2RGdWxsUGF0aCArIERJUl9TRVBBUkFUT1IgKyBwYXRoO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplICcuJ3MsICAnLi4ncyBhbmQgJy8vJ3MuXG4gIHZhciBwYXJ0cyA9IGZ1bGxQYXRoLnNwbGl0KERJUl9TRVBBUkFUT1IpO1xuICB2YXIgZmluYWxQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgLy8gR28gdXAgb25lIGxldmVsLlxuICAgICAgaWYgKCFmaW5hbFBhcnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBwYXRoJyk7XG4gICAgICB9XG4gICAgICBmaW5hbFBhcnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAvLyBTa2lwIG92ZXIgdGhlIGN1cnJlbnQgZGlyZWN0b3J5LlxuICAgIH0gZWxzZSBpZiAocGFydCAhPT0gJycpIHtcbiAgICAgIC8vIEVsaW1pbmF0ZSBzZXF1ZW5jZXMgb2YgJy8ncyBhcyB3ZWxsIGFzIHBvc3NpYmxlIGxlYWRpbmcvdHJhaWxpbmcgJy8ncy5cbiAgICAgIGZpbmFsUGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICBmdWxsUGF0aCA9IERJUl9TRVBBUkFUT1IgKyBmaW5hbFBhcnRzLmpvaW4oRElSX1NFUEFSQVRPUik7XG5cbiAgLy8gZnVsbFBhdGggaXMgZ3VhcmFudGVlZCB0byBiZSBub3JtYWxpemVkIGJ5IGNvbnN0cnVjdGlvbiBhdCB0aGlzIHBvaW50OlxuICAvLyAnLidzLCAnLi4ncywgJy8vJ3Mgd2lsbCBuZXZlciBhcHBlYXIgaW4gaXQuXG5cbiAgcmV0dXJuIGZ1bGxQYXRoO1xufVxuXG4vLyAvLyBQYXRoIGNhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS4gSWYgcmVsYXRpdmUsIGl0J3MgdGFrZW4gZnJvbSB0aGUgY3dkXy5cbi8vIC8vIElmIGEgZmlsZXN5c3RlbSBVUkwgaXMgcGFzc2VkIGl0LCBpdCBpcyBzaW1wbGUgcmV0dXJuZWRcbi8vIGZ1bmN0aW9uIHBhdGhUb0ZzVVJMXyhwYXRoKSB7XG4vLyAgIHBhdGggPSByZXNvbHZlVG9GdWxsUGF0aF8oY3dkRnVsbFBhdGgsIHBhdGgpO1xuLy8gICBwYXRoID0gZnNfLnJvb3QudG9VUkwoKSArIHBhdGguc3Vic3RyaW5nKDEpO1xuLy8gICByZXR1cm4gcGF0aDtcbi8vIH07XG5cbi8qKlxuICogSW50ZXJmYWNlIHRvIHdyYXAgdGhlIG5hdGl2ZSBGaWxlIGludGVyZmFjZS5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBuZWNlc3NhcnkgZm9yIGNyZWF0aW5nIHplcm8tbGVuZ3RoIChlbXB0eSkgZmlsZXMsXG4gKiBzb21ldGhpbmcgdGhlIEZpbGVzeXN0ZW0gQVBJIGFsbG93cyB5b3UgdG8gZG8uIFVuZm9ydHVuYXRlbHksIEZpbGUnc1xuICogY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseSwgbWFraW5nIGl0IGltcG9zc2libGUgdG8gaW5zdGFudGlhdGVcbiAqIGFuIGVtcHR5IEZpbGUgaW4gSlMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgSW5pdGlhbCB2YWx1ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTXlGaWxlKG9wdHMpIHtcbiAgdmFyIGJsb2JfID0gbnVsbDtcblxuICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgMDtcbiAgdGhpcy5uYW1lID0gb3B0cy5uYW1lIHx8ICcnO1xuICB0aGlzLnR5cGUgPSBvcHRzLnR5cGUgfHwgJyc7XG4gIHRoaXMubGFzdE1vZGlmaWVkRGF0ZSA9IG9wdHMubGFzdE1vZGlmaWVkRGF0ZSB8fCBudWxsO1xuICAvL3RoaXMuc2xpY2UgPSBCbG9iLnByb3RvdHlwZS5zbGljZTsgLy8gRG9lc24ndCB3b3JrIHdpdGggc3RydWN0dXJlZCBjbG9uZXMuXG5cbiAgLy8gTmVlZCBzb21lIGJsYWNrIG1hZ2ljIHRvIGNvcnJlY3QgdGhlIG9iamVjdCdzIHNpemUvbmFtZS90eXBlIGJhc2VkIG9uIHRoZVxuICAvLyBibG9iIHRoYXQgaXMgc2F2ZWQuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYmxvYl8nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGJsb2JfO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBibG9iXyA9IHZhbDtcbiAgICAgIHRoaXMuc2l6ZSA9IGJsb2JfLnNpemU7XG4gICAgICB0aGlzLm5hbWUgPSBibG9iXy5uYW1lO1xuICAgICAgdGhpcy50eXBlID0gYmxvYl8udHlwZTtcbiAgICAgIHRoaXMubGFzdE1vZGlmaWVkRGF0ZSA9IGJsb2JfLmxhc3RNb2RpZmllZERhdGU7XG4gICAgfS5iaW5kKHRoaXMpXG4gIH0pO1xufVxuTXlGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE15RmlsZTtcbi8vTXlGaWxlLnByb3RvdHlwZS5zbGljZSA9IEJsb2IucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIEludGVyZmFjZSB0byB3cml0aW5nIGEgQmxvYi9GaWxlLlxuICpcbiAqIE1vZGVsZWQgZnJvbTpcbiAqIGRldi53My5vcmcvMjAwOS9kYXAvZmlsZS1zeXN0ZW0vZmlsZS13cml0ZXIuaHRtbCN0aGUtZmlsZXdyaXRlci1pbnRlcmZhY2VcbiAqXG4gKiBAcGFyYW0ge0ZpbGVFbnRyeX0gZmlsZUVudHJ5IFRoZSBGaWxlRW50cnkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd3JpdGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGVXcml0ZXIoZmlsZUVudHJ5KSB7XG4gIGlmICghZmlsZUVudHJ5KSB7XG4gICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGZpbGVFbnRyeSBhcmd1bWVudCB0byB3cml0ZS4nKTtcbiAgfVxuXG4gIHZhciBwb3NpdGlvbl8gPSAwO1xuICB2YXIgYmxvYl8gPSBmaWxlRW50cnkuZmlsZV8gPyBmaWxlRW50cnkuZmlsZV8uYmxvYl8gOiBudWxsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncG9zaXRpb24nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbl87XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xlbmd0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGJsb2JfID8gYmxvYl8uc2l6ZSA6IDA7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnNlZWsgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICBwb3NpdGlvbl8gPSBvZmZzZXQ7XG5cbiAgICBpZiAocG9zaXRpb25fID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHBvc2l0aW9uXyA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb25fIDwgMCkge1xuICAgICAgcG9zaXRpb25fICs9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb25fIDwgMCkge1xuICAgICAgcG9zaXRpb25fID0gMDtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy50cnVuY2F0ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICBpZiAoYmxvYl8pIHtcbiAgICAgIGlmIChzaXplIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgYmxvYl8gPSBibG9iXy5zbGljZSgwLCBzaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2JfID0gbmV3IEJsb2IoW2Jsb2JfLCBuZXcgVWludDhBcnJheShzaXplIC0gdGhpcy5sZW5ndGgpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogYmxvYl8udHlwZX0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBibG9iXyA9IG5ldyBCbG9iKFtdKTtcbiAgICB9XG5cbiAgICBwb3NpdGlvbl8gPSAwOyAvLyB0cnVuY2F0ZSBmcm9tIGJlZ2lubmluZyBvZiBmaWxlLlxuXG4gICAgdGhpcy53cml0ZShibG9iXyk7IC8vIGNhbGxzIG9ud3JpdGVzdGFydCBhbmQgb253cml0ZWVuZC5cbiAgfTtcblxuICB0aGlzLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGJsb2IgYXJndW1lbnQgdG8gd3JpdGUuJyk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBvbndyaXRlc3RhcnQgaWYgaXQgd2FzIGRlZmluZWQuXG4gICAgaWYgKHRoaXMub253cml0ZXN0YXJ0KSB7XG4gICAgICB0aGlzLm9ud3JpdGVzdGFydCgpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG5vdCBoYW5kbGluZyBvbnByb2dyZXNzLCBvbndyaXRlLCBvbmFib3J0LiBUaHJvdyBhbiBlcnJvciBpZlxuICAgIC8vIHRoZXkncmUgZGVmaW5lZC5cblxuICAgIGlmIChibG9iXykge1xuICAgICAgLy8gQ2FsYyB0aGUgaGVhZCBhbmQgdGFpbCBmcmFnbWVudHNcbiAgICAgIHZhciBoZWFkID0gYmxvYl8uc2xpY2UoMCwgcG9zaXRpb25fKTtcbiAgICAgIHZhciB0YWlsID0gYmxvYl8uc2xpY2UocG9zaXRpb25fICsgZGF0YS5zaXplKTtcblxuICAgICAgLy8gQ2FsYyB0aGUgcGFkZGluZ1xuICAgICAgdmFyIHBhZGRpbmcgPSBwb3NpdGlvbl8gLSBoZWFkLnNpemU7XG4gICAgICBpZiAocGFkZGluZyA8IDApIHtcbiAgICAgICAgcGFkZGluZyA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHRoZSBcIndyaXRlXCIuIEluIGZhY3QsIGEgZnVsbCBvdmVyd3JpdGUgb2YgdGhlIEJsb2IuXG4gICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGlmIGRhdGEudHlwZSBzaG91bGQgb3ZlcndyaXRlIHRoZSBleGlzdCBibG9iJ3MgdHlwZS5cbiAgICAgIGJsb2JfID0gbmV3IEJsb2IoW2hlYWQsIG5ldyBVaW50OEFycmF5KHBhZGRpbmcpLCBkYXRhLCB0YWlsXSxcbiAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6IGJsb2JfLnR5cGV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmxvYl8gPSBuZXcgQmxvYihbZGF0YV0sIHt0eXBlOiBkYXRhLnR5cGV9KTtcbiAgICB9XG5cbiAgICBjb25zdCB3cml0ZUZpbGUgPSBmdW5jdGlvbihibG9iKSB7XG4gICAgICAvLyBCbG9iIG1pZ2h0IGJlIGEgRGF0YVVSSSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxuICAgICAgZmlsZUVudHJ5LmZpbGVfLmJsb2JfID0gYmxvYjtcbiAgICAgIGZpbGVFbnRyeS5maWxlXy5sYXN0TW9kaWZpZWREYXRlID0gZGF0YS5sYXN0TW9kaWZpZWREYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgICBpZGJfLnB1dChmaWxlRW50cnksIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIGlmICghSURCX1NVUFBPUlRTX0JMT0IpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIGJsb2Igd2UncmUgd3JpdGluZyBvbiB0aGlzIGZpbGUgZW50cnkgc28gd2UgY2FuIHJlY2FsbCBpdCBsYXRlci5cbiAgICAgICAgICBmaWxlRW50cnkuZmlsZV8uYmxvYl8gPSBibG9iXztcbiAgICAgICAgICBmaWxlRW50cnkuZmlsZV8ubGFzdE1vZGlmaWVkRGF0ZSA9IGRhdGEubGFzdE1vZGlmaWVkRGF0ZSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHNpemUgb2YgZGF0YSB3cml0dGVuIHRvIHdyaXRlci5wb3NpdGlvbi5cbiAgICAgICAgcG9zaXRpb25fICs9IGRhdGEuc2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5vbndyaXRlZW5kKSB7XG4gICAgICAgICAgdGhpcy5vbndyaXRlZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vbmVycm9yKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAoSURCX1NVUFBPUlRTX0JMT0IpIHtcbiAgICAgIHdyaXRlRmlsZShibG9iXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEJsb2JUb0Jhc2U2NChibG9iXywgd3JpdGVGaWxlKTtcbiAgICB9XG4gIH07XG59XG5cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGxpc3RpbmcgYSBkaXJlY3RvcnkncyBjb250ZW50cyAoZmlsZXMgYW5kIGZvbGRlcnMpLlxuICpcbiAqIE1vZGVsZWQgZnJvbTpcbiAqIGRldi53My5vcmcvMjAwOS9kYXAvZmlsZS1zeXN0ZW0vcHViL0ZpbGVTeXN0ZW0vI2lkbC1kZWYtRGlyZWN0b3J5UmVhZGVyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERpcmVjdG9yeVJlYWRlcihkaXJFbnRyeSkge1xuICB2YXIgZGlyRW50cnlfID0gZGlyRW50cnk7XG4gIHZhciB1c2VkXyA9IGZhbHNlO1xuXG4gIHRoaXMucmVhZEVudHJpZXMgPSBmdW5jdGlvbihzdWNjZXNzQ2FsbGJhY2ssIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKCFzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgIHRocm93IEVycm9yKCdFeHBlY3RlZCBzdWNjZXNzQ2FsbGJhY2sgYXJndW1lbnQuJyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gbWltaWMgdGhlIHdheSBEaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoKSBzaG91bGRcbiAgICAvLyBub3JtYWxseSBiZWhhdmlvci4gIEFjY29yZGluZyB0byBzcGVjLCByZWFkRW50cmllcygpIG5lZWRzIHRvIGJlIGNhbGxlZFxuICAgIC8vIHVudGlsIHRoZSBsZW5ndGggb2YgcmVzdWx0IGFycmF5IGlzIDAuIFRvIGhhbmRsZSBzb21lb25lIGltcGxlbWVudGluZ1xuICAgIC8vIGEgcmVjdXJzaXZlIGNhbGwgdG8gcmVhZEVudHJpZXMoKSwgZ2V0IGV2ZXJ5dGhpbmcgZnJvbSBpbmRleGVkREIgb24gdGhlXG4gICAgLy8gZmlyc3Qgc2hvdC4gVGhlbiAoRGlyZWN0b3J5UmVhZGVyIGhhcyBiZWVuIHVzZWQpLCByZXR1cm4gYW4gZW1wdHlcbiAgICAvLyByZXN1bHQgYXJyYXkuXG4gICAgaWYgKCF1c2VkXykge1xuICAgICAgaWRiXy5nZXRBbGxFbnRyaWVzKGRpckVudHJ5Xy5mdWxsUGF0aCwgZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICB1c2VkXz0gdHJ1ZTtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKGVudHJpZXMpO1xuICAgICAgfSwgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZXNzQ2FsbGJhY2soW10pO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogSW50ZXJmYWNlIHN1cHBsaWVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGF0ZSBvZiBhIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIE1vZGVsZWQgZnJvbTpcbiAqIGRldi53My5vcmcvMjAwOS9kYXAvZmlsZS1zeXN0ZW0vZmlsZS1kaXItc3lzLmh0bWwjaWRsLWRlZi1NZXRhZGF0YVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNZXRhZGF0YShtb2RpZmljYXRpb25UaW1lLCBzaXplKSB7XG4gIHRoaXMubW9kaWZpY2F0aW9uVGltZV8gPSBtb2RpZmljYXRpb25UaW1lIHx8IG51bGw7XG4gIHRoaXMuc2l6ZV8gPSBzaXplIHx8IDA7XG59XG5cbk1ldGFkYXRhLnByb3RvdHlwZSA9IHtcbiAgZ2V0IG1vZGlmaWNhdGlvblRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kaWZpY2F0aW9uVGltZV87XG4gIH0sXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVfO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyBlbnRyaWVzIGluIGEgZmlsZXN5c3RlbSwgZWFjaCBvZiB3aGljaCBtYXkgYmUgYSBGaWxlXG4gKiBvciBEaXJlY3RvcnlFbnRyeS5cbiAqXG4gKiBNb2RlbGVkIGZyb206XG4gKiBkZXYudzMub3JnLzIwMDkvZGFwL2ZpbGUtc3lzdGVtL3B1Yi9GaWxlU3lzdGVtLyNpZGwtZGVmLUVudHJ5XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVudHJ5KCkge31cblxuRW50cnkucHJvdG90eXBlID0ge1xuICBuYW1lOiBudWxsLFxuICBmdWxsUGF0aDogbnVsbCxcbiAgZmlsZXN5c3RlbTogbnVsbCxcbiAgY29weVRvOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBOT1RfSU1QTEVNRU5URURfRVJSO1xuICB9LFxuICBnZXRNZXRhZGF0YTogZnVuY3Rpb24oc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICAgIGlmICghc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBFcnJvcignRXhwZWN0ZWQgc3VjY2Vzc0NhbGxiYWNrIGFyZ3VtZW50LicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5pc0ZpbGUpIHtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKFxuICAgICAgICAgICAgbmV3IE1ldGFkYXRhKHRoaXMuZmlsZV8ubGFzdE1vZGlmaWVkRGF0ZSwgdGhpcy5maWxlXy5zaXplKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRfZXJyb3JDYWxsYmFjayhuZXcgTXlGaWxlRXJyb3Ioe2NvZGU6IDEwMDEsXG4gICAgICAgICAgICBuYW1lOiAnZ2V0TWV0YWRhdGEoKSBub3QgaW1wbGVtZW50ZWQgZm9yIERpcmVjdG9yeUVudHJ5J30pKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIG9wdF9lcnJvckNhbGxiYWNrICYmIG9wdF9lcnJvckNhbGxiYWNrKGUpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBOT1RfSU1QTEVNRU5URURfRVJSO1xuICB9LFxuICBtb3ZlVG86IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IE5PVF9JTVBMRU1FTlRFRF9FUlI7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICAgIGlmICghc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBFcnJvcignRXhwZWN0ZWQgc3VjY2Vzc0NhbGxiYWNrIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgcHJvdGVjdCBhZ2FpbnN0IGRpcmVjdG9yaWVzIHRoYXQgaGF2ZSBjb250ZW50IGluIGl0LlxuICAgIC8vIFNob3VsZCB0aHJvdyBhbiBlcnJvciBpbnN0ZWFkIGlmIHRoZSBkaXJFbnRyeSBpcyBub3QgZW1wdHkuXG4gICAgaWRiX1snZGVsZXRlJ10odGhpcy5mdWxsUGF0aCwgZnVuY3Rpb24oKSB7XG4gICAgICBzdWNjZXNzQ2FsbGJhY2soKTtcbiAgICB9LCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIH0sXG4gIHRvVVJMOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luID0gbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdDtcbiAgICByZXR1cm4gJ2ZpbGVzeXN0ZW06JyArIG9yaWdpbiArIERJUl9TRVBBUkFUT1IgKyBzdG9yYWdlVHlwZV8udG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgIHRoaXMuZnVsbFBhdGg7XG4gIH0sXG59O1xuXG4vKipcbiAqIEludGVyZmFjZSByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSBmaWxlc3lzdGVtLlxuICpcbiAqIE1vZGVsZWQgZnJvbTpcbiAqIGRldi53My5vcmcvMjAwOS9kYXAvZmlsZS1zeXN0ZW0vcHViL0ZpbGVTeXN0ZW0vI3RoZS1maWxlZW50cnktaW50ZXJmYWNlXG4gKlxuICogQHBhcmFtIHtGaWxlRW50cnl9IG9wdF9maWxlRW50cnkgT3B0aW9uYWwgRmlsZUVudHJ5IHRvIGluaXRpYWxpemUgdGhpc1xuICogICAgIG9iamVjdCBmcm9tLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RW50cnl9XG4gKi9cbmZ1bmN0aW9uIEZpbGVFbnRyeShvcHRfZmlsZUVudHJ5KSB7XG4gIHRoaXMuZmlsZV8gPSBudWxsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNGaWxlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNEaXJlY3RvcnknLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoaXMgZW50cnkgZnJvbSBwcm9wZXJ0aWVzIGZyb20gYW4gZXhpc3RpbmcgRmlsZUVudHJ5LlxuICBpZiAob3B0X2ZpbGVFbnRyeSkge1xuICAgIHRoaXMuZmlsZV8gPSBvcHRfZmlsZUVudHJ5LmZpbGVfO1xuICAgIHRoaXMubmFtZSA9IG9wdF9maWxlRW50cnkubmFtZTtcbiAgICB0aGlzLmZ1bGxQYXRoID0gb3B0X2ZpbGVFbnRyeS5mdWxsUGF0aDtcbiAgICB0aGlzLmZpbGVzeXN0ZW0gPSBvcHRfZmlsZUVudHJ5LmZpbGVzeXN0ZW07XG4gICAgaWYgKHR5cGVvZih0aGlzLmZpbGVfLmJsb2JfKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5maWxlXy5ibG9iXyA9IEJhc2U2NFRvQmxvYih0aGlzLmZpbGVfLmJsb2JfKTtcbiAgICB9XG4gIH1cbn1cbkZpbGVFbnRyeS5wcm90b3R5cGUgPSBuZXcgRW50cnkoKTtcbkZpbGVFbnRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWxlRW50cnk7XG5GaWxlRW50cnkucHJvdG90eXBlLmNyZWF0ZVdyaXRlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgaWYgdGhlcmUncyBhIHdheSB0byBkaXNwYXRjaCBvbndyaXRlIGV2ZW50IGFzIHdlJ3JlIHdyaXRpbmdcbiAgLy8gZGF0YSB0byBJREIuIFJpZ2h0IG5vdywgd2UncmUgb25seSBjYWxsaW5nIG9ud3JpdGVuZC9vbmVycm9yXG4gIC8vIEZpbGVFbnRyeS53cml0ZSgpLlxuICBjYWxsYmFjayhuZXcgRmlsZVdyaXRlcih0aGlzKSk7XG59O1xuRmlsZUVudHJ5LnByb3RvdHlwZS5maWxlID0gZnVuY3Rpb24oc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICBpZiAoIXN1Y2Nlc3NDYWxsYmFjaykge1xuICAgIHRocm93IEVycm9yKCdFeHBlY3RlZCBzdWNjZXNzQ2FsbGJhY2sgYXJndW1lbnQuJyk7XG4gIH1cblxuICBpZiAodGhpcy5maWxlXyA9PSBudWxsKSB7XG4gICAgaWYgKG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gICAgICBvcHRfZXJyb3JDYWxsYmFjayhOT1RfRk9VTkRfRVJSKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgTk9UX0ZPVU5EX0VSUjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgcmV0dXJuaW5nIGEgemVyby1sZW5ndGggKGVtcHR5KSBmaWxlLCByZXR1cm4gdGhlIGZha2UgZmlsZSBvYmouXG4gIC8vIE90aGVyd2lzZSwgcmV0dXJuIHRoZSBuYXRpdmUgRmlsZSBvYmplY3QgdGhhdCB3ZSd2ZSBzdGFzaGVkLlxuICB2YXIgZmlsZSA9IHRoaXMuZmlsZV8uYmxvYl8gPT0gbnVsbCA/IHRoaXMuZmlsZV8gOiB0aGlzLmZpbGVfLmJsb2JfO1xuICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSB0aGlzLmZpbGVfLmxhc3RNb2RpZmllZERhdGU7XG5cbiAgLy8gQWRkIEJsb2Iuc2xpY2UoKSB0byB0aGlzIHdyYXBwZWQgb2JqZWN0LiBDdXJyZW50bHkgd29uJ3Qgd29yayA6KFxuICAvKmlmICghdmFsLnNsaWNlKSB7XG4gICAgdmFsLnNsaWNlID0gQmxvYi5wcm90b3R5cGUuc2xpY2U7IC8vIEhhY2sgdG8gYWRkIGJhY2sgaW4gLnNsaWNlKCkuXG4gIH0qL1xuICBzdWNjZXNzQ2FsbGJhY2soZmlsZSk7XG59O1xuXG4vKipcbiAqIEludGVyZmFjZSByZXByZXNlbnRpbmcgYSBkaXJlY3RvcnkgaW4gdGhlIGZpbGVzeXN0ZW0uXG4gKlxuICogTW9kZWxlZCBmcm9tOlxuICogZGV2LnczLm9yZy8yMDA5L2RhcC9maWxlLXN5c3RlbS9wdWIvRmlsZVN5c3RlbS8jdGhlLWRpcmVjdG9yeWVudHJ5LWludGVyZmFjZVxuICpcbiAqIEBwYXJhbSB7RGlyZWN0b3J5RW50cnl9IG9wdF9mb2xkZXJFbnRyeSBPcHRpb25hbCBEaXJlY3RvcnlFbnRyeSB0b1xuICogICAgIGluaXRpYWxpemUgdGhpcyBvYmplY3QgZnJvbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0VudHJ5fVxuICovXG5mdW5jdGlvbiBEaXJlY3RvcnlFbnRyeShvcHRfZm9sZGVyRW50cnkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpc0ZpbGUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNEaXJlY3RvcnknLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhpcyBlbnRyeSBmcm9tIHByb3BlcnRpZXMgZnJvbSBhbiBleGlzdGluZyBEaXJlY3RvcnlFbnRyeS5cbiAgaWYgKG9wdF9mb2xkZXJFbnRyeSkge1xuICAgIHRoaXMubmFtZSA9IG9wdF9mb2xkZXJFbnRyeS5uYW1lO1xuICAgIHRoaXMuZnVsbFBhdGggPSBvcHRfZm9sZGVyRW50cnkuZnVsbFBhdGg7XG4gICAgdGhpcy5maWxlc3lzdGVtID0gb3B0X2ZvbGRlckVudHJ5LmZpbGVzeXN0ZW07XG4gIH1cbn1cbkRpcmVjdG9yeUVudHJ5LnByb3RvdHlwZSA9IG5ldyBFbnRyeSgpO1xuRGlyZWN0b3J5RW50cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0b3J5RW50cnk7XG5EaXJlY3RvcnlFbnRyeS5wcm90b3R5cGUuY3JlYXRlUmVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGlyZWN0b3J5UmVhZGVyKHRoaXMpO1xufTtcbkRpcmVjdG9yeUVudHJ5LnByb3RvdHlwZS5nZXREaXJlY3RvcnkgPSBmdW5jdGlvbihwYXRoLCBvcHRpb25zLCBzdWNjZXNzQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0X2Vycm9yQ2FsbGJhY2spIHtcblxuICAvLyBDcmVhdGUgYW4gYWJzb2x1dGUgcGF0aCBpZiB3ZSB3ZXJlIGhhbmRlZCBhIHJlbGF0aXZlIG9uZS5cbiAgcGF0aCA9IHJlc29sdmVUb0Z1bGxQYXRoXyh0aGlzLmZ1bGxQYXRoLCBwYXRoKTtcblxuICBpZGJfLmdldChwYXRoLCBmdW5jdGlvbihmb2xkZXJFbnRyeSkge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZSA9PT0gdHJ1ZSAmJiBvcHRpb25zLmV4Y2x1c2l2ZSA9PT0gdHJ1ZSAmJiBmb2xkZXJFbnRyeSkge1xuICAgICAgLy8gSWYgY3JlYXRlIGFuZCBleGNsdXNpdmUgYXJlIGJvdGggdHJ1ZSwgYW5kIHRoZSBwYXRoIGFscmVhZHkgZXhpc3RzLFxuICAgICAgLy8gZ2V0RGlyZWN0b3J5IG11c3QgZmFpbC5cbiAgICAgIGlmIChvcHRfZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBvcHRfZXJyb3JDYWxsYmFjayhJTlZBTElEX01PRElGSUNBVElPTl9FUlIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZSA9PT0gdHJ1ZSAmJiAhZm9sZGVyRW50cnkpIHtcbiAgICAgIC8vIElmIGNyZWF0ZSBpcyB0cnVlLCB0aGUgcGF0aCBkb2Vzbid0IGV4aXN0LCBhbmQgbm8gb3RoZXIgZXJyb3Igb2NjdXJzLFxuICAgICAgLy8gZ2V0RGlyZWN0b3J5IG11c3QgY3JlYXRlIGl0IGFzIGEgemVyby1sZW5ndGggZmlsZSBhbmQgcmV0dXJuIGEgY29ycmVzcG9uZGluZ1xuICAgICAgLy8gRGlyZWN0b3J5RW50cnkuXG4gICAgICB2YXIgZGlyRW50cnkgPSBuZXcgRGlyZWN0b3J5RW50cnkoKTtcbiAgICAgIGRpckVudHJ5Lm5hbWUgPSBwYXRoLnNwbGl0KERJUl9TRVBBUkFUT1IpLnBvcCgpOyAvLyBKdXN0IG5lZWQgZmlsZW5hbWUuXG4gICAgICBkaXJFbnRyeS5mdWxsUGF0aCA9IHBhdGg7XG4gICAgICBkaXJFbnRyeS5maWxlc3lzdGVtID0gZnNfO1xuXG4gICAgICBpZGJfLnB1dChkaXJFbnRyeSwgc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZSA9PT0gdHJ1ZSAmJiBmb2xkZXJFbnRyeSkge1xuXG4gICAgICBpZiAoZm9sZGVyRW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgLy8gSURCIHdvbid0IHNhdmUgbWV0aG9kcywgc28gd2UgbmVlZCByZS1jcmVhdGUgdGhlIERpcmVjdG9yeUVudHJ5LlxuICAgICAgICBzdWNjZXNzQ2FsbGJhY2sobmV3IERpcmVjdG9yeUVudHJ5KGZvbGRlckVudHJ5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICBvcHRfZXJyb3JDYWxsYmFjayhJTlZBTElEX01PRElGSUNBVElPTl9FUlIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKCFvcHRpb25zLmNyZWF0ZSB8fCBvcHRpb25zLmNyZWF0ZSA9PT0gZmFsc2UpICYmICFmb2xkZXJFbnRyeSkge1xuICAgICAgLy8gSGFuZGxlIHJvb3Qgc3BlY2lhbC4gSXQgc2hvdWxkIGFsd2F5cyBleGlzdC5cbiAgICAgIGlmIChwYXRoID09IERJUl9TRVBBUkFUT1IpIHtcbiAgICAgICAgZm9sZGVyRW50cnkgPSBuZXcgRGlyZWN0b3J5RW50cnkoKTtcbiAgICAgICAgZm9sZGVyRW50cnkubmFtZSA9ICcnO1xuICAgICAgICBmb2xkZXJFbnRyeS5mdWxsUGF0aCA9IERJUl9TRVBBUkFUT1I7XG4gICAgICAgIGZvbGRlckVudHJ5LmZpbGVzeXN0ZW0gPSBmc187XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhmb2xkZXJFbnRyeSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgY3JlYXRlIGlzIG5vdCB0cnVlIGFuZCB0aGUgcGF0aCBkb2Vzbid0IGV4aXN0LCBnZXREaXJlY3RvcnkgbXVzdCBmYWlsLlxuICAgICAgaWYgKG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIG9wdF9lcnJvckNhbGxiYWNrKE5PVF9GT1VORF9FUlIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoIW9wdGlvbnMuY3JlYXRlIHx8IG9wdGlvbnMuY3JlYXRlID09PSBmYWxzZSkgJiYgZm9sZGVyRW50cnkgJiZcbiAgICAgICAgICAgICAgIGZvbGRlckVudHJ5LmlzRmlsZSkge1xuICAgICAgLy8gSWYgY3JlYXRlIGlzIG5vdCB0cnVlIGFuZCB0aGUgcGF0aCBleGlzdHMsIGJ1dCBpcyBhIGZpbGUsIGdldERpcmVjdG9yeVxuICAgICAgLy8gbXVzdCBmYWlsLlxuICAgICAgaWYgKG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIG9wdF9lcnJvckNhbGxiYWNrKElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBubyBvdGhlciBlcnJvciBvY2N1cnMsIGdldERpcmVjdG9yeSBtdXN0IHJldHVybiBhXG4gICAgICAvLyBEaXJlY3RvcnlFbnRyeSBjb3JyZXNwb25kaW5nIHRvIHBhdGguXG5cbiAgICAgIC8vIElEQiB3b24ndCcgc2F2ZSBtZXRob2RzLCBzbyB3ZSBuZWVkIHJlLWNyZWF0ZSBEaXJlY3RvcnlFbnRyeS5cbiAgICAgIHN1Y2Nlc3NDYWxsYmFjayhuZXcgRGlyZWN0b3J5RW50cnkoZm9sZGVyRW50cnkpKTtcbiAgICB9XG4gIH0sIG9wdF9lcnJvckNhbGxiYWNrKTtcbn07XG5cbkRpcmVjdG9yeUVudHJ5LnByb3RvdHlwZS5nZXRGaWxlID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRfZXJyb3JDYWxsYmFjaykge1xuXG4gIC8vIENyZWF0ZSBhbiBhYnNvbHV0ZSBwYXRoIGlmIHdlIHdlcmUgaGFuZGVkIGEgcmVsYXRpdmUgb25lLlxuICBwYXRoID0gcmVzb2x2ZVRvRnVsbFBhdGhfKHRoaXMuZnVsbFBhdGgsIHBhdGgpO1xuXG4gIGlkYl8uZ2V0KHBhdGgsIGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZSA9PT0gdHJ1ZSAmJiBvcHRpb25zLmV4Y2x1c2l2ZSA9PT0gdHJ1ZSAmJiBmaWxlRW50cnkpIHtcbiAgICAgIC8vIElmIGNyZWF0ZSBhbmQgZXhjbHVzaXZlIGFyZSBib3RoIHRydWUsIGFuZCB0aGUgcGF0aCBhbHJlYWR5IGV4aXN0cyxcbiAgICAgIC8vIGdldEZpbGUgbXVzdCBmYWlsLlxuXG4gICAgICBpZiAob3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgb3B0X2Vycm9yQ2FsbGJhY2soSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jcmVhdGUgPT09IHRydWUgJiYgIWZpbGVFbnRyeSkge1xuICAgICAgLy8gSWYgY3JlYXRlIGlzIHRydWUsIHRoZSBwYXRoIGRvZXNuJ3QgZXhpc3QsIGFuZCBubyBvdGhlciBlcnJvciBvY2N1cnMsXG4gICAgICAvLyBnZXRGaWxlIG11c3QgY3JlYXRlIGl0IGFzIGEgemVyby1sZW5ndGggZmlsZSBhbmQgcmV0dXJuIGEgY29ycmVzcG9uZGluZ1xuICAgICAgLy8gRmlsZUVudHJ5LlxuICAgICAgdmFyIGZpbGVFbnRyeSA9IG5ldyBGaWxlRW50cnkoKTtcbiAgICAgIGZpbGVFbnRyeS5uYW1lID0gcGF0aC5zcGxpdChESVJfU0VQQVJBVE9SKS5wb3AoKTsgLy8gSnVzdCBuZWVkIGZpbGVuYW1lLlxuICAgICAgZmlsZUVudHJ5LmZ1bGxQYXRoID0gcGF0aDtcbiAgICAgIGZpbGVFbnRyeS5maWxlc3lzdGVtID0gZnNfO1xuICAgICAgZmlsZUVudHJ5LmZpbGVfID0gbmV3IE15RmlsZSh7c2l6ZTogMCwgbmFtZTogZmlsZUVudHJ5Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWREYXRlOiBuZXcgRGF0ZSgpfSk7XG5cbiAgICAgIGlkYl8ucHV0KGZpbGVFbnRyeSwgc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjayk7XG5cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3JlYXRlID09PSB0cnVlICYmIGZpbGVFbnRyeSkge1xuICAgICAgaWYgKGZpbGVFbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgLy8gSURCIHdvbid0IHNhdmUgbWV0aG9kcywgc28gd2UgbmVlZCByZS1jcmVhdGUgdGhlIEZpbGVFbnRyeS5cbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKG5ldyBGaWxlRW50cnkoZmlsZUVudHJ5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICBvcHRfZXJyb3JDYWxsYmFjayhJTlZBTElEX01PRElGSUNBVElPTl9FUlIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKCFvcHRpb25zLmNyZWF0ZSB8fCBvcHRpb25zLmNyZWF0ZSA9PT0gZmFsc2UpICYmICFmaWxlRW50cnkpIHtcbiAgICAgIC8vIElmIGNyZWF0ZSBpcyBub3QgdHJ1ZSBhbmQgdGhlIHBhdGggZG9lc24ndCBleGlzdCwgZ2V0RmlsZSBtdXN0IGZhaWwuXG4gICAgICBpZiAob3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgb3B0X2Vycm9yQ2FsbGJhY2soTk9UX0ZPVU5EX0VSUik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCghb3B0aW9ucy5jcmVhdGUgfHwgb3B0aW9ucy5jcmVhdGUgPT09IGZhbHNlKSAmJiBmaWxlRW50cnkgJiZcbiAgICAgICAgICAgICAgIGZpbGVFbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgLy8gSWYgY3JlYXRlIGlzIG5vdCB0cnVlIGFuZCB0aGUgcGF0aCBleGlzdHMsIGJ1dCBpcyBhIGRpcmVjdG9yeSwgZ2V0RmlsZVxuICAgICAgLy8gbXVzdCBmYWlsLlxuICAgICAgaWYgKG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIG9wdF9lcnJvckNhbGxiYWNrKElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBubyBvdGhlciBlcnJvciBvY2N1cnMsIGdldEZpbGUgbXVzdCByZXR1cm4gYSBGaWxlRW50cnlcbiAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gcGF0aC5cblxuICAgICAgLy8gSURCIHdvbid0JyBzYXZlIG1ldGhvZHMsIHNvIHdlIG5lZWQgcmUtY3JlYXRlIHRoZSBGaWxlRW50cnkuXG4gICAgICBzdWNjZXNzQ2FsbGJhY2sobmV3IEZpbGVFbnRyeShmaWxlRW50cnkpKTtcbiAgICB9XG4gIH0sIG9wdF9lcnJvckNhbGxiYWNrKTtcbn07XG5cbkRpcmVjdG9yeUVudHJ5LnByb3RvdHlwZS5yZW1vdmVSZWN1cnNpdmVseSA9IGZ1bmN0aW9uKHN1Y2Nlc3NDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIGlmICghc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIHN1Y2Nlc3NDYWxsYmFjayBhcmd1bWVudC4nKTtcbiAgfVxuXG4gIHRoaXMucmVtb3ZlKHN1Y2Nlc3NDYWxsYmFjaywgb3B0X2Vycm9yQ2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVwcmVzZW50aW5nIGEgZmlsZXN5c3RlbS5cbiAqXG4gKiBNb2RlbGVkIGZyb206XG4gKiBkZXYudzMub3JnLzIwMDkvZGFwL2ZpbGUtc3lzdGVtL3B1Yi9GaWxlU3lzdGVtLyNpZGwtZGVmLUxvY2FsRmlsZVN5c3RlbVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIEtpbmQgb2Ygc3RvcmFnZSB0byB1c2UsIGVpdGhlciBURU1QT1JBUlkgb3IgUEVSU0lTVEVOVC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFN0b3JhZ2Ugc3BhY2UgKGJ5dGVzKSB0aGUgYXBwbGljYXRpb24gZXhwZWN0cyB0byBuZWVkLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERPTUZpbGVTeXN0ZW0odHlwZSwgc2l6ZSkge1xuICBzdG9yYWdlVHlwZV8gPSB0eXBlID09IGV4cG9ydHMuVEVNUE9SQVJZID8gJ1RlbXBvcmFyeScgOiAnUGVyc2lzdGVudCc7XG4gIHRoaXMubmFtZSA9IChsb2NhdGlvbi5wcm90b2NvbCArIGxvY2F0aW9uLmhvc3QpLnJlcGxhY2UoLzovZywgJ18nKSArXG4gICAgICAgICAgICAgICc6JyArIHN0b3JhZ2VUeXBlXztcbiAgdGhpcy5yb290ID0gbmV3IERpcmVjdG9yeUVudHJ5KCk7XG4gIHRoaXMucm9vdC5mdWxsUGF0aCA9IERJUl9TRVBBUkFUT1I7XG4gIHRoaXMucm9vdC5maWxlc3lzdGVtID0gdGhpcztcbiAgdGhpcy5yb290Lm5hbWUgPSAnJztcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEZpbGVTeXN0ZW0odHlwZSwgc2l6ZSwgc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICBpZiAodHlwZSAhPSBleHBvcnRzLlRFTVBPUkFSWSAmJiB0eXBlICE9IGV4cG9ydHMuUEVSU0lTVEVOVCkge1xuICAgIGlmIChvcHRfZXJyb3JDYWxsYmFjaykge1xuICAgICAgb3B0X2Vycm9yQ2FsbGJhY2soSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmc18gPSBuZXcgRE9NRmlsZVN5c3RlbSh0eXBlLCBzaXplKTtcbiAgaWRiXy5vcGVuKGZzXy5uYW1lLCBmdW5jdGlvbihlKSB7XG4gICAgc3VjY2Vzc0NhbGxiYWNrKGZzXyk7XG4gIH0sIG9wdF9lcnJvckNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTCh1cmwsIHN1Y2Nlc3NDYWxsYmFjaywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIG9yaWdpbiA9IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBiYXNlID0gJ2ZpbGVzeXN0ZW06JyArIG9yaWdpbiArIERJUl9TRVBBUkFUT1IgKyBzdG9yYWdlVHlwZV8udG9Mb3dlckNhc2UoKTtcbiAgdXJsID0gdXJsLnJlcGxhY2UoYmFzZSwgJycpO1xuICBpZiAodXJsLnN1YnN0cigtMSkgPT09ICcvJykge1xuICAgIHVybCA9IHVybC5zbGljZSgwLCAtMSk7XG4gIH1cbiAgaWYgKHVybCkge1xuICAgIGlkYl8uZ2V0KHVybCwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHN1Y2Nlc3NDYWxsYmFjayhuZXcgRmlsZUVudHJ5KGVudHJ5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICByZXR1cm4gc3VjY2Vzc0NhbGxiYWNrKG5ldyBEaXJlY3RvcnlFbnRyeShlbnRyeSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRfZXJyb3JDYWxsYmFjayAmJiBvcHRfZXJyb3JDYWxsYmFjayhOT1RfRk9VTkRfRVJSKTtcbiAgICAgIH1cbiAgICB9LCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VjY2Vzc0NhbGxiYWNrKGZzXy5yb290KTtcbiAgfVxufVxuXG4vLyBDb3JlIGxvZ2ljIHRvIGhhbmRsZSBJREIgb3BlcmF0aW9ucyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pZGJfLm9wZW4gPSBmdW5jdGlvbihkYk5hbWUsIHN1Y2Nlc3NDYWxsYmFjaywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIFRPRE86IEZGIDEyLjBhMSBpc24ndCBsaWtpbmcgYSBkYiBuYW1lIHdpdGggOiBpbiBpdC5cbiAgdmFyIHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihkYk5hbWUucmVwbGFjZSgnOicsICdfJykvKiwgMSAvKnZlcnNpb24qLyk7XG5cbiAgcmVxdWVzdC5vbmVycm9yID0gb3B0X2Vycm9yQ2FsbGJhY2sgfHwgb25FcnJvcjtcblxuICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBGaXJzdCBvcGVuIHdhcyBjYWxsZWQgb3IgaGlnaGVyIGRiIHZlcnNpb24gd2FzIHVzZWQuXG5cbiAgIC8vIGNvbnNvbGUubG9nKCdvbnVwZ3JhZGVuZWVkZWQ6IG9sZFZlcnNpb246JyArIGUub2xkVmVyc2lvbixcbiAgIC8vICAgICAgICAgICAnbmV3VmVyc2lvbjonICsgZS5uZXdWZXJzaW9uKTtcblxuICAgIHNlbGYuZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgc2VsZi5kYi5vbmVycm9yID0gb25FcnJvcjtcblxuICAgIGlmICghc2VsZi5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKEZJTEVfU1RPUkVfKSkge1xuICAgICAgdmFyIHN0b3JlID0gc2VsZi5kYi5jcmVhdGVPYmplY3RTdG9yZShGSUxFX1NUT1JFXy8qLHtrZXlQYXRoOiAnaWQnLCBhdXRvSW5jcmVtZW50OiB0cnVlfSovKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5kYiA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBzZWxmLmRiLm9uZXJyb3IgPSBvbkVycm9yO1xuICAgIHN1Y2Nlc3NDYWxsYmFjayhlKTtcbiAgfTtcblxuICByZXF1ZXN0Lm9uYmxvY2tlZCA9IG9wdF9lcnJvckNhbGxiYWNrIHx8IG9uRXJyb3I7XG59O1xuXG5pZGJfLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGIuY2xvc2UoKTtcbiAgdGhpcy5kYiA9IG51bGw7XG59O1xuXG4vLyBUT0RPOiBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBldmVyIGNhbGwgdGhpcyBtZXRob2QuIFRoZSBmaWxlc3lzdGVtIEFQSVxuLy8gZG9lc24ndCBhbGxvdyB5b3UgdG8gZGVsZXRlIGEgZmlsZXN5c3RlbSBvbmNlIGl0IGlzICdjcmVhdGVkJy4gVXNlcnMgc2hvdWxkXG4vLyB1c2UgdGhlIHB1YmxpYyByZW1vdmUvcmVtb3ZlUmVjdXJzaXZlbHkgQVBJIGluc3RlYWQuXG5pZGJfLmRyb3AgPSBmdW5jdGlvbihzdWNjZXNzQ2FsbGJhY2ssIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIGlmICghdGhpcy5kYikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYk5hbWUgPSB0aGlzLmRiLm5hbWU7XG5cbiAgdmFyIHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgc3VjY2Vzc0NhbGxiYWNrKGUpO1xuICB9O1xuICByZXF1ZXN0Lm9uZXJyb3IgPSBvcHRfZXJyb3JDYWxsYmFjayB8fCBvbkVycm9yO1xuXG4gIGlkYl8uY2xvc2UoKTtcbn07XG5cbmlkYl8uZ2V0ID0gZnVuY3Rpb24oZnVsbFBhdGgsIHN1Y2Nlc3NDYWxsYmFjaywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgaWYgKCF0aGlzLmRiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHR4ID0gdGhpcy5kYi50cmFuc2FjdGlvbihbRklMRV9TVE9SRV9dLCAncmVhZG9ubHknKTtcblxuICAvL3ZhciByZXF1ZXN0ID0gdHgub2JqZWN0U3RvcmUoRklMRV9TVE9SRV8pLmdldChmdWxsUGF0aCk7XG4gIHZhciByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKGZ1bGxQYXRoLCBmdWxsUGF0aCArIERJUl9PUEVOX0JPVU5ELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gIHZhciByZXF1ZXN0ID0gdHgub2JqZWN0U3RvcmUoRklMRV9TVE9SRV8pLmdldChyYW5nZSk7XG5cbiAgdHgub25hYm9ydCA9IG9wdF9lcnJvckNhbGxiYWNrIHx8IG9uRXJyb3I7XG4gIHR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgc3VjY2Vzc0NhbGxiYWNrKHJlcXVlc3QucmVzdWx0KTtcbiAgfTtcbn07XG5cbmlkYl8uZ2V0QWxsRW50cmllcyA9IGZ1bmN0aW9uKGZ1bGxQYXRoLCBzdWNjZXNzQ2FsbGJhY2ssIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIGlmICghdGhpcy5kYikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgLy92YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGZ1bGxQYXRoLCB0cnVlKTtcbiAgLy92YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS51cHBlckJvdW5kKGZ1bGxQYXRoLCB0cnVlKTtcblxuICAvLyBUcmVhdCB0aGUgcm9vdCBlbnRyeSBzcGVjaWFsLiBRdWVyeWluZyBpdCByZXR1cm5zIGFsbCBlbnRyaWVzIGJlY2F1c2VcbiAgLy8gdGhleSBtYXRjaCAnLycuXG4gIHZhciByYW5nZSA9IG51bGw7XG4gIGlmIChmdWxsUGF0aCAhPSBESVJfU0VQQVJBVE9SKSB7XG4gICAgLy9jb25zb2xlLmxvZyhmdWxsUGF0aCArICcvJywgZnVsbFBhdGggKyBESVJfT1BFTl9CT1VORClcbiAgICByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFxuICAgICAgICBmdWxsUGF0aCArIERJUl9TRVBBUkFUT1IsIGZ1bGxQYXRoICsgRElSX09QRU5fQk9VTkQsIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eCA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW0ZJTEVfU1RPUkVfXSwgJ3JlYWRvbmx5Jyk7XG4gIHR4Lm9uYWJvcnQgPSBvcHRfZXJyb3JDYWxsYmFjayB8fCBvbkVycm9yO1xuICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvIGRvIGJlIHJhbmdlIHF1ZXJpZXMgaW5zdGVhZCBvZiBmaWx0ZXJpbmcgcmVzdWx0XG4gICAgLy8gaW4gbWVtb3J5IDooXG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHZhbFBhcnRzTGVuID0gdmFsLmZ1bGxQYXRoLnNwbGl0KERJUl9TRVBBUkFUT1IpLmxlbmd0aDtcbiAgICAgIHZhciBmdWxsUGF0aFBhcnRzTGVuID0gZnVsbFBhdGguc3BsaXQoRElSX1NFUEFSQVRPUikubGVuZ3RoO1xuXG4gICAgICBpZiAoZnVsbFBhdGggPT0gRElSX1NFUEFSQVRPUiAmJiB2YWxQYXJ0c0xlbiA8IGZ1bGxQYXRoUGFydHNMZW4gKyAxKSB7XG4gICAgICAgIC8vIEhhY2sgdG8gZmlsdGVyIG91dCBlbnRyaWVzIGluIHRoZSByb290IGZvbGRlci4gVGhpcyBpcyBpbmVmZmljaWVudFxuICAgICAgICAvLyBiZWNhdXNlIHJlYWRpbmcgdGhlIGVudGlyZXMgb2YgZnMucm9vdCAoZS5nLiAnLycpIHJldHVybnMgQUxMXG4gICAgICAgIC8vIHJlc3VsdHMgaW4gdGhlIGRhdGFiYXNlLCB0aGVuIGZpbHRlcnMgb3V0IHRoZSBlbnRyaWVzIG5vdCBpbiAnLycuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9IGVsc2UgaWYgKGZ1bGxQYXRoICE9IERJUl9TRVBBUkFUT1IgJiZcbiAgICAgICAgICAgICAgICAgdmFsUGFydHNMZW4gPT0gZnVsbFBhdGhQYXJ0c0xlbiArIDEpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBhIHN1YmZvbGRlciBhbmQgZW50cnkgaXMgYSBkaXJlY3QgY2hpbGQsIGluY2x1ZGUgaXQgaW5cbiAgICAgICAgLy8gdGhlIHJlc3VsdHMuIE90aGVyd2lzZSwgaXQncyBub3QgYW4gZW50cnkgb2YgdGhpcyBmb2xkZXIuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdWNjZXNzQ2FsbGJhY2socmVzdWx0cyk7XG4gIH07XG5cbiAgdmFyIHJlcXVlc3QgPSB0eC5vYmplY3RTdG9yZShGSUxFX1NUT1JFXykub3BlbkN1cnNvcihyYW5nZSk7XG5cbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBpZiAoY3Vyc29yKSB7XG4gICAgICB2YXIgdmFsID0gY3Vyc29yLnZhbHVlO1xuXG4gICAgICByZXN1bHRzLnB1c2godmFsLmlzRmlsZSA/IG5ldyBGaWxlRW50cnkodmFsKSA6IG5ldyBEaXJlY3RvcnlFbnRyeSh2YWwpKTtcbiAgICAgIGN1cnNvclsnY29udGludWUnXSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmlkYl9bJ2RlbGV0ZSddID0gZnVuY3Rpb24oZnVsbFBhdGgsIHN1Y2Nlc3NDYWxsYmFjaywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgaWYgKCF0aGlzLmRiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHR4ID0gdGhpcy5kYi50cmFuc2FjdGlvbihbRklMRV9TVE9SRV9dLCAncmVhZHdyaXRlJyk7XG4gIHR4Lm9uY29tcGxldGUgPSBzdWNjZXNzQ2FsbGJhY2s7XG4gIHR4Lm9uYWJvcnQgPSBvcHRfZXJyb3JDYWxsYmFjayB8fCBvbkVycm9yO1xuXG4gIC8vdmFyIHJlcXVlc3QgPSB0eC5vYmplY3RTdG9yZShGSUxFX1NUT1JFXykuZGVsZXRlKGZ1bGxQYXRoKTtcbiAgdmFyIHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoXG4gICAgICBmdWxsUGF0aCwgZnVsbFBhdGggKyBESVJfT1BFTl9CT1VORCwgZmFsc2UsIHRydWUpO1xuICB2YXIgcmVxdWVzdCA9IHR4Lm9iamVjdFN0b3JlKEZJTEVfU1RPUkVfKVsnZGVsZXRlJ10ocmFuZ2UpO1xufTtcblxuaWRiXy5wdXQgPSBmdW5jdGlvbihlbnRyeSwgc3VjY2Vzc0NhbGxiYWNrLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICBpZiAoIXRoaXMuZGIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHggPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFtGSUxFX1NUT1JFX10sICdyZWFkd3JpdGUnKTtcbiAgdHgub25hYm9ydCA9IG9wdF9lcnJvckNhbGxiYWNrIHx8IG9uRXJyb3I7XG4gIHR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgLy8gVE9ETzogRXJyb3IgaXMgdGhyb3duIGlmIHdlIHBhc3MgdGhlIHJlcXVlc3QgZXZlbnQgYmFjayBpbnN0ZWFkLlxuICAgIHN1Y2Nlc3NDYWxsYmFjayhlbnRyeSk7XG4gIH07XG5cbiAgdmFyIHJlcXVlc3QgPSB0eC5vYmplY3RTdG9yZShGSUxFX1NUT1JFXykucHV0KGVudHJ5LCBlbnRyeS5mdWxsUGF0aCk7XG59O1xuXG4vLyBHbG9iYWwgZXJyb3IgaGFuZGxlci4gRXJyb3JzIGJ1YmJsZSBmcm9tIHJlcXVlc3QsIHRvIHRyYW5zYWN0aW9uLCB0byBkYi5cbmZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICBzd2l0Y2ggKGUudGFyZ2V0LmVycm9yQ29kZSkge1xuICAgIGNhc2UgMTI6XG4gICAgICBjb25zb2xlLmxvZygnRXJyb3IgLSBBdHRlbXB0IHRvIG9wZW4gZGIgd2l0aCBhIGxvd2VyIHZlcnNpb24gdGhhbiB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAnY3VycmVudCBvbmUuJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS5sb2coJ2Vycm9yQ29kZTogJyArIGUudGFyZ2V0LmVycm9yQ29kZSk7XG4gIH1cblxuICBjb25zb2xlLmxvZyhlLCBlLmNvZGUsIGUubWVzc2FnZSk7XG59XG5cbi8vIENsZWFuIHVwLlxuLy8gVE9ETzogZGVjaWRlIGlmIHRoaXMgaXMgdGhlIGJlc3QgcGxhY2UgZm9yIHRoaXMuXG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uKGUpIHtcbiAgaWRiXy5kYiAmJiBpZGJfLmRiLmNsb3NlKCk7XG59LCBmYWxzZSk7XG5cbi8vZXhwb3J0cy5pZGIgPSBpZGJfO1xuZXhwb3J0cy5yZXF1ZXN0RmlsZVN5c3RlbSA9IHJlcXVlc3RGaWxlU3lzdGVtO1xuZXhwb3J0cy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMID0gcmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTDtcblxuLy8gRXhwb3J0IG1vcmUgc3R1ZmYgKHRvIHdpbmRvdykgZm9yIHVuaXQgdGVzdHMgdG8gZG8gdGhlaXIgdGhpbmcuXG5pZiAoZXhwb3J0cyA9PT0gd2luZG93ICYmIGV4cG9ydHMuUlVOTklOR19URVNUUykge1xuICBleHBvcnRzWydFbnRyeSddID0gRW50cnk7XG4gIGV4cG9ydHNbJ0ZpbGVFbnRyeSddID0gRmlsZUVudHJ5O1xuICBleHBvcnRzWydEaXJlY3RvcnlFbnRyeSddID0gRGlyZWN0b3J5RW50cnk7XG4gIGV4cG9ydHNbJ3Jlc29sdmVUb0Z1bGxQYXRoXyddID0gcmVzb2x2ZVRvRnVsbFBhdGhfO1xuICBleHBvcnRzWydNZXRhZGF0YSddID0gTWV0YWRhdGE7XG4gIGV4cG9ydHNbJ0Jhc2U2NFRvQmxvYiddID0gQmFzZTY0VG9CbG9iO1xufVxuXG59KShzZWxmKTsgLy8gRG9uJ3QgdXNlIHdpbmRvdyBiZWNhdXNlIHdlIHdhbnQgdG8gcnVuIGluIHdvcmtlcnMuXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZ2xvYiwgb3B0cykge1xuICBpZiAodHlwZW9mIGdsb2IgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBzdHIgPSBTdHJpbmcoZ2xvYik7XG5cbiAgLy8gVGhlIHJlZ2V4cCB3ZSBhcmUgYnVpbGRpbmcsIGFzIGEgc3RyaW5nLlxuICB2YXIgcmVTdHIgPSBcIlwiO1xuXG4gIC8vIFdoZXRoZXIgd2UgYXJlIG1hdGNoaW5nIHNvIGNhbGxlZCBcImV4dGVuZGVkXCIgZ2xvYnMgKGxpa2UgYmFzaCkgYW5kIHNob3VsZFxuICAvLyBzdXBwb3J0IHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hpbmcsIG1hdGNoaW5nIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLCBncm91cFxuICAvLyBtYXRjaGluZywgZXRjLlxuICB2YXIgZXh0ZW5kZWQgPSBvcHRzID8gISFvcHRzLmV4dGVuZGVkIDogZmFsc2U7XG5cbiAgLy8gV2hldGhlciBvciBub3QgdG8gY2FwdHVyZSB0aG9zZSBzdGFycywgaXQgbWVhbnMgd3JhcHBpbmcgdGhlbSB3aXRoIHBhcmVudGhlc2VzXG4gIC8vIEl0J3Mgbm90IG5lY2Vzc2FyeSBpZiBnbG9ic3RhcnQgaXMgdHVybmVkIG9uXG4gIHZhciBjYXB0dXJlID0gb3B0cyA/ICEhb3B0cy5jYXB0dXJlIDogZmFsc2U7XG5cbiAgLy8gV2hlbiBnbG9ic3RhciBpcyBfZmFsc2VfIChkZWZhdWx0KSwgJy9mb28vKicgaXMgdHJhbnNsYXRlZCBhIHJlZ2V4cCBsaWtlXG4gIC8vICdeXFwvZm9vXFwvLiokJyB3aGljaCB3aWxsIG1hdGNoIGFueSBzdHJpbmcgYmVnaW5uaW5nIHdpdGggJy9mb28vJ1xuICAvLyBXaGVuIGdsb2JzdGFyIGlzIF90cnVlXywgJy9mb28vKicgaXMgdHJhbnNsYXRlZCB0byByZWdleHAgbGlrZVxuICAvLyAnXlxcL2Zvb1xcL1teL10qJCcgd2hpY2ggd2lsbCBtYXRjaCBhbnkgc3RyaW5nIGJlZ2lubmluZyB3aXRoICcvZm9vLycgQlVUXG4gIC8vIHdoaWNoIGRvZXMgbm90IGhhdmUgYSAnLycgdG8gdGhlIHJpZ2h0IG9mIGl0LlxuICAvLyBFLmcuIHdpdGggJy9mb28vKicgdGhlc2Ugd2lsbCBtYXRjaDogJy9mb28vYmFyJywgJy9mb28vYmFyLnR4dCcgYnV0XG4gIC8vIHRoZXNlIHdpbGwgbm90ICcvZm9vL2Jhci9iYXonLCAnL2Zvby9iYXIvYmF6LnR4dCdcbiAgLy8gTGFzdGVseSwgd2hlbiBnbG9ic3RhciBpcyBfdHJ1ZV8sICcvZm9vLyoqJyBpcyBlcXVpdmVsYW50IHRvICcvZm9vLyonIHdoZW5cbiAgLy8gZ2xvYnN0YXIgaXMgX2ZhbHNlX1xuICB2YXIgZ2xvYnN0YXIgPSBvcHRzID8gISFvcHRzLmdsb2JzdGFyIDogZmFsc2U7XG5cbiAgLy8gSWYgd2UgYXJlIGRvaW5nIGV4dGVuZGVkIG1hdGNoaW5nLCB0aGlzIGJvb2xlYW4gaXMgdHJ1ZSB3aGVuIHdlIGFyZSBpbnNpZGVcbiAgLy8gYSBncm91cCAoZWcgeyouaHRtbCwqLmpzfSksIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gIHZhciBpbkdyb3VwID0gZmFsc2U7XG5cbiAgLy8gUmVnRXhwIGZsYWdzIChlZyBcImlcIiApIHRvIHBhc3MgaW4gdG8gUmVnRXhwIGNvbnN0cnVjdG9yLlxuICB2YXIgZmxhZ3MgPSBvcHRzICYmIHR5cGVvZiggb3B0cy5mbGFncyApID09PSBcInN0cmluZ1wiID8gb3B0cy5mbGFncyA6IFwiXCI7XG5cbiAgdmFyIGM7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjID0gc3RyW2ldO1xuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSBcIi9cIjpcbiAgICBjYXNlIFwiJFwiOlxuICAgIGNhc2UgXCJeXCI6XG4gICAgY2FzZSBcIitcIjpcbiAgICBjYXNlIFwiLlwiOlxuICAgIGNhc2UgXCIoXCI6XG4gICAgY2FzZSBcIilcIjpcbiAgICBjYXNlIFwiPVwiOlxuICAgIGNhc2UgXCIhXCI6XG4gICAgY2FzZSBcInxcIjpcbiAgICAgIHJlU3RyICs9IFwiXFxcXFwiICsgYztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIj9cIjpcbiAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICByZVN0ciArPSBcIi5cIjtcblx0ICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIltcIjpcbiAgICBjYXNlIFwiXVwiOlxuICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgIHJlU3RyICs9IGM7XG5cdCAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgXCJ7XCI6XG4gICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgaW5Hcm91cCA9IHRydWU7XG5cdCAgICByZVN0ciArPSBcIihcIjtcblx0ICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIn1cIjpcbiAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICBpbkdyb3VwID0gZmFsc2U7XG5cdCAgICByZVN0ciArPSBcIilcIjtcblx0ICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIixcIjpcbiAgICAgIGlmIChpbkdyb3VwKSB7XG4gICAgICAgIHJlU3RyICs9IFwifFwiO1xuXHQgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZVN0ciArPSBcIlxcXFxcIiArIGM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCIqXCI6XG4gICAgICAvLyBNb3ZlIG92ZXIgYWxsIGNvbnNlY3V0aXZlIFwiKlwiJ3MuXG4gICAgICAvLyBBbHNvIHN0b3JlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBjaGFyYWN0ZXJzXG4gICAgICB2YXIgcHJldkNoYXIgPSBzdHJbaSAtIDFdO1xuICAgICAgdmFyIHN0YXJDb3VudCA9IDE7XG4gICAgICB3aGlsZShzdHJbaSArIDFdID09PSBcIipcIikge1xuICAgICAgICBzdGFyQ291bnQrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgdmFyIG5leHRDaGFyID0gc3RyW2kgKyAxXTtcblxuICAgICAgaWYgKCFnbG9ic3Rhcikge1xuICAgICAgICAvLyBnbG9ic3RhciBpcyBkaXNhYmxlZCwgc28gdHJlYXQgYW55IG51bWJlciBvZiBcIipcIiBhcyBvbmVcbiAgICAgICAgcmVTdHIgKz0gY2FwdHVyZSA/IFwiKC4qKVwiIDogXCIuKlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2xvYnN0YXIgaXMgZW5hYmxlZCwgc28gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBnbG9ic3RhciBzZWdtZW50XG4gICAgICAgIHZhciBpc0dsb2JzdGFyID0gc3RhckNvdW50ID4gMSAgICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBcIipcIidzXG4gICAgICAgICAgJiYgKHByZXZDaGFyID09PSBcIi9cIiB8fCBwcmV2Q2hhciA9PT0gdW5kZWZpbmVkKSAgIC8vIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAgICAgICAgJiYgKG5leHRDaGFyID09PSBcIi9cIiB8fCBuZXh0Q2hhciA9PT0gdW5kZWZpbmVkKSAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIHNlZ21lbnRcblxuICAgICAgICBpZiAoaXNHbG9ic3Rhcikge1xuICAgICAgICAgIC8vIGl0J3MgYSBnbG9ic3Rhciwgc28gbWF0Y2ggemVybyBvciBtb3JlIHBhdGggc2VnbWVudHNcbiAgICAgICAgICByZVN0ciArPSBcIigoPzpbXi9dKig/OlxcL3wkKSkqKVwiO1xuICAgICAgICAgIGkrKzsgLy8gbW92ZSBvdmVyIHRoZSBcIi9cIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0J3Mgbm90IGEgZ2xvYnN0YXIsIHNvIG9ubHkgbWF0Y2ggb25lIHBhdGggc2VnbWVudFxuICAgICAgICAgIHJlU3RyICs9IFwiKFteL10qKVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZVN0ciArPSBjO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gcmVnZXhwICdnJyBmbGFnIGlzIHNwZWNpZmllZCBkb24ndFxuICAvLyBjb25zdHJhaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIF4gJiAkXG4gIGlmICghZmxhZ3MgfHwgIX5mbGFncy5pbmRleE9mKCdnJykpIHtcbiAgICByZVN0ciA9IFwiXlwiICsgcmVTdHIgKyBcIiRcIjtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlU3RyLCBmbGFncyk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiXG5leHBvcnRzLnBia2RmMiA9IHJlcXVpcmUoJy4vbGliL2FzeW5jJylcblxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcmVxdWlyZSgnLi9saWIvc3luYycpXG4iLCJ2YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxudmFyIGRlZmF1bHRFbmNvZGluZyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1lbmNvZGluZycpXG52YXIgc3luYyA9IHJlcXVpcmUoJy4vc3luYycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFpFUk9fQlVGXG52YXIgc3VidGxlID0gZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLnN1YnRsZVxudmFyIHRvQnJvd3NlciA9IHtcbiAgJ3NoYSc6ICdTSEEtMScsXG4gICdzaGEtMSc6ICdTSEEtMScsXG4gICdzaGExJzogJ1NIQS0xJyxcbiAgJ3NoYTI1Nic6ICdTSEEtMjU2JyxcbiAgJ3NoYS0yNTYnOiAnU0hBLTI1NicsXG4gICdzaGEzODQnOiAnU0hBLTM4NCcsXG4gICdzaGEtMzg0JzogJ1NIQS0zODQnLFxuICAnc2hhLTUxMic6ICdTSEEtNTEyJyxcbiAgJ3NoYTUxMic6ICdTSEEtNTEyJ1xufVxudmFyIGNoZWNrcyA9IFtdXG5mdW5jdGlvbiBjaGVja05hdGl2ZSAoYWxnbykge1xuICBpZiAoZ2xvYmFsLnByb2Nlc3MgJiYgIWdsb2JhbC5wcm9jZXNzLmJyb3dzZXIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICB9XG4gIGlmICghc3VidGxlIHx8ICFzdWJ0bGUuaW1wb3J0S2V5IHx8ICFzdWJ0bGUuZGVyaXZlQml0cykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG4gIH1cbiAgaWYgKGNoZWNrc1thbGdvXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNoZWNrc1thbGdvXVxuICB9XG4gIFpFUk9fQlVGID0gWkVST19CVUYgfHwgQnVmZmVyLmFsbG9jKDgpXG4gIHZhciBwcm9tID0gYnJvd3NlclBia2RmMihaRVJPX0JVRiwgWkVST19CVUYsIDEwLCAxMjgsIGFsZ28pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICBjaGVja3NbYWxnb10gPSBwcm9tXG4gIHJldHVybiBwcm9tXG59XG5mdW5jdGlvbiBicm93c2VyUGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywgbGVuZ3RoLCBhbGdvKSB7XG4gIHJldHVybiBzdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLCBwYXNzd29yZCwge25hbWU6ICdQQktERjInfSwgZmFsc2UsIFsnZGVyaXZlQml0cyddXG4gICkudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN1YnRsZS5kZXJpdmVCaXRzKHtcbiAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgc2FsdDogc2FsdCxcbiAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGFsZ29cbiAgICAgIH1cbiAgICB9LCBrZXksIGxlbmd0aCA8PCAzKVxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzKVxuICB9KVxufVxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UgKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gIHByb21pc2UudGhlbihmdW5jdGlvbiAob3V0KSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBvdXQpXG4gICAgfSlcbiAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGUpXG4gICAgfSlcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBkZWZhdWx0RW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIGNoZWNrUGFyYW1ldGVycyhpdGVyYXRpb25zLCBrZXlsZW4pXG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNhbGxiYWNrIHByb3ZpZGVkIHRvIHBia2RmMicpXG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuICB2YXIgYWxnbyA9IHRvQnJvd3NlcltkaWdlc3QudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFhbGdvIHx8IHR5cGVvZiBnbG9iYWwuUHJvbWlzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvdXRcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IHN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIG91dClcbiAgICB9KVxuICB9XG4gIHJlc29sdmVQcm9taXNlKGNoZWNrTmF0aXZlKGFsZ28pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBpZiAocmVzcCkge1xuICAgICAgcmV0dXJuIGJyb3dzZXJQYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgIH1cbiAgfSksIGNhbGxiYWNrKVxufVxuIiwidmFyIGRlZmF1bHRFbmNvZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgZGVmYXVsdEVuY29kaW5nID0gJ3V0Zi04J1xufSBlbHNlIHtcbiAgdmFyIHBWZXJzaW9uTWFqb3IgPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKVswXS5zbGljZSgxKSwgMTApXG5cbiAgZGVmYXVsdEVuY29kaW5nID0gcFZlcnNpb25NYWpvciA+PSA2ID8gJ3V0Zi04JyA6ICdiaW5hcnknXG59XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRFbmNvZGluZ1xuIiwidmFyIE1BWF9BTExPQyA9IE1hdGgucG93KDIsIDMwKSAtIDEgLy8gZGVmYXVsdCBpbiBpb2pzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRpb25zLCBrZXlsZW4pIHtcbiAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpdGVyYXRpb25zIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5bGVuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChrZXlsZW4gPCAwIHx8IGtleWxlbiA+IE1BWF9BTExPQyB8fCBrZXlsZW4gIT09IGtleWxlbikgeyAvKiBlc2xpbnQgbm8tc2VsZi1jb21wYXJlOiAwICovXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuICB9XG59XG4iLCJ2YXIgbWQ1ID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvbWQ1JylcbnZhciBybWQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBjaGVja1BhcmFtZXRlcnMgPSByZXF1aXJlKCcuL3ByZWNvbmRpdGlvbicpXG52YXIgZGVmYXVsdEVuY29kaW5nID0gcmVxdWlyZSgnLi9kZWZhdWx0LWVuY29kaW5nJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBzaXplcyA9IHtcbiAgbWQ1OiAxNixcbiAgc2hhMTogMjAsXG4gIHNoYTIyNDogMjgsXG4gIHNoYTI1NjogMzIsXG4gIHNoYTM4NDogNDgsXG4gIHNoYTUxMjogNjQsXG4gIHJtZDE2MDogMjAsXG4gIHJpcGVtZDE2MDogMjBcbn1cblxuZnVuY3Rpb24gSG1hYyAoYWxnLCBrZXksIHNhbHRMZW4pIHtcbiAgdmFyIGhhc2ggPSBnZXREaWdlc3QoYWxnKVxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gaGFzaChrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzaXplc1thbGddKVxuICB2YXIgb3BhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzaXplc1thbGddKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdmFyIGlwYWQxID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNhbHRMZW4gKyA0KVxuICBpcGFkLmNvcHkoaXBhZDEsIDAsIDAsIGJsb2Nrc2l6ZSlcbiAgdGhpcy5pcGFkMSA9IGlwYWQxXG4gIHRoaXMuaXBhZDIgPSBpcGFkXG4gIHRoaXMub3BhZCA9IG9wYWRcbiAgdGhpcy5hbGcgPSBhbGdcbiAgdGhpcy5ibG9ja3NpemUgPSBibG9ja3NpemVcbiAgdGhpcy5oYXNoID0gaGFzaFxuICB0aGlzLnNpemUgPSBzaXplc1thbGddXG59XG5cbkhtYWMucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChkYXRhLCBpcGFkKSB7XG4gIGRhdGEuY29weShpcGFkLCB0aGlzLmJsb2Nrc2l6ZSlcbiAgdmFyIGggPSB0aGlzLmhhc2goaXBhZClcbiAgaC5jb3B5KHRoaXMub3BhZCwgdGhpcy5ibG9ja3NpemUpXG4gIHJldHVybiB0aGlzLmhhc2godGhpcy5vcGFkKVxufVxuXG5mdW5jdGlvbiBnZXREaWdlc3QgKGFsZykge1xuICBmdW5jdGlvbiBzaGFGdW5jIChkYXRhKSB7XG4gICAgcmV0dXJuIHNoYShhbGcpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB9XG5cbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIHJtZDE2MFxuICBpZiAoYWxnID09PSAnbWQ1JykgcmV0dXJuIG1kNVxuICByZXR1cm4gc2hhRnVuY1xufVxuXG5mdW5jdGlvbiBwYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIGRlZmF1bHRFbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCBkZWZhdWx0RW5jb2RpbmcpXG5cbiAgY2hlY2tQYXJhbWV0ZXJzKGl0ZXJhdGlvbnMsIGtleWxlbilcblxuICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG5cbiAgdmFyIGhtYWMgPSBuZXcgSG1hYyhkaWdlc3QsIHBhc3N3b3JkLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgREsgPSBCdWZmZXIuYWxsb2NVbnNhZmUoa2V5bGVuKVxuICB2YXIgYmxvY2sxID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNhbHQubGVuZ3RoICsgNClcbiAgc2FsdC5jb3B5KGJsb2NrMSwgMCwgMCwgc2FsdC5sZW5ndGgpXG5cbiAgdmFyIGRlc3RQb3MgPSAwXG4gIHZhciBoTGVuID0gc2l6ZXNbZGlnZXN0XVxuICB2YXIgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuXG4gICAgdmFyIFQgPSBobWFjLnJ1bihibG9jazEsIGhtYWMuaXBhZDEpXG4gICAgdmFyIFUgPSBUXG5cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgVSA9IGhtYWMucnVuKFUsIGhtYWMuaXBhZDIpXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKykgVFtrXSBePSBVW2tdXG4gICAgfVxuXG4gICAgVC5jb3B5KERLLCBkZXN0UG9zKVxuICAgIGRlc3RQb3MgKz0gaExlblxuICB9XG5cbiAgcmV0dXJuIERLXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGJrZGYyXG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHVuZGVmaW5lZDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlc1swXSA9PT0gZGVzdCAmJiBzcmMubGlzdGVuZXJDb3VudCgnZGF0YScpID09PSAxICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKSBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO2Vsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSkgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7ZWxzZSBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXQgPSBudWxsO2Vsc2UgaWYgKG9iamVjdE1vZGUpIHJldCA9IGxpc3Quc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpIHJldCA9IGxpc3Quam9pbignJyk7ZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldCA9IGxpc3RbMF07ZWxzZSByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCA9ICcnO2Vsc2UgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSkgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO2Vsc2UgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKSBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7ZWxzZSBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gY3JlYXRlIHRoZSB0d28gb2JqZWN0cyBuZWVkZWQgdG8gc3RvcmUgdGhlIGNvcmtlZCByZXF1ZXN0c1xuICAvLyB0aGV5IGFyZSBub3QgYSBsaW5rZWQgbGlzdCwgYXMgbm8gbmV3IGVsZW1lbnRzIGFyZSBpbnNlcnRlZCBpbiB0aGVyZVxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgfVxuICB9O1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsInZhciBTdHJlYW0gPSAoZnVuY3Rpb24gKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7IC8vIGhhY2sgdG8gZml4IGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSB3aGVuIHVzZWQgd2l0aCBicm93c2VyaWZ5XG4gIH0gY2F0Y2goXyl7fVxufSgpKTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcblxuZnVuY3Rpb24gUklQRU1EMTYwICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxufVxuXG5pbmhlcml0cyhSSVBFTUQxNjAsIEhhc2hCYXNlKVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtID0gbmV3IEFycmF5KDE2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIG1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcblxuICB2YXIgYWwgPSB0aGlzLl9hXG4gIHZhciBibCA9IHRoaXMuX2JcbiAgdmFyIGNsID0gdGhpcy5fY1xuICB2YXIgZGwgPSB0aGlzLl9kXG4gIHZhciBlbCA9IHRoaXMuX2VcblxuICAvLyBNaiA9IDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVcbiAgLy8gSyA9IDB4MDAwMDAwMDBcbiAgLy8gU2ogPSAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhcbiAgYWwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzBdLCAweDAwMDAwMDAwLCAxMSk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4xKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVsxXSwgMHgwMDAwMDAwMCwgMTQpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMShkbCwgZWwsIGFsLCBibCwgY2wsIG1bMl0sIDB4MDAwMDAwMDAsIDE1KTsgYWwgPSByb3RsKGFsLCAxMClcbiAgY2wgPSBmbjEoY2wsIGRsLCBlbCwgYWwsIGJsLCBtWzNdLCAweDAwMDAwMDAwLCAxMik7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm4xKGJsLCBjbCwgZGwsIGVsLCBhbCwgbVs0XSwgMHgwMDAwMDAwMCwgNSk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4xKGFsLCBibCwgY2wsIGRsLCBlbCwgbVs1XSwgMHgwMDAwMDAwMCwgOCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4xKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs2XSwgMHgwMDAwMDAwMCwgNyk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm4xKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVs3XSwgMHgwMDAwMDAwMCwgOSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm4xKGNsLCBkbCwgZWwsIGFsLCBibCwgbVs4XSwgMHgwMDAwMDAwMCwgMTEpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMShibCwgY2wsIGRsLCBlbCwgYWwsIG1bOV0sIDB4MDAwMDAwMDAsIDEzKTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzEwXSwgMHgwMDAwMDAwMCwgMTQpOyBjbCA9IHJvdGwoY2wsIDEwKVxuICBlbCA9IGZuMShlbCwgYWwsIGJsLCBjbCwgZGwsIG1bMTFdLCAweDAwMDAwMDAwLCAxNSk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm4xKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVsxMl0sIDB4MDAwMDAwMDAsIDYpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMShjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTNdLCAweDAwMDAwMDAwLCA3KTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjEoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzE0XSwgMHgwMDAwMDAwMCwgOSk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4xKGFsLCBibCwgY2wsIGRsLCBlbCwgbVsxNV0sIDB4MDAwMDAwMDAsIDgpOyBjbCA9IHJvdGwoY2wsIDEwKVxuXG4gIC8vIE1qID0gNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOFxuICAvLyBLID0gMHg1YTgyNzk5OVxuICAvLyBTaiA9IDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMlxuICBlbCA9IGZuMihlbCwgYWwsIGJsLCBjbCwgZGwsIG1bN10sIDB4NWE4Mjc5OTksIDcpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMihkbCwgZWwsIGFsLCBibCwgY2wsIG1bNF0sIDB4NWE4Mjc5OTksIDYpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMihjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTNdLCAweDVhODI3OTk5LCA4KTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjIoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzFdLCAweDVhODI3OTk5LCAxMyk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgbVsxMF0sIDB4NWE4Mjc5OTksIDExKTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjIoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzZdLCAweDVhODI3OTk5LCA5KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjIoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzE1XSwgMHg1YTgyNzk5OSwgNyk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm4yKGNsLCBkbCwgZWwsIGFsLCBibCwgbVszXSwgMHg1YTgyNzk5OSwgMTUpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMihibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTJdLCAweDVhODI3OTk5LCA3KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjIoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzBdLCAweDVhODI3OTk5LCAxMik7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4yKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs5XSwgMHg1YTgyNzk5OSwgMTUpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMihkbCwgZWwsIGFsLCBibCwgY2wsIG1bNV0sIDB4NWE4Mjc5OTksIDkpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMihjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMl0sIDB4NWE4Mjc5OTksIDExKTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjIoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzE0XSwgMHg1YTgyNzk5OSwgNyk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgbVsxMV0sIDB4NWE4Mjc5OTksIDEzKTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjIoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzhdLCAweDVhODI3OTk5LCAxMik7IGJsID0gcm90bChibCwgMTApXG5cbiAgLy8gTWogPSAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyXG4gIC8vIEsgPSAweDZlZDllYmExXG4gIC8vIFNqID0gMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1XG4gIGRsID0gZm4zKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVszXSwgMHg2ZWQ5ZWJhMSwgMTEpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMyhjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTBdLCAweDZlZDllYmExLCAxMyk7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm4zKGJsLCBjbCwgZGwsIGVsLCBhbCwgbVsxNF0sIDB4NmVkOWViYTEsIDYpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuMyhhbCwgYmwsIGNsLCBkbCwgZWwsIG1bNF0sIDB4NmVkOWViYTEsIDcpOyBjbCA9IHJvdGwoY2wsIDEwKVxuICBlbCA9IGZuMyhlbCwgYWwsIGJsLCBjbCwgZGwsIG1bOV0sIDB4NmVkOWViYTEsIDE0KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjMoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzE1XSwgMHg2ZWQ5ZWJhMSwgOSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm4zKGNsLCBkbCwgZWwsIGFsLCBibCwgbVs4XSwgMHg2ZWQ5ZWJhMSwgMTMpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMyhibCwgY2wsIGRsLCBlbCwgYWwsIG1bMV0sIDB4NmVkOWViYTEsIDE1KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjMoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzJdLCAweDZlZDllYmExLCAxNCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4zKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs3XSwgMHg2ZWQ5ZWJhMSwgOCk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm4zKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVswXSwgMHg2ZWQ5ZWJhMSwgMTMpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMyhjbCwgZGwsIGVsLCBhbCwgYmwsIG1bNl0sIDB4NmVkOWViYTEsIDYpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMyhibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTNdLCAweDZlZDllYmExLCA1KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjMoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzExXSwgMHg2ZWQ5ZWJhMSwgMTIpOyBjbCA9IHJvdGwoY2wsIDEwKVxuICBlbCA9IGZuMyhlbCwgYWwsIGJsLCBjbCwgZGwsIG1bNV0sIDB4NmVkOWViYTEsIDcpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMyhkbCwgZWwsIGFsLCBibCwgY2wsIG1bMTJdLCAweDZlZDllYmExLCA1KTsgYWwgPSByb3RsKGFsLCAxMClcblxuICAvLyBNaiA9IDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDJcbiAgLy8gSyA9IDB4OGYxYmJjZGNcbiAgLy8gU2ogPSAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTJcbiAgY2wgPSBmbjQoY2wsIGRsLCBlbCwgYWwsIGJsLCBtWzFdLCAweDhmMWJiY2RjLCAxMSk7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm40KGJsLCBjbCwgZGwsIGVsLCBhbCwgbVs5XSwgMHg4ZjFiYmNkYywgMTIpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNChhbCwgYmwsIGNsLCBkbCwgZWwsIG1bMTFdLCAweDhmMWJiY2RjLCAxNCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm40KGVsLCBhbCwgYmwsIGNsLCBkbCwgbVsxMF0sIDB4OGYxYmJjZGMsIDE1KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjQoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzBdLCAweDhmMWJiY2RjLCAxNCk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm40KGNsLCBkbCwgZWwsIGFsLCBibCwgbVs4XSwgMHg4ZjFiYmNkYywgMTUpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuNChibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTJdLCAweDhmMWJiY2RjLCA5KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzRdLCAweDhmMWJiY2RjLCA4KTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjQoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzEzXSwgMHg4ZjFiYmNkYywgOSk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm40KGRsLCBlbCwgYWwsIGJsLCBjbCwgbVszXSwgMHg4ZjFiYmNkYywgMTQpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuNChjbCwgZGwsIGVsLCBhbCwgYmwsIG1bN10sIDB4OGYxYmJjZGMsIDUpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuNChibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTVdLCAweDhmMWJiY2RjLCA2KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzE0XSwgMHg4ZjFiYmNkYywgOCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm40KGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs1XSwgMHg4ZjFiYmNkYywgNik7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm40KGRsLCBlbCwgYWwsIGJsLCBjbCwgbVs2XSwgMHg4ZjFiYmNkYywgNSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm40KGNsLCBkbCwgZWwsIGFsLCBibCwgbVsyXSwgMHg4ZjFiYmNkYywgMTIpOyBlbCA9IHJvdGwoZWwsIDEwKVxuXG4gIC8vIE1qID0gNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuICAvLyBLID0gMHhhOTUzZmQ0ZVxuICAvLyBTaiA9IDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuICBibCA9IGZuNShibCwgY2wsIGRsLCBlbCwgYWwsIG1bNF0sIDB4YTk1M2ZkNGUsIDkpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIG1bMF0sIDB4YTk1M2ZkNGUsIDE1KTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjUoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzVdLCAweGE5NTNmZDRlLCA1KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjUoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzldLCAweGE5NTNmZDRlLCAxMSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm41KGNsLCBkbCwgZWwsIGFsLCBibCwgbVs3XSwgMHhhOTUzZmQ0ZSwgNik7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm41KGJsLCBjbCwgZGwsIGVsLCBhbCwgbVsxMl0sIDB4YTk1M2ZkNGUsIDgpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIG1bMl0sIDB4YTk1M2ZkNGUsIDEzKTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjUoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzEwXSwgMHhhOTUzZmQ0ZSwgMTIpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuNShkbCwgZWwsIGFsLCBibCwgY2wsIG1bMTRdLCAweGE5NTNmZDRlLCA1KTsgYWwgPSByb3RsKGFsLCAxMClcbiAgY2wgPSBmbjUoY2wsIGRsLCBlbCwgYWwsIGJsLCBtWzFdLCAweGE5NTNmZDRlLCAxMik7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm41KGJsLCBjbCwgZGwsIGVsLCBhbCwgbVszXSwgMHhhOTUzZmQ0ZSwgMTMpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIG1bOF0sIDB4YTk1M2ZkNGUsIDE0KTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjUoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzExXSwgMHhhOTUzZmQ0ZSwgMTEpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuNShkbCwgZWwsIGFsLCBibCwgY2wsIG1bNl0sIDB4YTk1M2ZkNGUsIDgpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuNShjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTVdLCAweGE5NTNmZDRlLCA1KTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjUoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzEzXSwgMHhhOTUzZmQ0ZSwgNik7IGRsID0gcm90bChkbCwgMTApXG5cbiAgdmFyIGFyID0gdGhpcy5fYVxuICB2YXIgYnIgPSB0aGlzLl9iXG4gIHZhciBjciA9IHRoaXMuX2NcbiAgdmFyIGRyID0gdGhpcy5fZFxuICB2YXIgZXIgPSB0aGlzLl9lXG5cbiAgLy8gTSdqID0gNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMlxuICAvLyBLJyA9IDB4NTBhMjhiZTZcbiAgLy8gUydqID0gOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2XG4gIGFyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgbVs1XSwgMHg1MGEyOGJlNiwgOCk7IGNyID0gcm90bChjciwgMTApXG4gIGVyID0gZm41KGVyLCBhciwgYnIsIGNyLCBkciwgbVsxNF0sIDB4NTBhMjhiZTYsIDkpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuNShkciwgZXIsIGFyLCBiciwgY3IsIG1bN10sIDB4NTBhMjhiZTYsIDkpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNShjciwgZHIsIGVyLCBhciwgYnIsIG1bMF0sIDB4NTBhMjhiZTYsIDExKTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjUoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzldLCAweDUwYTI4YmU2LCAxMyk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgbVsyXSwgMHg1MGEyOGJlNiwgMTUpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuNShlciwgYXIsIGJyLCBjciwgZHIsIG1bMTFdLCAweDUwYTI4YmU2LCAxNSk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm41KGRyLCBlciwgYXIsIGJyLCBjciwgbVs0XSwgMHg1MGEyOGJlNiwgNSk7IGFyID0gcm90bChhciwgMTApXG4gIGNyID0gZm41KGNyLCBkciwgZXIsIGFyLCBiciwgbVsxM10sIDB4NTBhMjhiZTYsIDcpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuNShiciwgY3IsIGRyLCBlciwgYXIsIG1bNl0sIDB4NTBhMjhiZTYsIDcpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuNShhciwgYnIsIGNyLCBkciwgZXIsIG1bMTVdLCAweDUwYTI4YmU2LCA4KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjUoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzhdLCAweDUwYTI4YmU2LCAxMSk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm41KGRyLCBlciwgYXIsIGJyLCBjciwgbVsxXSwgMHg1MGEyOGJlNiwgMTQpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNShjciwgZHIsIGVyLCBhciwgYnIsIG1bMTBdLCAweDUwYTI4YmU2LCAxNCk7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm41KGJyLCBjciwgZHIsIGVyLCBhciwgbVszXSwgMHg1MGEyOGJlNiwgMTIpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuNShhciwgYnIsIGNyLCBkciwgZXIsIG1bMTJdLCAweDUwYTI4YmU2LCA2KTsgY3IgPSByb3RsKGNyLCAxMClcblxuICAvLyBNJ2ogPSA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyXG4gIC8vIEsnID0gMHg1YzRkZDEyNFxuICAvLyBTJ2ogPSA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTFcbiAgZXIgPSBmbjQoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzZdLCAweDVjNGRkMTI0LCA5KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjQoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzExXSwgMHg1YzRkZDEyNCwgMTMpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNChjciwgZHIsIGVyLCBhciwgYnIsIG1bM10sIDB4NWM0ZGQxMjQsIDE1KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjQoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzddLCAweDVjNGRkMTI0LCA3KTsgZHIgPSByb3RsKGRyLCAxMClcbiAgYXIgPSBmbjQoYXIsIGJyLCBjciwgZHIsIGVyLCBtWzBdLCAweDVjNGRkMTI0LCAxMik7IGNyID0gcm90bChjciwgMTApXG4gIGVyID0gZm40KGVyLCBhciwgYnIsIGNyLCBkciwgbVsxM10sIDB4NWM0ZGQxMjQsIDgpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuNChkciwgZXIsIGFyLCBiciwgY3IsIG1bNV0sIDB4NWM0ZGQxMjQsIDkpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNChjciwgZHIsIGVyLCBhciwgYnIsIG1bMTBdLCAweDVjNGRkMTI0LCAxMSk7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm40KGJyLCBjciwgZHIsIGVyLCBhciwgbVsxNF0sIDB4NWM0ZGQxMjQsIDcpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuNChhciwgYnIsIGNyLCBkciwgZXIsIG1bMTVdLCAweDVjNGRkMTI0LCA3KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjQoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzhdLCAweDVjNGRkMTI0LCAxMik7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm40KGRyLCBlciwgYXIsIGJyLCBjciwgbVsxMl0sIDB4NWM0ZGQxMjQsIDcpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNChjciwgZHIsIGVyLCBhciwgYnIsIG1bNF0sIDB4NWM0ZGQxMjQsIDYpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuNChiciwgY3IsIGRyLCBlciwgYXIsIG1bOV0sIDB4NWM0ZGQxMjQsIDE1KTsgZHIgPSByb3RsKGRyLCAxMClcbiAgYXIgPSBmbjQoYXIsIGJyLCBjciwgZHIsIGVyLCBtWzFdLCAweDVjNGRkMTI0LCAxMyk7IGNyID0gcm90bChjciwgMTApXG4gIGVyID0gZm40KGVyLCBhciwgYnIsIGNyLCBkciwgbVsyXSwgMHg1YzRkZDEyNCwgMTEpOyBiciA9IHJvdGwoYnIsIDEwKVxuXG4gIC8vIE0naiA9IDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTNcbiAgLy8gSycgPSAweDZkNzAzZWYzXG4gIC8vIFMnaiA9IDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNVxuICBkciA9IGZuMyhkciwgZXIsIGFyLCBiciwgY3IsIG1bMTVdLCAweDZkNzAzZWYzLCA5KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjMoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzVdLCAweDZkNzAzZWYzLCA3KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjMoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzFdLCAweDZkNzAzZWYzLCAxNSk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4zKGFyLCBiciwgY3IsIGRyLCBlciwgbVszXSwgMHg2ZDcwM2VmMywgMTEpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMyhlciwgYXIsIGJyLCBjciwgZHIsIG1bN10sIDB4NmQ3MDNlZjMsIDgpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuMyhkciwgZXIsIGFyLCBiciwgY3IsIG1bMTRdLCAweDZkNzAzZWYzLCA2KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjMoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzZdLCAweDZkNzAzZWYzLCA2KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjMoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzldLCAweDZkNzAzZWYzLCAxNCk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4zKGFyLCBiciwgY3IsIGRyLCBlciwgbVsxMV0sIDB4NmQ3MDNlZjMsIDEyKTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjMoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzhdLCAweDZkNzAzZWYzLCAxMyk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm4zKGRyLCBlciwgYXIsIGJyLCBjciwgbVsxMl0sIDB4NmQ3MDNlZjMsIDUpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuMyhjciwgZHIsIGVyLCBhciwgYnIsIG1bMl0sIDB4NmQ3MDNlZjMsIDE0KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjMoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzEwXSwgMHg2ZDcwM2VmMywgMTMpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMyhhciwgYnIsIGNyLCBkciwgZXIsIG1bMF0sIDB4NmQ3MDNlZjMsIDEzKTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjMoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzRdLCAweDZkNzAzZWYzLCA3KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjMoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzEzXSwgMHg2ZDcwM2VmMywgNSk7IGFyID0gcm90bChhciwgMTApXG5cbiAgLy8gTSdqID0gOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNFxuICAvLyBLJyA9IDB4N2E2ZDc2ZTlcbiAgLy8gUydqID0gMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4XG4gIGNyID0gZm4yKGNyLCBkciwgZXIsIGFyLCBiciwgbVs4XSwgMHg3YTZkNzZlOSwgMTUpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuMihiciwgY3IsIGRyLCBlciwgYXIsIG1bNl0sIDB4N2E2ZDc2ZTksIDUpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMihhciwgYnIsIGNyLCBkciwgZXIsIG1bNF0sIDB4N2E2ZDc2ZTksIDgpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMihlciwgYXIsIGJyLCBjciwgZHIsIG1bMV0sIDB4N2E2ZDc2ZTksIDExKTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjIoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzNdLCAweDdhNmQ3NmU5LCAxNCk7IGFyID0gcm90bChhciwgMTApXG4gIGNyID0gZm4yKGNyLCBkciwgZXIsIGFyLCBiciwgbVsxMV0sIDB4N2E2ZDc2ZTksIDE0KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjIoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzE1XSwgMHg3YTZkNzZlOSwgNik7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4yKGFyLCBiciwgY3IsIGRyLCBlciwgbVswXSwgMHg3YTZkNzZlOSwgMTQpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMihlciwgYXIsIGJyLCBjciwgZHIsIG1bNV0sIDB4N2E2ZDc2ZTksIDYpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuMihkciwgZXIsIGFyLCBiciwgY3IsIG1bMTJdLCAweDdhNmQ3NmU5LCA5KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjIoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzJdLCAweDdhNmQ3NmU5LCAxMik7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm4yKGJyLCBjciwgZHIsIGVyLCBhciwgbVsxM10sIDB4N2E2ZDc2ZTksIDkpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMihhciwgYnIsIGNyLCBkciwgZXIsIG1bOV0sIDB4N2E2ZDc2ZTksIDEyKTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjIoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzddLCAweDdhNmQ3NmU5LCA1KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjIoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzEwXSwgMHg3YTZkNzZlOSwgMTUpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuMihjciwgZHIsIGVyLCBhciwgYnIsIG1bMTRdLCAweDdhNmQ3NmU5LCA4KTsgZXIgPSByb3RsKGVyLCAxMClcblxuICAvLyBNJ2ogPSAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG4gIC8vIEsnID0gMHgwMDAwMDAwMFxuICAvLyBTJ2ogPSA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbiAgYnIgPSBmbjEoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzEyXSwgMHgwMDAwMDAwMCwgOCk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4xKGFyLCBiciwgY3IsIGRyLCBlciwgbVsxNV0sIDB4MDAwMDAwMDAsIDUpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMShlciwgYXIsIGJyLCBjciwgZHIsIG1bMTBdLCAweDAwMDAwMDAwLCAxMik7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm4xKGRyLCBlciwgYXIsIGJyLCBjciwgbVs0XSwgMHgwMDAwMDAwMCwgOSk7IGFyID0gcm90bChhciwgMTApXG4gIGNyID0gZm4xKGNyLCBkciwgZXIsIGFyLCBiciwgbVsxXSwgMHgwMDAwMDAwMCwgMTIpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuMShiciwgY3IsIGRyLCBlciwgYXIsIG1bNV0sIDB4MDAwMDAwMDAsIDUpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIG1bOF0sIDB4MDAwMDAwMDAsIDE0KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjEoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzddLCAweDAwMDAwMDAwLCA2KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjEoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzZdLCAweDAwMDAwMDAwLCA4KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjEoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzJdLCAweDAwMDAwMDAwLCAxMyk7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm4xKGJyLCBjciwgZHIsIGVyLCBhciwgbVsxM10sIDB4MDAwMDAwMDAsIDYpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIG1bMTRdLCAweDAwMDAwMDAwLCA1KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjEoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzBdLCAweDAwMDAwMDAwLCAxNSk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm4xKGRyLCBlciwgYXIsIGJyLCBjciwgbVszXSwgMHgwMDAwMDAwMCwgMTMpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuMShjciwgZHIsIGVyLCBhciwgYnIsIG1bOV0sIDB4MDAwMDAwMDAsIDExKTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjEoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzExXSwgMHgwMDAwMDAwMCwgMTEpOyBkciA9IHJvdGwoZHIsIDEwKVxuXG4gIC8vIGNoYW5nZSBzdGF0ZVxuICB2YXIgdCA9ICh0aGlzLl9iICsgY2wgKyBkcikgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYyArIGRsICsgZXIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2QgKyBlbCArIGFyKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9lICsgYWwgKyBicikgfCAwXG4gIHRoaXMuX2UgPSAodGhpcy5fYSArIGJsICsgY3IpIHwgMFxuICB0aGlzLl9hID0gdFxufVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gMHg4MFxuICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPiA1Nikge1xuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cblxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFsxXSwgNjApXG4gIHRoaXMuX3VwZGF0ZSgpXG5cbiAgLy8gcHJvZHVjZSByZXN1bHRcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoMjApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYSwgMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZCwgMTIpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZSwgMTYpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIGZuMSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIGMgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuMiAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBjKSB8ICgofmIpICYgZCkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm4zIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiB8ICh+YykpIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjQgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgZCkgfCAoYyAmICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuNSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIChjIHwgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSSVBFTUQxNjBcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgYmxvY2tTaXplID0gdGhpcy5fYmxvY2tTaXplXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICB2YXIgYWNjdW0gPSB0aGlzLl9sZW5cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XG4gICAgdmFyIGFzc2lnbmVkID0gYWNjdW0gJSBibG9ja1NpemVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5taW4obGVuZ3RoIC0gb2Zmc2V0LCBibG9ja1NpemUgLSBhc3NpZ25lZClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgIGJsb2NrW2Fzc2lnbmVkICsgaV0gPSBkYXRhW29mZnNldCArIGldXG4gICAgfVxuXG4gICAgYWNjdW0gKz0gcmVtYWluZGVyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxuXG4gICAgaWYgKChhY2N1bSAlIGJsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9sZW4gKz0gbGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxuXG4gIHRoaXMuX2Jsb2NrW3JlbV0gPSAweDgwXG5cbiAgLy8gemVybyAocmVtICsgMSkgdHJhaWxpbmcgYml0cywgd2hlcmUgKHJlbSArIDEpIGlzIHRoZSBzbWFsbGVzdFxuICAvLyBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsZW5ndGggKyAxICsgKHJlbSArIDEpKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxuXG4gIGlmIChyZW0gPj0gdGhpcy5fZmluYWxTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIHVpbnQzMlxuICBpZiAoYml0cyA8PSAweGZmZmZmZmZmKSB7XG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShiaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIC8vIHVpbnQ2NFxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dCaXRzID0gYml0cyAmIDB4ZmZmZmZmZmZcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyMjQsIFNoYTI1NilcblxuU2hhMjI0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjMTA1OWVkOFxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nID0gMHg2NGY5OGZhN1xuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJcclxuZXhwb3J0IGNvbnN0IEJPWF9BTkNIT1JfUE9TID0ge1xyXG4gIFRPUF9MRUZUOiAxLFxyXG4gIFRPUF9SSUdIVDogMixcclxuICBCT1RUT01fUklHSFQ6IDMsXHJcbiAgQk9UVE9NX0xFRlQ6IDRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGZpdFNxdWFyZVBvaW50ID0gKG1vdmluZ1BvaW50LCBmaXhlZFBvaW50KSA9PiB7XHJcbiAgY29uc3QgbXAgICAgPSBtb3ZpbmdQb2ludFxyXG4gIGNvbnN0IGZwICAgID0gZml4ZWRQb2ludFxyXG4gIGNvbnN0IHhsZW4gID0gTWF0aC5hYnMobXAueCAtIGZwLngpXHJcbiAgY29uc3QgeWxlbiAgPSBNYXRoLmFicyhtcC55IC0gZnAueSlcclxuICBjb25zdCBsZW4gICA9IE1hdGgubWluKHhsZW4sIHlsZW4pXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBmcC54ICsgTWF0aC5zaWduKG1wLnggLSBmcC54KSAqIGxlbixcclxuICAgIHk6IGZwLnkgKyBNYXRoLnNpZ24obXAueSAtIGZwLnkpICogbGVuXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY2FsY1JlY3RBbmRBbmNob3IgPSAobW92aW5nUG9pbnQsIGZpeGVkUG9pbnQpID0+IHtcclxuICBjb25zdCBtcCA9IG1vdmluZ1BvaW50XHJcbiAgY29uc3QgZnAgPSBmaXhlZFBvaW50XHJcbiAgbGV0IHBvcyAgPSBudWxsXHJcbiAgbGV0IHRscCAgPSBudWxsXHJcblxyXG4gIGlmIChtcC54IDw9IGZwLnggJiYgbXAueSA8PSBmcC55KSB7XHJcbiAgICBwb3MgPSBCT1hfQU5DSE9SX1BPUy5UT1BfTEVGVFxyXG4gICAgdGxwID0gbXBcclxuICB9IGVsc2UgaWYgKG1wLnggPiBmcC54ICYmIG1wLnkgPiBmcC55KSB7XHJcbiAgICBwb3MgPSBCT1hfQU5DSE9SX1BPUy5CT1RUT01fUklHSFRcclxuICAgIHRscCA9IGZwXHJcbiAgfSBlbHNlIGlmIChtcC54ID4gZnAueCkge1xyXG4gICAgcG9zID0gQk9YX0FOQ0hPUl9QT1MuVE9QX1JJR0hUXHJcbiAgICB0bHAgPSB7IHg6IGZwLngsIHk6IG1wLnkgfVxyXG4gIH0gZWxzZSBpZiAobXAueSA+IGZwLnkpIHtcclxuICAgIHBvcyA9IEJPWF9BTkNIT1JfUE9TLkJPVFRPTV9MRUZUXHJcbiAgICB0bHAgPSB7IHg6IG1wLngsIHk6IGZwLnkgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlY3Q6IHtcclxuICAgICAgeDogdGxwLngsXHJcbiAgICAgIHk6IHRscC55LFxyXG4gICAgICB3aWR0aDogTWF0aC5hYnMobXAueCAtIGZwLngpLFxyXG4gICAgICBoZWlnaHQ6IE1hdGguYWJzKG1wLnkgLSBmcC55KVxyXG4gICAgfSxcclxuICAgIGFuY2hvclBvczogcG9zXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcG9pbnRBdFBvcyA9IChyZWN0LCBwb3MpID0+IHtcclxuICBzd2l0Y2ggKHBvcykge1xyXG4gICAgY2FzZSBCT1hfQU5DSE9SX1BPUy5UT1BfTEVGVDpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByZWN0LngsXHJcbiAgICAgICAgeTogcmVjdC55XHJcbiAgICAgIH1cclxuICAgIGNhc2UgQk9YX0FOQ0hPUl9QT1MuVE9QX1JJR0hUOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJlY3QueCArIHJlY3Qud2lkdGgsXHJcbiAgICAgICAgeTogcmVjdC55XHJcbiAgICAgIH1cclxuICAgIGNhc2UgQk9YX0FOQ0hPUl9QT1MuQk9UVE9NX1JJR0hUOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJlY3QueCArIHJlY3Qud2lkdGgsXHJcbiAgICAgICAgeTogcmVjdC55ICsgcmVjdC5oZWlnaHRcclxuICAgICAgfVxyXG4gICAgY2FzZSBCT1hfQU5DSE9SX1BPUy5CT1RUT01fTEVGVDpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByZWN0LngsXHJcbiAgICAgICAgeTogcmVjdC55ICsgcmVjdC5oZWlnaHRcclxuICAgICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGRpYWdvbmFsUG9zID0gKHBvcykgPT4ge1xyXG4gIHN3aXRjaCAocG9zKSB7XHJcbiAgICBjYXNlIEJPWF9BTkNIT1JfUE9TLlRPUF9MRUZUOlxyXG4gICAgICByZXR1cm4gQk9YX0FOQ0hPUl9QT1MuQk9UVE9NX1JJR0hUXHJcblxyXG4gICAgY2FzZSBCT1hfQU5DSE9SX1BPUy5UT1BfUklHSFQ6XHJcbiAgICAgIHJldHVybiBCT1hfQU5DSE9SX1BPUy5CT1RUT01fTEVGVFxyXG5cclxuICAgIGNhc2UgQk9YX0FOQ0hPUl9QT1MuQk9UVE9NX1JJR0hUOlxyXG4gICAgICByZXR1cm4gQk9YX0FOQ0hPUl9QT1MuVE9QX0xFRlRcclxuXHJcbiAgICBjYXNlIEJPWF9BTkNIT1JfUE9TLkJPVFRPTV9MRUZUOlxyXG4gICAgICByZXR1cm4gQk9YX0FOQ0hPUl9QT1MuVE9QX1JJR0hUXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGlhZ29uYWxQb2ludCA9IChyZWN0LCBhbmNob3JQb3MpID0+IHtcclxuICByZXR1cm4gcG9pbnRBdFBvcyhyZWN0LCBkaWFnb25hbFBvcyhhbmNob3JQb3MpKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuR2V0QW5jaG9yUmVjdHMgPSAoQU5DSE9SX1BPUywgcG9pbnRBdFBvcykgPT4gKHsgcmVjdCwgc2l6ZSA9IDUgfSkgPT4ge1xyXG4gIGNvbnN0IHZhbHVlcyA9IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiBvYmpba2V5XSlcclxuICBjb25zdCBjcmVhdGVSZWN0ID0gKHBvaW50LCBzaXplKSA9PiAoe1xyXG4gICAgeDogcG9pbnQueCAtIHNpemUsXHJcbiAgICB5OiBwb2ludC55IC0gc2l6ZSxcclxuICAgIHdpZHRoOiBzaXplICogMixcclxuICAgIGhlaWdodDogc2l6ZSAqIDJcclxuICB9KVxyXG5cclxuICByZXR1cm4gdmFsdWVzKEFOQ0hPUl9QT1MpLm1hcChwb3MgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYW5jaG9yUG9zOiBwb3MsXHJcbiAgICAgIHJlY3Q6IGNyZWF0ZVJlY3QocG9pbnRBdFBvcyhyZWN0LCBwb3MpLCBzaXplKVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBbmNob3JSZWN0cyA9IGdlbkdldEFuY2hvclJlY3RzKEJPWF9BTkNIT1JfUE9TLCBwb2ludEF0UG9zKVxyXG5cclxuZXhwb3J0IGNsYXNzIEJveCB7XHJcbiAgLy8gTm90ZTogcG9zc2libGUgc2V0dGluZ3NcclxuICBzdGF0aWMgc2V0dGluZ3MgPSBbXVxyXG4gIHN0YXRpYyBjYXRlZ29yeSA9ICdyZWN0J1xyXG4gIHN0YXRpYyBkZWZhdWx0QW5jaG9yUG9zID0gQk9YX0FOQ0hPUl9QT1MuQk9UVE9NX1JJR0hUXHJcblxyXG4gIHN0YXRlID0ge1xyXG4gICAgdHlwZTogJ2JveCcsXHJcbiAgICBkYXRhOiBudWxsLFxyXG4gICAgc3R5bGU6IHt9LFxyXG4gICAgcmVjdDoge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwLFxyXG4gICAgICB3aWR0aDogMCxcclxuICAgICAgaGVpZ2h0OiAwXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2NhbCA9IHt9XHJcblxyXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIGZpcnN0U2lsZW5jZTogdHJ1ZSxcclxuICAgICAgdHJhbnNmb3JtOiB4ID0+IHgsXHJcbiAgICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9XHJcbiAgICB9LCBvcHRpb25zKVxyXG5cclxuICAgIHRoaXMudHJhbnNmb3JtID0gb3B0cy50cmFuc2Zvcm1cclxuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9wdHMub25TdGF0ZUNoYW5nZVxyXG4gICAgdGhpcy5ub3JtYWxpemVSZWN0ID0gb3B0cy5ub3JtYWxpemVSZWN0IHx8ICh4ID0+IHgpXHJcblxyXG4gICAgdGhpcy5fX3NldFN0YXRlKHtcclxuICAgICAgaWQ6ICAgICBvcHRzLmlkLFxyXG4gICAgICBkYXRhOiAgIG9wdHMuZGF0YSxcclxuICAgICAgdHlwZTogICB0aGlzLmdldFR5cGUoKSxcclxuICAgICAgc3R5bGU6ICB0aGlzLmdldERlZmF1bHRTdHlsZSgpLFxyXG4gICAgICBjYXRlZ29yeTogdGhpcy5nZXRDYXRlZ29yeSgpLFxyXG4gICAgICByZWN0OiB7XHJcbiAgICAgICAgeDogICAgICBvcHRzLngsXHJcbiAgICAgICAgeTogICAgICBvcHRzLnksXHJcbiAgICAgICAgd2lkdGg6ICBvcHRzLndpZHRoIHx8IDAsXHJcbiAgICAgICAgaGVpZ2h0OiBvcHRzLmhlaWdodCB8fCAwXHJcbiAgICAgIH1cclxuICAgIH0sIHsgc2lsZW50OiBvcHRzLmZpcnN0U2lsZW5jZSB9KVxyXG4gIH1cclxuXHJcbiAgZ2V0VHlwZSAoKSB7XHJcbiAgICByZXR1cm4gJ2JveCdcclxuICB9XHJcblxyXG4gIGdldENhdGVnb3J5ICgpIHtcclxuICAgIHJldHVybiBCb3guY2F0ZWdvcnlcclxuICB9XHJcblxyXG4gIGdldERlZmF1bHRBbmNob3JQb3MgKCkge1xyXG4gICAgcmV0dXJuIEJPWF9BTkNIT1JfUE9TLkJPVFRPTV9SSUdIVFxyXG4gIH1cclxuXHJcbiAgZ2V0RGVmYXVsdFN0eWxlICgpIHtcclxuICAgIHJldHVybiB7fVxyXG4gIH1cclxuXHJcbiAgZ2V0SWQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWRcclxuICB9XHJcblxyXG4gIGdldFN0YXRlICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzLnN0YXRlKVxyXG4gIH1cclxuXHJcbiAgcHJvY2Vzc0luY29taW5nU3R5bGUgKHN0eWxlKSB7XHJcbiAgICByZXR1cm4gc3R5bGVcclxuICB9XHJcblxyXG4gIHNldFN0eWxlIChvYmopIHtcclxuICAgIHRoaXMuX19zZXRTdGF0ZSh7XHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5zdHlsZSxcclxuICAgICAgICAuLi50aGlzLnByb2Nlc3NJbmNvbWluZ1N0eWxlKG9iailcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHNldERhdGEgKGRhdGEpIHtcclxuICAgIHRoaXMuX19zZXRTdGF0ZSh7IGRhdGEgfSlcclxuICB9XHJcblxyXG4gIG1vdmVBbmNob3JTdGFydCAoeyBhbmNob3JQb3MgfSkge1xyXG4gICAgdGhpcy5fX3NldExvY2FsKHtcclxuICAgICAgb2xkUG9pbnQ6ICAgICBwb2ludEF0UG9zKHRoaXMuc3RhdGUucmVjdCwgYW5jaG9yUG9zKSxcclxuICAgICAgb2xkQW5jaG9yUG9zOiBhbmNob3JQb3MsXHJcbiAgICAgIGFuY2hvclBvczogICAgYW5jaG9yUG9zXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgbW92ZUFuY2hvciAoeyB4LCB5IH0sIHsgZml0IH0gPSB7fSkge1xyXG4gICAgY29uc3Qgb2xkICAgICA9IHRoaXMuc3RhdGUucmVjdFxyXG4gICAgY29uc3QgcG9zICAgICA9IHRoaXMubG9jYWwuYW5jaG9yUG9zXHJcbiAgICBjb25zdCBmaXhlZCAgID0gZGlhZ29uYWxQb2ludChvbGQsIHBvcylcclxuICAgIGNvbnN0IG1vdmluZyAgPSAhZml0ID8geyB4LCB5IH0gOiBmaXRTcXVhcmVQb2ludCh7IHgsIHkgfSwgZml4ZWQpXHJcbiAgICBjb25zdCByZXMgICAgID0gY2FsY1JlY3RBbmRBbmNob3IobW92aW5nLCBmaXhlZClcclxuXHJcbiAgICB0aGlzLl9fc2V0TG9jYWwoeyBhbmNob3JQb3M6IHJlcy5hbmNob3JQb3MgfSlcclxuICAgIHRoaXMuX19zZXRTdGF0ZSh7IHJlY3Q6IHRoaXMubm9ybWFsaXplUmVjdChyZXMucmVjdCwgJ21vdmVBbmNob3InKSB9KVxyXG4gIH1cclxuXHJcbiAgbW92ZUFuY2hvckVuZCAoKSB7XHJcbiAgICB0aGlzLl9fc2V0TG9jYWwoe1xyXG4gICAgICBvbGRQb2ludDogICAgIG51bGwsXHJcbiAgICAgIG9sZEFuY2hvclBvczogbnVsbCxcclxuICAgICAgYW5jaG9yUG9zOiAgICBudWxsXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgbW92ZUJveFN0YXJ0ICgpIHtcclxuICAgIHRoaXMuX19zZXRMb2NhbCh7XHJcbiAgICAgIG9sZFJlY3Q6IHsgLi4udGhpcy5zdGF0ZS5yZWN0IH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBtb3ZlQm94ICh7IGR4LCBkeSB9KSB7XHJcbiAgICBjb25zdCBvbGQgPSB0aGlzLmxvY2FsLm9sZFJlY3RcclxuICAgIGNvbnN0IHVwZCA9IHtcclxuICAgICAgLi4ub2xkLFxyXG4gICAgICB4OiBvbGQueCArIGR4LFxyXG4gICAgICB5OiBvbGQueSArIGR5XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX3NldFN0YXRlKHsgcmVjdDogdGhpcy5ub3JtYWxpemVSZWN0KHVwZCwgJ21vdmVCb3gnKSB9KVxyXG4gIH1cclxuXHJcbiAgbW92ZUJveEVuZCAoKSB7XHJcbiAgICB0aGlzLl9fc2V0TG9jYWwoe1xyXG4gICAgICBvbGRSZWN0OiBudWxsXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgX19zZXRTdGF0ZSAob2JqLCBvcHRzID0ge30pIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmdldFN0YXRlKClcclxuXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAuLi50aGlzLnN0YXRlLFxyXG4gICAgICAuLi5vYmpcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0cy5zaWxlbnQpICByZXR1cm5cclxuXHJcbiAgICBjb25zdCBmbiAgICAgID0gKCkgPT4gdGhpcy5vblN0YXRlQ2hhbmdlKHRoaXMuZ2V0U3RhdGUoKSwgbGFzdClcclxuICAgIGNvbnN0IGludm9rZSAgPSBvcHRzLm5leHRUaWNrID8gKGZuKSA9PiBzZXRUaW1lb3V0KGZuLCAwKSA6IChmbikgPT4gZm4oKVxyXG5cclxuICAgIGludm9rZShmbilcclxuICB9XHJcblxyXG4gIF9fc2V0TG9jYWwgKG9iaikge1xyXG4gICAgdGhpcy5sb2NhbCA9IHtcclxuICAgICAgLi4udGhpcy5sb2NhbCxcclxuICAgICAgLi4ub2JqXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBFeHQgZnJvbSAnLi93ZWJfZXh0ZW5zaW9uJ1xyXG5pbXBvcnQgZnMgZnJvbSAnLi9maWxlc3lzdGVtJ1xyXG5pbXBvcnQgeyBnZXRTY3JlZW5zaG90TWFuIH0gZnJvbSAnLi4vY29tbW9uL3NjcmVlbnNob3RfbWFuJ1xyXG5pbXBvcnQgeyBkZWxheSwgZGF0YVVSSXRvQmxvYiB9IGZyb20gJy4uL2NvbW1vbi91dGlscydcclxuXHJcbmZ1bmN0aW9uIGdldEFjdGl2ZVRhYkluZm8gKCkge1xyXG4gIHJldHVybiBFeHQud2luZG93cy5nZXRMYXN0Rm9jdXNlZCgpXHJcbiAgLnRoZW4od2luID0+IHtcclxuICAgIHJldHVybiBFeHQudGFicy5xdWVyeSh7IGFjdGl2ZTogdHJ1ZSwgd2luZG93SWQ6IHdpbi5pZCB9KVxyXG4gICAgLnRoZW4odGFicyA9PiB0YWJzWzBdKVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVNpemVGcm9tRGF0YVVSSSAoZGF0YVVSSSkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxyXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgd2lkdGg6IGltZy5uYXR1cmFsV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBpbWcubmF0dXJhbEhlaWdodFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gICAgaW1nLnNyYyA9IGRhdGFVUklcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NyZWVuc2hvdFJhdGlvIChkYXRhVVJJLCB0YWJJZCwgZGV2aWNlUGl4ZWxSYXRpbykge1xyXG4gIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICBpbWFnZVNpemVGcm9tRGF0YVVSSShkYXRhVVJJKSxcclxuICAgIEV4dC50YWJzLmdldCh0YWJJZClcclxuICBdKVxyXG4gIC50aGVuKHR1cGxlID0+IHtcclxuICAgIGNvbnN0IFtzaXplLCB0YWJdID0gdHVwbGVcclxuICAgIHJldHVybiB0YWIud2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvIC8gc2l6ZS53aWR0aFxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZURhdGFVUkkgKGRhdGFVUkksIHNjYWxlKSB7XHJcbiAgaWYgKHNjYWxlID09PSAxKSAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhVVJJKVxyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcclxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgIHJlc29sdmUoaW1nKVxyXG4gICAgfVxyXG4gICAgaW1nLnNyYyA9IGRhdGFVUklcclxuICB9KVxyXG4gIC50aGVuKGltZyA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoaW1nLm5hdHVyYWxXaWR0aCwgaW1nLm5hdHVyYWxIZWlnaHQsIHNjYWxlKVxyXG4gICAgcmV0dXJuIGRyYXdPbkNhbnZhcyh7XHJcbiAgICAgIGNhbnZhcyxcclxuICAgICAgZGF0YVVSSSxcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMCxcclxuICAgICAgd2lkdGg6ICBpbWcubmF0dXJhbFdpZHRoICogc2NhbGUsXHJcbiAgICAgIGhlaWdodDogaW1nLm5hdHVyYWxIZWlnaHQgKiBzY2FsZVxyXG4gICAgfSlcclxuICAgIC50aGVuKCgpID0+IGNhbnZhcy50b0RhdGFVUkwoKSlcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZVNjcmVlbiAodGFiSWQsIHByZXNldFNjcmVlbnNob3RSYXRpbykge1xyXG4gIGNvbnN0IGlzMm5kQXJnRnVuY3Rpb24gICAgPSB0eXBlb2YgcHJlc2V0U2NyZWVuc2hvdFJhdGlvID09PSAnZnVuY3Rpb24nXHJcbiAgY29uc3QgaGFzU2NyZWVuc2hvdFJhdGlvICA9IHByZXNldFNjcmVlbnNob3RSYXRpbyAmJiAhaXMybmRBcmdGdW5jdGlvblxyXG4gIGNvbnN0IHBEYXRhVVJJICA9IEV4dC50YWJzLmNhcHR1cmVWaXNpYmxlVGFiKG51bGwsIHsgZm9ybWF0OiAncG5nJyB9KVxyXG4gIGNvbnN0IHBSYXRpbyAgICA9IGhhc1NjcmVlbnNob3RSYXRpbyAgPyBQcm9taXNlLnJlc29sdmUocHJlc2V0U2NyZWVuc2hvdFJhdGlvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwRGF0YVVSSS50aGVuKGRhdGFVUkkgPT4gZ2V0U2NyZWVuc2hvdFJhdGlvKGRhdGFVUkksIHRhYklkLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykpXHJcblxyXG4gIHJldHVybiBQcm9taXNlLmFsbChbcERhdGFVUkksIHBSYXRpb10pXHJcbiAgLnRoZW4odHVwbGUgPT4ge1xyXG4gICAgY29uc3QgW2RhdGFVUkksIHNjcmVlbnNob3RSYXRpb10gPSB0dXBsZVxyXG4gICAgLy8gTm90ZTogbGVhayB0aGUgaW5mbyBhYm91dCBzY3JlZW5zaG90UmF0aW8gb24gcHVycG9zZVxyXG4gICAgaWYgKCFoYXNTY3JlZW5zaG90UmF0aW8gJiYgaXMybmRBcmdGdW5jdGlvbikgcHJlc2V0U2NyZWVuc2hvdFJhdGlvKHNjcmVlbnNob3RSYXRpbylcclxuICAgIGlmIChzY3JlZW5zaG90UmF0aW8gPT09IDEpICByZXR1cm4gZGF0YVVSSVxyXG4gICAgcmV0dXJuIHNjYWxlRGF0YVVSSShkYXRhVVJJLCBzY3JlZW5zaG90UmF0aW8pXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVTY3JlZW5XaXRoQ2FjaGVkU2NyZWVuc2hvdFJhdGlvICgpIHtcclxuICBsZXQgc2NyZWVuc2hvdFJhdGlvXHJcblxyXG4gIHJldHVybiAodGFiSWQpID0+IHtcclxuICAgIHJldHVybiBjYXB0dXJlU2NyZWVuKHRhYklkLCBzY3JlZW5zaG90UmF0aW8gfHwgZnVuY3Rpb24gKHJhdGlvKSB7IHNjcmVlbnNob3RSYXRpbyA9IHJhdGlvIH0pXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYXB0dXJlU2NyZWVuQmxvYiAodGFiSWQpIHtcclxuICByZXR1cm4gY2FwdHVyZVNjcmVlbih0YWJJZCkudGhlbihkYXRhVVJJdG9CbG9iKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVNjcmVlbiAodGFiSWQsIGZpbGVOYW1lKSB7XHJcbiAgcmV0dXJuIGNhcHR1cmVTY3JlZW5CbG9iKHRhYklkKVxyXG4gIC50aGVuKHNjcmVlbkJsb2IgPT4ge1xyXG4gICAgcmV0dXJuIGdldFNjcmVlbnNob3RNYW4oKS5vdmVyd3JpdGUoZmlsZU5hbWUsIHNjcmVlbkJsb2IpXHJcbiAgICAudGhlbih1cmwgPT4gKHtcclxuICAgICAgdXJsLFxyXG4gICAgICBmaWxlTmFtZVxyXG4gICAgfSkpXHJcbiAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gcENvbXBvc2UgKGxpc3QpIHtcclxuICByZXR1cm4gbGlzdC5yZWR1Y2UoKHByZXYsIGZuKSA9PiB7XHJcbiAgICByZXR1cm4gcHJldi50aGVuKGZuKVxyXG4gIH0sIFByb21pc2UucmVzb2x2ZSgpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbGxTY3JvbGxPZmZzZXRzICh7IHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCwgdG9wUGFkZGluZyA9IDE1MCB9KSB7XHJcbiAgY29uc3QgdG9wUGFkICA9IHdpbmRvd0hlaWdodCA+IHRvcFBhZGRpbmcgPyB0b3BQYWRkaW5nIDogMFxyXG4gIGNvbnN0IHhTdGVwICAgPSB3aW5kb3dXaWR0aFxyXG4gIGNvbnN0IHlTdGVwICAgPSB3aW5kb3dIZWlnaHQgLSB0b3BQYWRcclxuICBjb25zdCByZXN1bHQgID0gW11cclxuXHJcbiAgLy8gTm90ZTogYm90dG9tIGNvbWVzIGZpcnN0IHNvIHRoYXQgd2hlbiB3ZSByZW5kZXIgdGhvc2Ugc2NyZWVuc2hvdHMgb25lIGJ5IG9uZSB0byB0aGUgZmluYWwgY2FudmFzLFxyXG4gIC8vIHRob3NlIGF0IHRvcCB3aWxsIG92ZXJ3cml0ZSB0b3AgcGFkZGluZyBwYXJ0IG9mIHRob3NlIGF0IGJvdHRvbSwgaXQgaXMgdXNlZnVsIGlmIHRoYXQgcGFnZSBoYXMgc29tZSBmaXhlZCBoZWFkZXJcclxuICBmb3IgKGxldCB5ID0gcGFnZUhlaWdodCAtIHdpbmRvd0hlaWdodDsgeSA+IC0xICogeVN0ZXA7IHkgLT0geVN0ZXApIHtcclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgcGFnZVdpZHRoOyB4ICs9IHhTdGVwKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKHsgeCwgeSB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdFxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbGxTY3JvbGxPZmZzZXRzRm9yUmVjdCAoXHJcbiAgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0sXHJcbiAgeyBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHdpbmRvd1dpZHRoLCB3aW5kb3dIZWlnaHQsIG9yaWdpbmFsWCwgb3JpZ2luYWxZLCB0b3BQYWRkaW5nID0gMTUwIH1cclxuKSB7XHJcbiAgY29uc3QgdG9wUGFkICA9IHdpbmRvd0hlaWdodCA+IHRvcFBhZGRpbmcgPyB0b3BQYWRkaW5nIDogMFxyXG4gIGNvbnN0IHhTdGVwICAgPSB3aW5kb3dXaWR0aFxyXG4gIGNvbnN0IHlTdGVwICAgPSB3aW5kb3dIZWlnaHQgLSB0b3BQYWRcclxuICBjb25zdCByZXN1bHQgID0gW11cclxuXHJcbiAgZm9yIChsZXQgc3kgPSB5ICsgaGVpZ2h0IC0gd2luZG93SGVpZ2h0OyBzeSA+IHkgLSB5U3RlcDsgc3kgLT0geVN0ZXApIHtcclxuICAgIGZvciAobGV0IHN4ID0geDsgc3ggPCB4ICsgd2lkdGg7IHN4ICs9IHhTdGVwKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKHsgeDogc3gsIHk6IHN5IH0pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmVzdWx0LnB1c2goeyB4OiB4LCB5OiB5ICsgaGVpZ2h0IC0gd2luZG93SGVpZ2h0IH0pXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyAod2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyA9IDEpIHtcclxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gIGNhbnZhcy53aWR0aCAgPSB3aWR0aCAqIHBpeGVsUmF0aW9cclxuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpb1xyXG4gIHJldHVybiBjYW52YXNcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd09uQ2FudmFzICh7IGNhbnZhcywgZGF0YVVSSSwgeCwgeSwgd2lkdGgsIGhlaWdodCB9KSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcclxuXHJcbiAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgeCwgeSwgd2lkdGggfHwgaW1hZ2Uud2lkdGgsIGhlaWdodCB8fCBpbWFnZS5oZWlnaHQpXHJcbiAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHRcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBpbWFnZS5zcmMgPSBkYXRhVVJJXHJcbiAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gd2l0aFBhZ2VJbmZvIChzdGFydENhcHR1cmUsIGVuZENhcHR1cmUsIGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIHN0YXJ0Q2FwdHVyZSgpXHJcbiAgLnRoZW4ocGFnZUluZm8gPT4ge1xyXG4gICAgLy8gTm90ZTogaW4gY2FzZSBzZW5kZXIgY29udGFpbnMgYW55IG5vbi1zZXJpYWxpemFibGUgZGF0YVxyXG4gICAgZGVsZXRlIHBhZ2VJbmZvLnNlbmRlclxyXG5cclxuICAgIHJldHVybiBjYWxsYmFjayhwYWdlSW5mbylcclxuICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgIGVuZENhcHR1cmUocGFnZUluZm8pXHJcbiAgICAgIHJldHVybiByZXN1bHRcclxuICAgIH0pXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVGdWxsU2NyZWVuICh0YWJJZCwgeyBzdGFydENhcHR1cmUsIHNjcm9sbFBhZ2UsIGVuZENhcHR1cmUgfSA9IGNhcHR1cmVDbGllbnRBUEksIG9wdGlvbnMgPSB7fSkge1xyXG4gIGNvbnN0IG9wdHMgPSB7XHJcbiAgICBibG9iOiBmYWxzZSxcclxuICAgIC4uLm9wdGlvbnNcclxuICB9XHJcblxyXG4gIHJldHVybiB3aXRoUGFnZUluZm8oc3RhcnRDYXB0dXJlLCBlbmRDYXB0dXJlLCBwYWdlSW5mbyA9PiB7XHJcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gcGFnZUluZm8uZGV2aWNlUGl4ZWxSYXRpb1xyXG5cclxuICAgIC8vIE5vdGU6IGN1dCBkb3duIHBhZ2Ugd2lkdGggYW5kIGhlaWdodFxyXG4gICAgLy8gcmVmZXJlbmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDgxNDgzL21heGltdW0tc2l6ZS1vZi1hLWNhbnZhcy1lbGVtZW50LzExNTg1OTM5IzExNTg1OTM5XHJcbiAgICBjb25zdCBtYXhTaWRlICAgICAgID0gTWF0aC5mbG9vcigzMjc2NyAvIGRldmljZVBpeGVsUmF0aW8pXHJcbiAgICBwYWdlSW5mby5wYWdlV2lkdGggID0gTWF0aC5taW4obWF4U2lkZSwgcGFnZUluZm8ucGFnZVdpZHRoKVxyXG4gICAgcGFnZUluZm8ucGFnZUhlaWdodCA9IE1hdGgubWluKG1heFNpZGUsIHBhZ2VJbmZvLnBhZ2VIZWlnaHQpXHJcblxyXG4gICAgY29uc3QgY2FwdHVyZVNjcmVlbiA9IGNyZWF0ZUNhcHR1cmVTY3JlZW5XaXRoQ2FjaGVkU2NyZWVuc2hvdFJhdGlvKClcclxuICAgIGNvbnN0IGNhbnZhcyAgICAgICAgPSBjcmVhdGVDYW52YXMocGFnZUluZm8ucGFnZVdpZHRoLCBwYWdlSW5mby5wYWdlSGVpZ2h0LCBkZXZpY2VQaXhlbFJhdGlvKVxyXG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IGdldEFsbFNjcm9sbE9mZnNldHMocGFnZUluZm8pXHJcbiAgICBjb25zdCB0b2RvcyAgICAgICAgID0gc2Nyb2xsT2Zmc2V0cy5tYXAoKG9mZnNldCwgaSkgPT4gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gc2Nyb2xsUGFnZShvZmZzZXQsIHsgaW5kZXg6IGksIHRvdGFsOiBzY3JvbGxPZmZzZXRzLmxlbmd0aCB9KVxyXG4gICAgICAudGhlbihyZWFsT2Zmc2V0ID0+IHtcclxuICAgICAgICByZXR1cm4gY2FwdHVyZVNjcmVlbih0YWJJZClcclxuICAgICAgICAudGhlbihkYXRhVVJJID0+IGRyYXdPbkNhbnZhcyh7XHJcbiAgICAgICAgICBjYW52YXMsXHJcbiAgICAgICAgICBkYXRhVVJJLFxyXG4gICAgICAgICAgeDogICAgICByZWFsT2Zmc2V0LnggKiBkZXZpY2VQaXhlbFJhdGlvLFxyXG4gICAgICAgICAgeTogICAgICByZWFsT2Zmc2V0LnkgKiBkZXZpY2VQaXhlbFJhdGlvLFxyXG4gICAgICAgICAgd2lkdGg6ICBwYWdlSW5mby53aW5kb3dXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8sXHJcbiAgICAgICAgICBoZWlnaHQ6IHBhZ2VJbmZvLndpbmRvd0hlaWdodCAqIGRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICB9KSlcclxuICAgICAgfSlcclxuICAgIH0pXHJcbiAgICBjb25zdCBjb252ZXJ0ID0gb3B0cy5ibG9iID8gZGF0YVVSSXRvQmxvYiA6IHggPT4geFxyXG5cclxuICAgIHJldHVybiBwQ29tcG9zZSh0b2RvcylcclxuICAgIC50aGVuKCgpID0+IGNvbnZlcnQoY2FudmFzLnRvRGF0YVVSTCgpKSlcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZVNjcmVlbkluU2VsZWN0aW9uU2ltcGxlICh0YWJJZCwgeyByZWN0LCBkZXZpY2VQaXhlbFJhdGlvIH0sIG9wdGlvbnMgPSB7fSkge1xyXG4gIGNvbnN0IG9wdHMgPSB7XHJcbiAgICBibG9iOiBmYWxzZSxcclxuICAgIC4uLm9wdGlvbnNcclxuICB9XHJcbiAgY29uc3QgY29udmVydCA9IG9wdHMuYmxvYiA/IGRhdGFVUkl0b0Jsb2IgOiB4ID0+IHhcclxuICBjb25zdCByYXRpbyAgID0gZGV2aWNlUGl4ZWxSYXRpb1xyXG4gIGNvbnN0IGNhbnZhcyAgPSBjcmVhdGVDYW52YXMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHJhdGlvKVxyXG5cclxuICByZXR1cm4gY2FwdHVyZVNjcmVlbih0YWJJZClcclxuICAudGhlbihkYXRhVVJJID0+IGRyYXdPbkNhbnZhcyh7XHJcbiAgICBjYW52YXMsXHJcbiAgICBkYXRhVVJJLFxyXG4gICAgeDogICAgICAtMSAqIHJlY3QueCAqIGRldmljZVBpeGVsUmF0aW8sXHJcbiAgICB5OiAgICAgIC0xICogcmVjdC55ICogZGV2aWNlUGl4ZWxSYXRpb1xyXG4gIH0pKVxyXG4gIC50aGVuKCgpID0+IGNvbnZlcnQoY2FudmFzLnRvRGF0YVVSTCgpKSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVTY3JlZW5JblNlbGVjdGlvbiAodGFiSWQsIHsgcmVjdCwgZGV2aWNlUGl4ZWxSYXRpbyB9LCB7IHN0YXJ0Q2FwdHVyZSwgc2Nyb2xsUGFnZSwgZW5kQ2FwdHVyZSB9LCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCBvcHRzID0ge1xyXG4gICAgYmxvYjogZmFsc2UsXHJcbiAgICAuLi5vcHRpb25zXHJcbiAgfVxyXG4gIGNvbnN0IGNvbnZlcnQgPSBvcHRzLmJsb2IgPyBkYXRhVVJJdG9CbG9iIDogeCA9PiB4XHJcbiAgY29uc3QgcmF0aW8gICA9IGRldmljZVBpeGVsUmF0aW9cclxuXHJcbiAgcmV0dXJuIHdpdGhQYWdlSW5mbyhzdGFydENhcHR1cmUsIGVuZENhcHR1cmUsIHBhZ2VJbmZvID0+IHtcclxuICAgIGNvbnN0IG1heFNpZGUgICAgICAgPSBNYXRoLmZsb29yKDMyNzY3IC8gcmF0aW8pXHJcbiAgICBwYWdlSW5mby5wYWdlV2lkdGggID0gTWF0aC5taW4obWF4U2lkZSwgcGFnZUluZm8ucGFnZVdpZHRoKVxyXG4gICAgcGFnZUluZm8ucGFnZUhlaWdodCA9IE1hdGgubWluKG1heFNpZGUsIHBhZ2VJbmZvLnBhZ2VIZWlnaHQpXHJcblxyXG4gICAgY29uc3QgY2FwdHVyZVNjcmVlbiA9IGNyZWF0ZUNhcHR1cmVTY3JlZW5XaXRoQ2FjaGVkU2NyZWVuc2hvdFJhdGlvKClcclxuICAgIGNvbnN0IGNhbnZhcyAgICAgICAgPSBjcmVhdGVDYW52YXMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHJhdGlvKVxyXG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IGdldEFsbFNjcm9sbE9mZnNldHNGb3JSZWN0KHJlY3QsIHBhZ2VJbmZvKVxyXG4gICAgY29uc3QgdG9kb3MgICAgICAgICA9IHNjcm9sbE9mZnNldHMubWFwKChvZmZzZXQsIGkpID0+ICgpID0+IHtcclxuICAgICAgcmV0dXJuIHNjcm9sbFBhZ2Uob2Zmc2V0LCB7IGluZGV4OiBpLCB0b3RhbDogc2Nyb2xsT2Zmc2V0cy5sZW5ndGggfSlcclxuICAgICAgLnRoZW4ocmVhbE9mZnNldCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhcHR1cmVTY3JlZW4odGFiSWQpXHJcbiAgICAgICAgLnRoZW4oZGF0YVVSSSA9PiBkcmF3T25DYW52YXMoe1xyXG4gICAgICAgICAgY2FudmFzLFxyXG4gICAgICAgICAgZGF0YVVSSSxcclxuICAgICAgICAgIHg6ICAgICAgKHJlYWxPZmZzZXQueCAtIHJlY3QueCkgKiBkZXZpY2VQaXhlbFJhdGlvLFxyXG4gICAgICAgICAgeTogICAgICAocmVhbE9mZnNldC55IC0gcmVjdC55KSAqIGRldmljZVBpeGVsUmF0aW8sXHJcbiAgICAgICAgICB3aWR0aDogIHBhZ2VJbmZvLndpbmRvd1dpZHRoICogZGV2aWNlUGl4ZWxSYXRpbyxcclxuICAgICAgICAgIGhlaWdodDogcGFnZUluZm8ud2luZG93SGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpb1xyXG4gICAgICAgIH0pKVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gcENvbXBvc2UodG9kb3MpXHJcbiAgICAudGhlbigoKSA9PiBjb252ZXJ0KGNhbnZhcy50b0RhdGFVUkwoKSkpXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNhcHR1cmVDbGllbnRBUEkgPSB7XHJcbiAgZ2V0UGFnZUluZm86ICgpID0+IHtcclxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5XHJcbiAgICBjb25zdCB3aWR0aHMgPSBbXHJcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcclxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoLFxyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGgsXHJcbiAgICAgIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCxcclxuICAgICAgYm9keSA/IGJvZHkub2Zmc2V0V2lkdGggOiAwXHJcbiAgICBdXHJcbiAgICBjb25zdCBoZWlnaHRzID0gW1xyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxyXG4gICAgICBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLFxyXG4gICAgICBib2R5ID8gYm9keS5vZmZzZXRIZWlnaHQgOiAwXHJcbiAgICBdXHJcblxyXG4gICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgcGFnZVdpZHRoOiAgICBNYXRoLm1heCguLi53aWR0aHMpLFxyXG4gICAgICBwYWdlSGVpZ2h0OiAgIE1hdGgubWF4KC4uLmhlaWdodHMpLFxyXG4gICAgICB3aW5kb3dXaWR0aDogIHdpbmRvdy5pbm5lcldpZHRoLFxyXG4gICAgICB3aW5kb3dIZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcclxuICAgICAgaGFzQm9keTogICAgICAhIWJvZHksXHJcbiAgICAgIG9yaWdpbmFsWDogICAgd2luZG93LnNjcm9sbFgsXHJcbiAgICAgIG9yaWdpbmFsWTogICAgd2luZG93LnNjcm9sbFksXHJcbiAgICAgIG9yaWdpbmFsT3ZlcmZsb3dTdHlsZTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93LFxyXG4gICAgICBvcmlnaW5hbEJvZHlPdmVyZmxvd1lTdHlsZTogYm9keSAmJiBib2R5LnN0eWxlLm92ZXJmbG93WSxcclxuICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogd2luZG93LmRldmljZVBpeGVsUmF0aW9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gIH0sXHJcbiAgc3RhcnRDYXB0dXJlOiAoeyBoaWRlU2Nyb2xsYmFyID0gdHJ1ZSB9ID0ge30pID0+IHtcclxuICAgIGNvbnN0IGJvZHkgICAgICA9IGRvY3VtZW50LmJvZHlcclxuICAgIGNvbnN0IHBhZ2VJbmZvICA9IGNhcHR1cmVDbGllbnRBUEkuZ2V0UGFnZUluZm8oKVxyXG5cclxuICAgIC8vIE5vdGU6IHRyeSB0byBtYWtlIHBhZ2VzIHdpdGggYmFkIHNjcm9sbGluZyB3b3JrLCBlLmcuLCBvbmVzIHdpdGhcclxuICAgIC8vIGBib2R5IHsgb3ZlcmZsb3cteTogc2Nyb2xsOyB9YCBjYW4gYnJlYWsgYHdpbmRvdy5zY3JvbGxUb2BcclxuICAgIGlmIChib2R5KSB7XHJcbiAgICAgIGJvZHkuc3R5bGUub3ZlcmZsb3dZID0gJ3Zpc2libGUnXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhpZGVTY3JvbGxiYXIpIHtcclxuICAgICAgLy8gRGlzYWJsZSBhbGwgc2Nyb2xsYmFycy4gV2UnbGwgcmVzdG9yZSB0aGUgc2Nyb2xsYmFyIHN0YXRlIHdoZW4gd2UncmUgZG9uZVxyXG4gICAgICAvLyB0YWtpbmcgdGhlIHNjcmVlbnNob3RzLlxyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFnZUluZm8pXHJcbiAgfSxcclxuICBzY3JvbGxQYWdlOiAoeyB4LCB5IH0pID0+IHtcclxuICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KVxyXG5cclxuICAgIHJldHVybiBkZWxheSgoKSA9PiAoe1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFlcclxuICAgIH0pLCAxMDApXHJcbiAgfSxcclxuICBlbmRDYXB0dXJlOiAocGFnZUluZm8pID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgb3JpZ2luYWxYLCBvcmlnaW5hbFksIGhhc0JvZHksXHJcbiAgICAgIG9yaWdpbmFsT3ZlcmZsb3dTdHlsZSxcclxuICAgICAgb3JpZ2luYWxCb2R5T3ZlcmZsb3dZU3R5bGVcclxuICAgIH0gPSBwYWdlSW5mb1xyXG5cclxuICAgIGlmIChoYXNCb2R5KSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dZID0gb3JpZ2luYWxCb2R5T3ZlcmZsb3dZU3R5bGVcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBvcmlnaW5hbE92ZXJmbG93U3R5bGVcclxuICAgIHdpbmRvdy5zY3JvbGxUbyhvcmlnaW5hbFgsIG9yaWdpbmFsWSlcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUZ1bGxTY3JlZW4gKHRhYklkLCBmaWxlTmFtZSwgY2xpZW50QVBJKSB7XHJcbiAgcmV0dXJuIGNhcHR1cmVGdWxsU2NyZWVuKHRhYklkLCBjbGllbnRBUEksIHsgYmxvYjogdHJ1ZSB9KVxyXG4gIC50aGVuKHNjcmVlbkJsb2IgPT4ge1xyXG4gICAgcmV0dXJuIGdldFNjcmVlbnNob3RNYW4oKS5vdmVyd3JpdGUoZmlsZU5hbWUsIHNjcmVlbkJsb2IpXHJcbiAgICAudGhlbih1cmwgPT4gKHtcclxuICAgICAgdXJsLFxyXG4gICAgICBmaWxlTmFtZVxyXG4gICAgfSkpXHJcbiAgfSlcclxufVxyXG4iLCJpbXBvcnQgZ2xvYjJyZWcgZnJvbSAna2QtZ2xvYi10by1yZWdleHAnXHJcbmltcG9ydCB7IGRlbGF5LCB1bnRpbCwgdG9SZWdFeHAsIGluc2VydFNjcmlwdCwgcmV0cnksIGVuc3VyZUV4dE5hbWUsIHdpdGhDb3VudERvd24gfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgeyBzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIGRvbVRleHQsIGlzVmlzaWJsZSwgY3NzU2VsZWN0b3IgfSBmcm9tICcuL2RvbV91dGlscydcclxuaW1wb3J0IHsgcG9zdE1lc3NhZ2UgfSBmcm9tICcuL2lwYy9jc19wb3N0bWVzc2FnZSdcclxuaW1wb3J0IEV4dCBmcm9tICcuL3dlYl9leHRlbnNpb24nXHJcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2cnXHJcbmltcG9ydCBkcmFnTW9jayBmcm9tICcuL2RyYWdfbW9jaydcclxuaW1wb3J0IHNlbmRLZXlzIGZyb20gJy4vc2VuZF9rZXlzJ1xyXG5pbXBvcnQgeyBkZWNyeXB0SWZOZWVkZWQgfSBmcm9tICcuL2VuY3J5cHQnXHJcbmltcG9ydCB7IExBU1RfU0NSRUVOU0hPVF9GSUxFX05BTUUgfSBmcm9tICcuL2NvbnN0YW50J1xyXG5cclxuY29uc3QgSElHSExJR0hUX1RJTUVPVVQgPSA1MDBcclxuXHJcbmNvbnN0IGdsb2JNYXRjaCA9IChwYXR0ZXJuLCB0ZXh0KSA9PiBnbG9iMnJlZyhwYXR0ZXJuKS50ZXN0KHRleHQpXHJcblxyXG5jb25zdCBnZXRFbGVtZW50QnlYUGF0aCA9ICh4cGF0aCkgPT4ge1xyXG4gIGNvbnN0IHNuYXBzaG90ID0gZG9jdW1lbnQuZXZhbHVhdGUoXHJcbiAgICB4cGF0aCxcclxuICAgIGRvY3VtZW50LmJvZHksXHJcbiAgICBudWxsLFxyXG4gICAgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXHJcbiAgICBudWxsXHJcbiAgKVxyXG5cclxuICByZXR1cm4gc25hcHNob3Quc25hcHNob3RJdGVtKDApXHJcbn1cclxuXHJcbi8vIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3RpbW94bGV5L29mZnNldFxyXG5jb25zdCB2aWV3cG9ydE9mZnNldCA9IChlbCkgPT4ge1xyXG4gIGNvbnN0IGJveCAgICAgICAgID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuXHJcbiAgLy8gTm90ZTogc2ltcGx5IHVzZSBib3VkZGluZ0NsaWVudFJlY3Qgc2luY2UgZWxlbWVudEZyb21Qb2ludCB1c2VzXHJcbiAgLy8gdGhlIHNhbWUgdG9wL2xlZnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgdmlld3BvcnQvd2luZG93IGluc3RlYWQgb2Ygd2hvbGUgZG9jdW1lbnRcclxuICByZXR1cm4ge1xyXG4gICAgdG9wOiBib3gudG9wLFxyXG4gICAgbGVmdDogYm94LmxlZnRcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHVudGlsSW5qZWN0ZWQgPSAoKSA9PiB7XHJcbiAgY29uc3QgYXBpID0ge1xyXG4gICAgZXZhbDogKGNvZGUpID0+IHtcclxuICAgICAgbG9nKCdzZW5kaW5nIElOSkVDVF9SVU5fRVZBTCcpXHJcbiAgICAgIHJldHVybiBwb3N0TWVzc2FnZSh3aW5kb3csIHdpbmRvdywgeyBjbWQ6ICdJTkpFQ1RfUlVOX0VWQUwnLCBhcmdzOiB7Y29kZX0gfSwgJyonLCA1MDAwKVxyXG4gICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICBsb2coJ2V2YWwgcmVzdWx0JywgZGF0YSlcclxuICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHRcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgaW5qZWN0ZWQgPSAhIWRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKCdkYXRhLWluamVjdGVkJylcclxuICBpZiAoaW5qZWN0ZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXBpKVxyXG5cclxuICBpbnNlcnRTY3JpcHQoRXh0LmV4dGVuc2lvbi5nZXRVUkwoJ2luamVjdC5qcycpKVxyXG5cclxuICByZXR1cm4gcmV0cnkoKCkgPT4ge1xyXG4gICAgbG9nKCdzZW5kaW5nIElOSkVDVF9SRUFEWScpXHJcbiAgICByZXR1cm4gcG9zdE1lc3NhZ2Uod2luZG93LCB3aW5kb3csIHsgY21kOiAnSU5KRUNUX1JFQURZJyB9LCAnKicsIDUwMClcclxuICB9LCB7XHJcbiAgICBzaG91bGRSZXRyeTogKCkgPT4gdHJ1ZSxcclxuICAgIHRpbWVvdXQ6IDUwMDAsXHJcbiAgICByZXRyeUludGVydmFsOiAwXHJcbiAgfSkoKVxyXG4gIC50aGVuKCgpID0+IGFwaSlcclxuICAuY2F0Y2goZSA9PiB7XHJcbiAgICBsb2coZS5zdGFjaylcclxuICAgIHRocm93IG5ldyBFcnJvcignZmFpbCB0byBpbmplY3QnKVxyXG4gIH0pXHJcbn1cclxuXHJcbmNvbnN0IGlzRWxlbWVudEZyb21Qb2ludCA9IChzdHIpID0+IC9eI2VsZW1lbnRmcm9tcG9pbnQvaS50ZXN0KHN0ci50cmltKCkpXHJcblxyXG5jb25zdCBwYWdlQ29vcmRpbmF0ZUJ5RWxlbWVudEZyb21Qb2ludCA9IChzdHIpID0+IHtcclxuICBjb25zdCByZWcgPSAvXiNlbGVtZW50ZnJvbXBvaW50XFxzKlxcKChcXGQrKD86XFwuXFxkKyk/KVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcKS9pXHJcbiAgY29uc3QgbSAgID0gc3RyLnRyaW0oKS5tYXRjaChyZWcpXHJcblxyXG4gIGlmICghbSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICcjZWxlbWVudGZyb21wb2ludCcgZXhwcmVzc2lvbmApXHJcbiAgfVxyXG5cclxuICBjb25zdCBwYWdlWCA9IHBhcnNlRmxvYXQobVsxXSlcclxuICBjb25zdCBwYWdlWSA9IHBhcnNlRmxvYXQobVsyXSlcclxuXHJcbiAgaWYgKHBhZ2VYIDw9IDAgfHwgcGFnZVkgPD0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGAnI2VsZW1lbnRmcm9tcG9pbnQnIG9ubHkgYWNjZXB0cyBwb3NpdGl2ZSBudW1iZXJzYClcclxuICB9XHJcblxyXG4gIHJldHVybiBbcGFnZVgsIHBhZ2VZXVxyXG59XHJcblxyXG5jb25zdCB2aWV3cG9ydENvb3JkaW5hdGVCeUVsZW1lbnRGcm9tUG9pbnQgPSAoc3RyKSA9PiB7XHJcbiAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBwYWdlQ29vcmRpbmF0ZUJ5RWxlbWVudEZyb21Qb2ludChzdHIpXHJcbiAgY29uc3Qgb2Zmc2V0ICA9IDBcclxuICBjb25zdCB4ICAgICAgID0gb2Zmc2V0ICsgcGFnZVggLSBzY3JvbGxMZWZ0KGRvY3VtZW50KVxyXG4gIGNvbnN0IHkgICAgICAgPSBvZmZzZXQgKyBwYWdlWSAtIHNjcm9sbFRvcChkb2N1bWVudClcclxuXHJcbiAgcmV0dXJuIFt4LCB5XVxyXG59XHJcblxyXG5jb25zdCBlbGVtZW50QnlFbGVtZW50RnJvbVBvaW50ID0gKHN0cikgPT4ge1xyXG4gIGNvbnN0IFt4LCB5XSAgPSB2aWV3cG9ydENvb3JkaW5hdGVCeUVsZW1lbnRGcm9tUG9pbnQoc3RyKVxyXG4gIGNvbnN0IGVsICAgICAgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpXHJcblxyXG4gIHJldHVybiBlbFxyXG59XHJcblxyXG4vLyBOb3RlOiBwYXJzZSB0aGUgbG9jYXRvciBhbmQgcmV0dXJuIHRoZSBlbGVtZW50IGZvdW5kIGFjY29yZGluZ2x5XHJcbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QnlMb2NhdG9yID0gKHN0ciwgc2hvdWxkV2FpdEZvclZpc2libGUpID0+IHtcclxuICBjb25zdCBpID0gc3RyLmluZGV4T2YoJz0nKVxyXG4gIGxldCBlbFxyXG5cclxuICBpZiAoKC9eXFwvLy50ZXN0KHN0cikpKSB7XHJcbiAgICBlbCA9IGdldEVsZW1lbnRCeVhQYXRoKHN0cilcclxuICB9IGVsc2UgaWYgKC9eI2VsZW1lbnRmcm9tcG9pbnQvaS50ZXN0KHN0ci50cmltKCkpKSB7XHJcbiAgICBlbCA9IGVsZW1lbnRCeUVsZW1lbnRGcm9tUG9pbnQoc3RyKVxyXG4gICAgbG9nKCdlbGVtZW50ZnJvbXBvaW50JywgZWwpXHJcbiAgfSBlbHNlIGlmIChpID09PSAtMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRFbGVtZW50QnlMb2NhdG9yOiBpbnZhbGlkIGxvY2F0b3IsICcgKyBzdHIpXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IG1ldGhvZCAgPSBzdHIuc3Vic3RyKDAsIGkpXHJcbiAgICBjb25zdCB2YWx1ZSAgID0gc3RyLnN1YnN0cihpICsgMSlcclxuXHJcbiAgICBzd2l0Y2ggKG1ldGhvZCAmJiBtZXRob2QudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICBjYXNlICdpZCc6XHJcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh2YWx1ZSlcclxuICAgICAgICBicmVha1xyXG5cclxuICAgICAgY2FzZSAnbmFtZSc6XHJcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSh2YWx1ZSlbMF1cclxuICAgICAgICBicmVha1xyXG5cclxuICAgICAgY2FzZSAnaWRlbnRpZmllcic6XHJcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh2YWx1ZSkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUodmFsdWUpWzBdXHJcbiAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgIGNhc2UgJ2xpbmsnOiB7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJykpXHJcbiAgICAgICAgLy8gTm90ZTogdGhlcmUgYXJlIGNhc2VzIHN1Y2ggYXMgJ2xpbms9ZXhhY3Q6eHh4J1xyXG4gICAgICAgIGxldCByZWFsVmFsID0gdmFsdWUucmVwbGFjZSgvXmV4YWN0Oi8sICcnKVxyXG4gICAgICAgIC8vIE5vdGU6IHBvc2l0aW9uIHN1cHBvcnQuIGVnLiBsaW5rPURvd25sb2FkQFBPUz0zXHJcbiAgICAgICAgbGV0IG1hdGNoICAgPSByZWFsVmFsLm1hdGNoKC9eKC4rKUBQT1M9KFxcZCspJC9pKVxyXG4gICAgICAgIGxldCBpbmRleCAgID0gMFxyXG5cclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgIHJlYWxWYWwgPSBtYXRjaFsxXVxyXG4gICAgICAgICAgaW5kZXggICA9IHBhcnNlSW50KG1hdGNoWzJdKSAtIDFcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdGU6IHVzZSB0ZXh0Q29udGVudCBpbnN0ZWFkIG9mIGlubmVyVGV4dCB0byBhdm9pZCBpbmZsdWVuY2UgZnJvbSB0ZXh0LXRyYW5zZm9ybVxyXG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBsaW5rcy5maWx0ZXIoYSA9PiBnbG9iTWF0Y2gocmVhbFZhbCwgZG9tVGV4dChhKSkpXHJcbiAgICAgICAgZWwgPSBjYW5kaWRhdGVzW2luZGV4XVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ2Nzcyc6XHJcbiAgICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbHVlKVxyXG4gICAgICAgIGJyZWFrXHJcblxyXG4gICAgICBjYXNlICd4cGF0aCc6XHJcbiAgICAgICAgZWwgPSBnZXRFbGVtZW50QnlYUGF0aCh2YWx1ZSlcclxuICAgICAgICBicmVha1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEVsZW1lbnRCeUxvY2F0b3I6IHVuc3VwcG9ydGVkIGxvY2F0b3IgbWV0aG9kLCAnICsgbWV0aG9kKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFlbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRFbGVtZW50QnlMb2NhdG9yOiBmYWlsIHRvIGZpbmQgZWxlbWVudCBiYXNlZCBvbiB0aGUgbG9jYXRvciwgJyArIHN0cilcclxuICB9XHJcblxyXG4gIGlmIChzaG91bGRXYWl0Rm9yVmlzaWJsZSAmJiAhaXNWaXNpYmxlKGVsKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRFbGVtZW50QnlMb2NhdG9yOiBlbGVtZW50IGlzIGZvdW5kIGJ1dCBub3QgdmlzaWJsZSB5ZXQnKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRGcmFtZUJ5TG9jYXRvciA9IChzdHIsIGhlbHBlcnMpID0+IHtcclxuICBjb25zdCBpID0gc3RyLmluZGV4T2YoJz0nKVxyXG5cclxuICAvLyBOb3RlOiB0cnkgdG8gcGFyc2UgZm9ybWF0IG9mICdpbmRleD0wJyBhbmQgJ3JlbGF0aXZlPXRvcC9wYXJlbnQnXHJcbiAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICBjb25zdCBtZXRob2QgID0gc3RyLnN1YnN0cigwLCBpKVxyXG4gICAgY29uc3QgdmFsdWUgICA9IHN0ci5zdWJzdHIoaSArIDEpXHJcblxyXG4gICAgc3dpdGNoIChtZXRob2QpIHtcclxuICAgICAgY2FzZSAnaW5kZXgnOiB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggICA9IHBhcnNlSW50KHZhbHVlLCAxMClcclxuICAgICAgICBjb25zdCBmcmFtZXMgID0gd2luZG93LmZyYW1lc1xyXG4gICAgICAgIGNvbnN0IGZyYW1lICAgPSBmcmFtZXNbaW5kZXhdXHJcblxyXG4gICAgICAgIGlmICghZnJhbWUpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlIChpbmRleCAke3ZhbHVlfSBpbiAke2ZyYW1lcy5sZW5ndGh9IGZyYW1lc2ApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyBmcmFtZSB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ3JlbGF0aXZlJzoge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgIHJldHVybiB7IGZyYW1lOiB3aW5kb3cudG9wIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgICAgIHJldHVybiB7IGZyYW1lOiB3aW5kb3cucGFyZW50IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcmVsYXRpdmUgdHlwZSwgJyArIHZhbHVlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOb3RlOiBjb25zaWRlciBpdCBhcyBuYW1lLCBpZiBubyAnPScgZm91bmQgYW5kIGl0IGhhcyBubyB4cGF0aCBwYXR0ZXJuXHJcbiAgaWYgKGkgPT09IC0xICYmICEvXlxcLy8udGVzdChzdHIpKSB7XHJcbiAgICBzdHIgPSAnbmFtZT0nICsgc3RyXHJcbiAgfVxyXG5cclxuICBjb25zdCBmcmFtZURvbSA9IGdldEVsZW1lbnRCeUxvY2F0b3Ioc3RyKVxyXG5cclxuICBpZiAoIWZyYW1lRG9tIHx8ICFmcmFtZURvbS5jb250ZW50V2luZG93KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBlbGVtZW50IGZvdW5kIGJhc2VkIG9uICR7c3RyfSBpcyBOT1QgYSBmcmFtZS9pZnJhbWVgKVxyXG4gIH1cclxuXHJcbiAgLy8gTm90ZTogZm9yIHRob3NlIGlmcmFtZS9mcmFtZSB0aGF0IGRvbid0IGhhdmUgc3JjLCB0aGV5IHdvbid0IGxvYWQgY29udGVudF9zY3JpcHQuanNcclxuICAvLyBzbyB3ZSBoYXZlIHRvIGluamVjdCB0aGUgc2NyaXB0IGJ5IG91cnNlbHZlc1xyXG4gIGlmICghZnJhbWVEb20uZ2V0QXR0cmlidXRlKCdzcmMnKSkge1xyXG4gICAgY29uc3QgZmlsZSAgPSBFeHQuZXh0ZW5zaW9uLmdldFVSTCgnY29udGVudF9zY3JpcHQuanMnKVxyXG4gICAgY29uc3QgZG9jICAgPSBmcmFtZURvbS5jb250ZW50RG9jdW1lbnRcclxuICAgIGNvbnN0IHMgICAgID0gZG9jLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LmNhbGwoZG9jLCAnc2NyaXB0JylcclxuXHJcbiAgICBzLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKVxyXG4gICAgcy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGZpbGUpXHJcblxyXG4gICAgZG9jLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzKVxyXG4gICAgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpXHJcblxyXG4gICAgaGVscGVycy5oYWNrQWxlcnRDb25maXJtUHJvbXB0KGRvYylcclxuICB9XHJcblxyXG4gIC8vIE5vdGU6IGNhbid0IHJldHVybiB0aGUgY29udGVudFdpbmRvdyBkaXJlY3RseSwgYmVjYXVzZSBQcm9taXNlICdyZXNvbHZlJyB3aWxsXHJcbiAgLy8gdHJ5IHRvIHRlc3QgaXRzICcudGhlbicgbWV0aG9kLCB3aGljaCB3aWxsIGNhdXNlIGEgY3Jvc3Mgb3JpZ2luIHZpb2xhdGlvblxyXG4gIC8vIHNvLCB3ZSB3cmFwIGl0IGluIGFuIG9iamVjdFxyXG4gIHJldHVybiB7IGZyYW1lOiBmcmFtZURvbS5jb250ZW50V2luZG93IH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHJ1biA9IChjb21tYW5kLCBjc0lwYywgaGVscGVycykgPT4ge1xyXG4gIGNvbnN0IHsgY21kLCB0YXJnZXQsIHZhbHVlLCBleHRyYSB9ID0gY29tbWFuZFxyXG4gIGNvbnN0IHdyYXAgPSAoZm4sIGdlbk9wdGlvbnMpID0+ICguLi5hcmdzKSA9PiB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gZ2VuT3B0aW9ucyguLi5hcmdzKVxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSlcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3Iob3B0aW9ucy5lcnJvck1zZyhlLm1lc3NhZ2UpKSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbiAgY29uc3QgZ2V0RWxlbWVudEJ5TG9jYXRvcldpdGhMb2dGb3JFZnAgPSAobG9jYXRvciwgc2hvdWxkV2FpdEZvclZpc2libGUpID0+IHtcclxuICAgIGNvbnN0IGVsID0gZ2V0RWxlbWVudEJ5TG9jYXRvcihsb2NhdG9yLCBzaG91bGRXYWl0Rm9yVmlzaWJsZSlcclxuXHJcbiAgICBpZiAoaXNFbGVtZW50RnJvbVBvaW50KGxvY2F0b3IpKSB7XHJcbiAgICAgIGxldCBlbFhwYXRoID0gJ3Vua293bidcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZWxYcGF0aCA9IGhlbHBlcnMueHBhdGgoZWwpXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gICAgICBjb25zdCBtc2cgPSBgJHtsb2NhdG9yfSA9PiB4cGF0aCBcIiR7ZWxYcGF0aH1cImBcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKG1zZywgZWwpXHJcbiAgICAgIGNzSXBjLmFzaygnQ1NfQUREX0xPRycsIHsgaW5mbzogbXNnIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsXHJcbiAgfVxyXG4gIGNvbnN0IF9fZ2V0RnJhbWVCeUxvY2F0b3IgPSB3cmFwKGdldEZyYW1lQnlMb2NhdG9yLCAobG9jYXRvcikgPT4gKHtcclxuICAgIGVycm9yTXNnOiAobXNnKSA9PiB7XHJcbiAgICAgIHJldHVybiBgdGltZW91dCByZWFjaGVkIHdoZW4gbG9va2luZyBmb3IgZnJhbWUgJyR7bG9jYXRvcn0nYFxyXG4gICAgfVxyXG4gIH0pKVxyXG4gIGNvbnN0IF9fZ2V0RWxlbWVudEJ5TG9jYXRvciA9IHdyYXAoZ2V0RWxlbWVudEJ5TG9jYXRvcldpdGhMb2dGb3JFZnAsIChsb2NhdG9yKSA9PiAoe1xyXG4gICAgZXJyb3JNc2c6IChtc2cpID0+IHtcclxuICAgICAgaWYgKC9lbGVtZW50IGlzIGZvdW5kIGJ1dCBub3QgdmlzaWJsZSB5ZXQvLnRlc3QobXNnKSkge1xyXG4gICAgICAgIHJldHVybiBgZWxlbWVudCBpcyBmb3VuZCBidXQgbm90IHZpc2libGUgeWV0IGZvciAnJHtsb2NhdG9yfScgKHVzZSAhV2FpdEZvclZpc2libGUgPSBmYWxzZSB0byBkaXNhYmxlIHdhaXRpbmcgZm9yIHZpc2libGUpYFxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYHRpbWVvdXQgcmVhY2hlZCB3aGVuIGxvb2tpbmcgZm9yIGVsZW1lbnQgJyR7bG9jYXRvcn0nYFxyXG4gICAgfVxyXG4gIH0pKVxyXG5cclxuICBzd2l0Y2ggKGNtZCkge1xyXG4gICAgY2FzZSAnb3Blbic6XHJcbiAgICAgIGlmICh3aW5kb3cubm9Db21tYW5kc1lldCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB1bnRpbCgnZG9jdW1lbnQuYm9keScsICgpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcGFzczogISFkb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgcmVzdWx0OiBkb2N1bWVudC5ib2R5XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihib2R5ID0+IHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGNvbW1hbmQudGFyZ2V0XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfSlcclxuXHJcbiAgICBjYXNlICdyZWZyZXNoJzpcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCksIDApXHJcbiAgICAgIHJldHVybiB0cnVlXHJcblxyXG4gICAgY2FzZSAnbW91c2VPdmVyJzoge1xyXG4gICAgICByZXR1cm4gX19nZXRFbGVtZW50QnlMb2NhdG9yKHRhcmdldClcclxuICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoZXh0cmEucGxheVNjcm9sbEVsZW1lbnRzSW50b1ZpZXcpIGVsLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICdjZW50ZXInIH0pXHJcbiAgICAgICAgICBpZiAoZXh0cmEucGxheUhpZ2hsaWdodEVsZW1lbnRzKSAgICAgIGhlbHBlcnMuaGlnaGxpZ2h0RG9tKGVsLCBISUdITElHSFRfVElNRU9VVClcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBsb2cuZXJyb3IoJ2Vycm9yIGluIHNjcm9sbCBhbmQgaGlnaGxpZ2h0JywgZS5tZXNzYWdlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnbW91c2VvdmVyJywgeyBidWJibGVzOiB0cnVlIH0pKVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnZHJhZ0FuZERyb3BUb09iamVjdCc6IHtcclxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0KSxcclxuICAgICAgICBfX2dldEVsZW1lbnRCeUxvY2F0b3IodmFsdWUpXHJcbiAgICAgIF0pXHJcbiAgICAgIC50aGVuKChbJHNyYywgJHRndF0pID0+IHtcclxuICAgICAgICBkcmFnTW9jay50cmlnZ2VyRHJhZ0V2ZW50KCRzcmMsICR0Z3QpXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICd3YWl0Rm9yVmlzaWJsZSc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQsIHRydWUpXHJcbiAgICAgIC50aGVuKCgpID0+IHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnY2xpY2tBdCc6IHtcclxuICAgICAgY29uc3QgZ2V0SWZyYW1lT2Zmc2V0ID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh3aW5kb3cgPT09IHdpbmRvdy50b3ApIHtcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB4OiAwLCB5OiAwIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2Uod2luZG93LnBhcmVudCwgd2luZG93LCB7XHJcbiAgICAgICAgICBhY3Rpb246ICdTT1VSQ0VfUEFHRV9PRkZTRVQnLFxyXG4gICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGlzRWZwICAgPSBpc0VsZW1lbnRGcm9tUG9pbnQodGFyZ2V0KVxyXG4gICAgICBjb25zdCBwVGFyZ2V0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWlzRWZwKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRhcmdldClcclxuICAgICAgICByZXR1cm4gZ2V0SWZyYW1lT2Zmc2V0KClcclxuICAgICAgICAudGhlbihpZnJhbWVPZmZzZXQgPT4ge1xyXG4gICAgICAgICAgbG9nKCdpZnJhbWVPZmZzZXQnLCBpZnJhbWVPZmZzZXQpXHJcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSB2aWV3cG9ydENvb3JkaW5hdGVCeUVsZW1lbnRGcm9tUG9pbnQodGFyZ2V0KVxyXG4gICAgICAgICAgcmV0dXJuIGAjZWxlbWVudGZyb21wb2ludCAoJHt4IC0gaWZyYW1lT2Zmc2V0Lnh9LCAke3kgLSBpZnJhbWVPZmZzZXQueX0pYFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pKClcclxuXHJcbiAgICAgIHJldHVybiBwVGFyZ2V0LnRoZW4odGFyZ2V0ID0+IHtcclxuICAgICAgICByZXR1cm4gX19nZXRFbGVtZW50QnlMb2NhdG9yKHRhcmdldCwgZXh0cmEud2FpdEZvclZpc2libGUpXHJcbiAgICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgICAgaWYgKCEvXlxcZCtcXHMqLFxccypcXGQrJC8udGVzdCh2YWx1ZSkgJiYgIWlzRWxlbWVudEZyb21Qb2ludCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvZmZzZXQgZm9yIGNsaWNrQXQ6ICR7dmFsdWV9YClcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBzY3JvbGxBbmRIaWdobGlnaHQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnBsYXlTY3JvbGxFbGVtZW50c0ludG9WaWV3KSBlbC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnY2VudGVyJyB9KVxyXG4gICAgICAgICAgICAgIGlmIChleHRyYS5wbGF5SGlnaGxpZ2h0RWxlbWVudHMpICAgICAgaGVscGVycy5oaWdobGlnaHREb20oZWwsIEhJR0hMSUdIVF9USU1FT1VUKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgbG9nLmVycm9yKCdlcnJvciBpbiBzY3JvbGwgYW5kIGhpZ2hsaWdodCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBbb3JpZ0NsaWVudFgsIG9yaWdDbGllbnRZXSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0VmcCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydENvb3JkaW5hdGVCeUVsZW1lbnRGcm9tUG9pbnQodGFyZ2V0KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnN0IFt4LCB5XSAgICAgICAgPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChzdHIgPT4gcGFyc2VJbnQoc3RyLnRyaW0oKSwgMTApKVxyXG4gICAgICAgICAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSB2aWV3cG9ydE9mZnNldChlbClcclxuICAgICAgICAgICAgICByZXR1cm4gW2xlZnQgKyB4LCB0b3AgKyB5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KSgpXHJcblxyXG4gICAgICAgICAgY29uc3QgbGFzdFNjcm9sbFggICA9IHdpbmRvdy5zY3JvbGxYXHJcbiAgICAgICAgICBjb25zdCBsYXN0U2Nyb2xsWSAgID0gd2luZG93LnNjcm9sbFlcclxuXHJcbiAgICAgICAgICBpZiAoIWlzRWZwKSBzY3JvbGxBbmRIaWdobGlnaHQoKVxyXG5cclxuICAgICAgICAgIGNvbnN0IGNsaWVudFggICAgICAgPSBvcmlnQ2xpZW50WCArIChsYXN0U2Nyb2xsWCAtIHdpbmRvdy5zY3JvbGxYKVxyXG4gICAgICAgICAgY29uc3QgY2xpZW50WSAgICAgICA9IG9yaWdDbGllbnRZICsgKGxhc3RTY3JvbGxZIC0gd2luZG93LnNjcm9sbFkpXHJcblxyXG4gICAgICAgICAgbG9nKCdjbGlja0F0IGNsaWVudFgvY2xpZW50WScsIGNsaWVudFgsIGNsaWVudFkpXHJcblxyXG4gICAgICAgICAgO1snbW91c2Vkb3duJywgJ21vdXNldXAnLCAnY2xpY2snXS5mb3JFYWNoKGV2ZW50VHlwZSA9PiB7XHJcbiAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgICAgbmV3IE1vdXNlRXZlbnQoZXZlbnRUeXBlLCB7XHJcbiAgICAgICAgICAgICAgICB2aWV3OiB3aW5kb3csXHJcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRZXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBOb3RlOiBkZWxheSBzY3JvbGwgYW5kIGhpZ2hsaWdodCBmb3IgZWZwLFxyXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoYXQgc2Nyb2xsIGNvdWxkIG1lc3MgdXAgdGhlIHdob2xlIGNvb2Rpcm5hdGUgY2FsY3VsYXRpb25cclxuICAgICAgICAgIGlmIChpc0VmcCkgc2Nyb2xsQW5kSGlnaGxpZ2h0KClcclxuXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnY2xpY2snOlxyXG4gICAgY2FzZSAnY2xpY2tBbmRXYWl0Jzoge1xyXG4gICAgICByZXR1cm4gX19nZXRFbGVtZW50QnlMb2NhdG9yKHRhcmdldCwgZXh0cmEud2FpdEZvclZpc2libGUpXHJcbiAgICAgIC50aGVuKGVsID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGV4dHJhLnBsYXlTY3JvbGxFbGVtZW50c0ludG9WaWV3KSBlbC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnY2VudGVyJyB9KVxyXG4gICAgICAgICAgaWYgKGV4dHJhLnBsYXlIaWdobGlnaHRFbGVtZW50cykgICAgICBoZWxwZXJzLmhpZ2hsaWdodERvbShlbCwgSElHSExJR0hUX1RJTUVPVVQpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgbG9nLmVycm9yKCdlcnJvciBpbiBzY3JvbGwgYW5kIGhpZ2hsaWdodCcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbC5jbGljaygpXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgY2FzZSAnc2VsZWN0QW5kV2FpdCc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQsIGV4dHJhLndhaXRGb3JWaXNpYmxlKVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyAgICAgPSBbXS5zbGljZS5jYWxsKGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdvcHRpb24nKSlcclxuICAgICAgICBjb25zdCBpICAgICAgICAgICA9IHZhbHVlLmluZGV4T2YoJz0nKVxyXG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgID0gdmFsdWUuc3Vic3RyaW5nKDAsIGkpXHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoaSArIDEpXHJcblxyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKG9wdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZpbmQob3AgPT4gZ2xvYk1hdGNoKG9wdGlvblZhbHVlLCBkb21UZXh0KG9wKS50cmltKCkpKVxyXG5cclxuICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZpbmQoKF8sIGluZGV4KSA9PiBpbmRleCA9PT0gcGFyc2VJbnQob3B0aW9uVmFsdWUpKVxyXG5cclxuICAgICAgICAgICAgY2FzZSAnaWQnOlxyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZpbmQoKG9wLCBpbmRleCkgPT4gb3AuaWQgPT09IG9wdGlvblZhbHVlKVxyXG5cclxuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZpbmQob3AgPT4gb3AudmFsdWUgPT09IG9wdGlvblZhbHVlKVxyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wdGlvbiB0eXBlIFwiJHtvcHRpb25UeXBlfVwiIG5vdCBzdXBwb3J0ZWRgKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKClcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGZpbmQgb3B0aW9uIHdpdGggJyR7dmFsdWV9J2ApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXh0cmEucGxheVNjcm9sbEVsZW1lbnRzSW50b1ZpZXcpIGVsLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICdjZW50ZXInIH0pXHJcbiAgICAgICAgaWYgKGV4dHJhLnBsYXlIaWdobGlnaHRFbGVtZW50cykgICAgICBoZWxwZXJzLmhpZ2hsaWdodERvbShlbCwgSElHSExJR0hUX1RJTUVPVVQpXHJcblxyXG4gICAgICAgIGVsLnZhbHVlID0gb3B0aW9uLnZhbHVlXHJcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3R5cGUnOiB7XHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0LCBleHRyYS53YWl0Rm9yVmlzaWJsZSlcclxuICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxyXG5cclxuICAgICAgICBpZiAodGFnICE9PSAnaW5wdXQnICYmIHRhZyAhPT0gJ3RleHRhcmVhJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdydW4gY29tbWFuZDogZWxlbWVudCBmb3VuZCBpcyBuZWl0aGVyIGlucHV0IG5vciB0ZXh0YXJlYScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXh0cmEucGxheVNjcm9sbEVsZW1lbnRzSW50b1ZpZXcpIGVsLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICdjZW50ZXInIH0pXHJcbiAgICAgICAgaWYgKGV4dHJhLnBsYXlIaWdobGlnaHRFbGVtZW50cykgICAgICBoZWxwZXJzLmhpZ2hsaWdodERvbShlbCwgSElHSExJR0hUX1RJTUVPVVQpXHJcblxyXG4gICAgICAgIC8vIE5vdGU6IG5lZWQgdGhlIGhlbHAgb2YgY2hyb21lLmRlYnVnZ2VyIHRvIHNldCBmaWxlIHBhdGggdG8gZmlsZSBpbnB1dFxyXG4gICAgICAgIGlmIChlbC50eXBlICYmIGVsLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgICAgICBpZiAoRXh0LmlzRmlyZWZveCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0dGluZyBmaWxlIHBhdGggZm8gZmlsZSBpbnB1dHMgaXMgbm90IHN1cHBvcnRlZCBieSBGaXJlZm94IGV4dGVuc2lvbiBhcGkgeWV0JylcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gY3NJcGMuYXNrKCdDU19TRVRfRklMRV9JTlBVVF9GSUxFUycsIHtcclxuICAgICAgICAgICAgZmlsZXM6ICAgIHZhbHVlLnNwbGl0KCc7JyksXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiBjc3NTZWxlY3RvcihlbClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVjcnlwdElmTmVlZGVkKHZhbHVlLCBlbClcclxuICAgICAgICAudGhlbihyZWFsVmFsdWUgPT4ge1xyXG4gICAgICAgICAgZWwudmFsdWUgPSAnJ1xyXG4gICAgICAgICAgc2VuZEtleXMoZWwsIHJlYWxWYWx1ZSwgdHJ1ZSlcclxuXHJcbiAgICAgICAgICBlbC52YWx1ZSA9IHJlYWxWYWx1ZVxyXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgaWYgKC9UaGlzIGlucHV0IGVsZW1lbnQgYWNjZXB0cyBhIGZpbGVuYW1lL2kudGVzdChlLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvcnJ5LCB1cGxvYWQgY2FuIG5vdCBiZSBhdXRvbWF0ZWQgQ2hyb21lIChBUEkgbGltaXRhdGlvbikuJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IGVcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdlZGl0Q29udGVudCc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQsIGV4dHJhLndhaXRGb3JWaXNpYmxlKVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgaWYgKGVsLmNvbnRlbnRFZGl0YWJsZSAhPT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBpcyBub3QgY29udGVudGVkaXRhYmxlYClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHRyYS5wbGF5U2Nyb2xsRWxlbWVudHNJbnRvVmlldykgZWwuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ2NlbnRlcicgfSlcclxuICAgICAgICBpZiAoZXh0cmEucGxheUhpZ2hsaWdodEVsZW1lbnRzKSAgICAgIGhlbHBlcnMuaGlnaGxpZ2h0RG9tKGVsLCBISUdITElHSFRfVElNRU9VVClcclxuXHJcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gdmFsdWVcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3NlbGVjdEZyYW1lJzoge1xyXG4gICAgICByZXR1cm4gX19nZXRGcmFtZUJ5TG9jYXRvcih0YXJnZXQsIGhlbHBlcnMpXHJcbiAgICAgIC50aGVuKGZyYW1lV2luZG93ID0+IHtcclxuICAgICAgICBpZiAoIWZyYW1lV2luZG93KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJhbWUvaWZyYW1lJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmcmFtZVdpbmRvd1xyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3ZlcmlmeVRleHQnOiB7XHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0KVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgY29uc3QgdGV4dCAgPSBkb21UZXh0KGVsKVxyXG5cclxuICAgICAgICBpZiAoIWdsb2JNYXRjaCh2YWx1ZSwgdGV4dCkpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxvZzoge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBgdGV4dCBub3QgbWF0Y2hlZCwgXFxuXFx0ZXhwZWN0ZWQ6IFwiJHt2YWx1ZX1cIiwgXFxuXFx0YWN0dWFsOiBcIiR7dGV4dH1cImBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICd2ZXJpZnlUaXRsZSc6IHtcclxuICAgICAgaWYgKCFnbG9iTWF0Y2godGFyZ2V0LCBkb2N1bWVudC50aXRsZSkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbG9nOiB7XHJcbiAgICAgICAgICAgIGVycm9yOiBgdGl0bGUgbm90IG1hdGNoZWQsIFxcblxcdGV4cGVjdGVkOiBcIiR7dGFyZ2V0fVwiLCBcXG5cXHRhY3R1YWw6IFwiJHtkb2N1bWVudC50aXRsZX1cImBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAndmVyaWZ5RWxlbWVudFByZXNlbnQnOiB7XHJcbiAgICAgIGNvbnN0IHsgdGltZW91dEVsZW1lbnQsIHJldHJ5SW5mbyB9ID0gZXh0cmEgfHwge31cclxuXHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0KVxyXG4gICAgICAudGhlbihcclxuICAgICAgICAoKSA9PiB0cnVlLFxyXG4gICAgICAgIChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzaG90c0xlZnQgICAgID0gKHRpbWVvdXRFbGVtZW50ICogMTAwMCAvIHJldHJ5SW5mby5yZXRyeUludGVydmFsKSAtIHJldHJ5SW5mby5yZXRyeUNvdW50XHJcbiAgICAgICAgICBjb25zdCBpc0xhc3RDaGFuY2UgID0gc2hvdHNMZWZ0IDw9IDFcclxuXHJcbiAgICAgICAgICBpZiAoaXNMYXN0Q2hhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgbG9nOiB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogYCcke3RhcmdldH0nIGVsZW1lbnQgbm90IHByZXNlbnRgXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhyb3cgZVxyXG4gICAgICAgIH1cclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3ZlcmlmeUNoZWNrZWQnOiB7XHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0KVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZCAgPSAhIWVsLmNoZWNrZWRcclxuXHJcbiAgICAgICAgaWYgKCFjaGVja2VkKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsb2c6IHtcclxuICAgICAgICAgICAgICBlcnJvcjogYCcke3RhcmdldH0nIGlzIG5vdCBjaGVja2VkYFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3ZlcmlmeUF0dHJpYnV0ZSc6IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0YXJnZXQubGFzdEluZGV4T2YoJ0AnKVxyXG5cclxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0YXJnZXQgZm9yIHZlcmlmeUF0dHJpYnV0ZSAtICR7dGFyZ2V0fWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxvY2F0b3IgICA9IHRhcmdldC5zdWJzdHIoMCwgaW5kZXgpXHJcbiAgICAgIGNvbnN0IGF0dHJOYW1lICA9IHRhcmdldC5zdWJzdHIoaW5kZXggKyAxKVxyXG5cclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcihsb2NhdG9yKVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSlcclxuXHJcbiAgICAgICAgaWYgKCFnbG9iTWF0Y2godmFsdWUsIGF0dHIpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsb2c6IHtcclxuICAgICAgICAgICAgICBlcnJvcjogYGF0dHJpYnV0ZSBub3QgbWF0Y2hlZCwgXFxuXFx0ZXhwZWN0ZWQ6IFwiJHt2YWx1ZX1cIiwgXFxuXFx0YWN0dWFsOiBcIiR7YXR0cn1cImBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICd2ZXJpZnlFcnJvcic6IHtcclxuICAgICAgaWYgKGV4dHJhLmxhc3RDb21tYW5kT2spIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbG9nOiB7XHJcbiAgICAgICAgICAgIGVycm9yOiB0YXJnZXRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnYXNzZXJ0VGV4dCc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQpXHJcbiAgICAgIC50aGVuKGVsID0+IHtcclxuICAgICAgICBjb25zdCB0ZXh0ICA9IGRvbVRleHQoZWwpXHJcblxyXG4gICAgICAgIGlmICghZ2xvYk1hdGNoKHZhbHVlLCB0ZXh0KSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZXh0IG5vdCBtYXRjaGVkLCBcXG5cXHRleHBlY3RlZDogXCIke3ZhbHVlfVwiLCBcXG5cXHRhY3R1YWw6IFwiJHt0ZXh0fVwiYClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnYXNzZXJ0VGl0bGUnOiB7XHJcbiAgICAgIGlmICghZ2xvYk1hdGNoKHRhcmdldCwgZG9jdW1lbnQudGl0bGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aXRsZSBub3QgbWF0Y2hlZCwgXFxuXFx0ZXhwZWN0ZWQ6IFwiJHt0YXJnZXR9XCIsIFxcblxcdGFjdHVhbDogXCIke2RvY3VtZW50LnRpdGxlfVwiYClcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdhc3NlcnRFbGVtZW50UHJlc2VudCc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQpXHJcbiAgICAgIC50aGVuKCgpID0+IHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnYXNzZXJ0Q2hlY2tlZCc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQpXHJcbiAgICAgIC50aGVuKGVsID0+IHtcclxuICAgICAgICBjb25zdCBjaGVja2VkICA9ICEhZWwuY2hlY2tlZFxyXG5cclxuICAgICAgICBpZiAoIWNoZWNrZWQpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7dGFyZ2V0fScgaXMgbm90IGNoZWNrZWRgKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdhc3NlcnRBdHRyaWJ1dGUnOiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGFyZ2V0Lmxhc3RJbmRleE9mKCdAJylcclxuXHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdGFyZ2V0IGZvciBhc3NlcnRBdHRyaWJ1dGUgLSAke3RhcmdldH1gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2NhdG9yICAgPSB0YXJnZXQuc3Vic3RyKDAsIGluZGV4KVxyXG4gICAgICBjb25zdCBhdHRyTmFtZSAgPSB0YXJnZXQuc3Vic3RyKGluZGV4ICsgMSlcclxuXHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IobG9jYXRvcilcclxuICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpXHJcblxyXG4gICAgICAgIGlmICghZ2xvYk1hdGNoKHZhbHVlLCBhdHRyKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdHRyaWJ1dGUgbm90IG1hdGNoZWQsIFxcblxcdGV4cGVjdGVkOiBcIiR7dmFsdWV9XCIsIFxcblxcdGFjdHVhbDogXCIke2F0dHJ9XCJgKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdhc3NlcnRFcnJvcic6IHtcclxuICAgICAgaWYgKGV4dHJhLmxhc3RDb21tYW5kT2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ2Fzc2VydEFsZXJ0Jzoge1xyXG4gICAgICBjb25zdCBtc2cgPSBkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZSgnZGF0YS1hbGVydCcpXHJcblxyXG4gICAgICBpZiAoIW1zZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYWxlcnQgZm91bmQhJylcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFnbG9iTWF0Y2godGFyZ2V0LCBtc2cpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bm1hdGNoZWQgYWxlcnQgbXNnLCBcXG5cXHRleHBlY3RlZDogXCIke3RhcmdldH1cIiwgXFxuXFx0YWN0dWFsOiBcIiR7bXNnfVwiYClcclxuICAgICAgfVxyXG5cclxuICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWxlcnQnLCAnJylcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdhc3NlcnRDb25maXJtYXRpb24nOiB7XHJcbiAgICAgIGNvbnN0IG1zZyA9IGRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm0nKVxyXG5cclxuICAgICAgaWYgKCFtc2cpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGNvbmZpcm0gZm91bmQhJylcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFnbG9iTWF0Y2godGFyZ2V0LCBtc2cpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bm1hdGNoZWQgY29uZmlybSBtc2csIFxcblxcdGV4cGVjdGVkOiBcIiR7dGFyZ2V0fVwiLCBcXG5cXHRhY3R1YWw6IFwiJHttc2d9XCJgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS1jb25maXJtJywgJycpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnYXNzZXJ0UHJvbXB0Jzoge1xyXG4gICAgICBjb25zdCBtc2cgPSBkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZSgnZGF0YS1wcm9tcHQnKVxyXG5cclxuICAgICAgaWYgKCFtc2cpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb21wdCBmb3VuZCEnKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWdsb2JNYXRjaCh0YXJnZXQsIG1zZykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVubWF0Y2hlZCBwcm9tcHQgbXNnLCBcXG5cXHRleHBlY3RlZDogXCIke3RhcmdldH1cIiwgXFxuXFx0YWN0dWFsOiBcIiR7bXNnfVwiYClcclxuICAgICAgfVxyXG5cclxuICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHJvbXB0JywgJycpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnYW5zd2VyT25OZXh0UHJvbXB0Jzoge1xyXG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS1wcm9tcHQtYW5zd2VyJywgdGFyZ2V0KVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3dhaXRGb3JQYWdlVG9Mb2FkJzpcclxuICAgICAgcmV0dXJuIHRydWVcclxuXHJcbiAgICBjYXNlICdzdG9yZVRpdGxlJzoge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhcnM6IHtcclxuICAgICAgICAgIFt2YWx1ZV06IGRvY3VtZW50LnRpdGxlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnc3RvcmVUZXh0Jzoge1xyXG4gICAgICByZXR1cm4gX19nZXRFbGVtZW50QnlMb2NhdG9yKHRhcmdldClcclxuICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB2YXJzOiB7XHJcbiAgICAgICAgICAgIFt2YWx1ZV06IGRvbVRleHQoZWwpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3N0b3JlQXR0cmlidXRlJzoge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRhcmdldC5sYXN0SW5kZXhPZignQCcpXHJcblxyXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRhcmdldCBmb3Igc3RvcmVBdHRyaWJ1dGUgLSAke3RhcmdldH1gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2NhdG9yICAgPSB0YXJnZXQuc3Vic3RyKDAsIGluZGV4KVxyXG4gICAgICBjb25zdCBhdHRyTmFtZSAgPSB0YXJnZXQuc3Vic3RyKGluZGV4ICsgMSlcclxuXHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IobG9jYXRvcilcclxuICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpXHJcblxyXG4gICAgICAgIGlmICghYXR0cikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGF0dHJpYnV0ZSAnJHthdHRyTmFtZX0nYClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB2YXJzOiB7XHJcbiAgICAgICAgICAgIFt2YWx1ZV06ICBhdHRyXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3N0b3JlRXZhbCc6IHtcclxuICAgICAgcmV0dXJuIHVudGlsSW5qZWN0ZWQoKVxyXG4gICAgICAudGhlbihhcGkgPT4ge1xyXG4gICAgICAgIHJldHVybiBhcGkuZXZhbCh0YXJnZXQpXHJcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+ICh7XHJcbiAgICAgICAgICB2YXJzOiB7XHJcbiAgICAgICAgICAgIFt2YWx1ZV06IHJlc3VsdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gcnVuRXZhbCBjb2RlOiAke2UubWVzc2FnZX1gKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnc3RvcmVWYWx1ZSc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQpXHJcbiAgICAgIC50aGVuKGVsID0+IHtcclxuICAgICAgICBjb25zdCB0ZXh0ICA9IGVsLnZhbHVlIHx8ICcnXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB2YXJzOiB7XHJcbiAgICAgICAgICAgIFt2YWx1ZV06IHRleHRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnc3RvcmVDaGVja2VkJzoge1xyXG4gICAgICByZXR1cm4gX19nZXRFbGVtZW50QnlMb2NhdG9yKHRhcmdldClcclxuICAgICAgLnRoZW4oZWwgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoZWNrZWQgID0gISFlbC5jaGVja2VkXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB2YXJzOiB7XHJcbiAgICAgICAgICAgIFt2YWx1ZV06IGNoZWNrZWRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAndmVyaWZ5VmFsdWUnOiB7XHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0KVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgY29uc3QgdGV4dCAgPSBlbC52YWx1ZVxyXG5cclxuICAgICAgICBpZiAoIWdsb2JNYXRjaCh2YWx1ZSwgdGV4dCkpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxvZzoge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBgdmFsdWUgbm90IG1hdGNoZWQsIFxcblxcdGV4cGVjdGVkOiBcIiR7dmFsdWV9XCIsIFxcblxcdGFjdHVhbDogXCIke3RleHR9XCJgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnYXNzZXJ0VmFsdWUnOiB7XHJcbiAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IodGFyZ2V0KVxyXG4gICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgY29uc3QgdGV4dCAgPSBlbC52YWx1ZVxyXG5cclxuICAgICAgICBpZiAoIWdsb2JNYXRjaCh2YWx1ZSwgdGV4dCkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgbm90IG1hdGNoZWQsIFxcblxcdGV4cGVjdGVkOiBcIiR7dmFsdWV9XCIsIFxcblxcdGFjdHVhbDogXCIke3RleHR9XCJgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdzZW5kS2V5cyc6IHtcclxuICAgICAgcmV0dXJuIF9fZ2V0RWxlbWVudEJ5TG9jYXRvcih0YXJnZXQpXHJcbiAgICAgIC50aGVuKGVsID0+IHtcclxuICAgICAgICBzZW5kS2V5cyhlbCwgdmFsdWUpXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdzZWxlY3RXaW5kb3cnOiB7XHJcbiAgICAgIGNvbnN0IHAgPSB0YXJnZXQgJiYgdGFyZ2V0LnRvVXBwZXJDYXNlKCkgPT09ICdUQUI9Q0xPU0VBTExPVEhFUidcclxuICAgICAgICAgICAgICAgICAgPyBjc0lwYy5hc2soJ0NTX0NMT1NFX09USEVSX1RBQlMnLCB7fSlcclxuICAgICAgICAgICAgICAgICAgOiBjc0lwYy5hc2soJ0NTX1NFTEVDVF9XSU5ET1cnLCB7IHRhcmdldCwgdmFsdWUgfSlcclxuXHJcbiAgICAgIC8vIE5vdGU6IGxldCBgc2VsZWN0V2luZG93YCBwYXNzIHRocm91Z2ggY3MgYW5kIGJhY2sgdG8gYmFja2dyb3VuZCxcclxuICAgICAgLy8gdG8ga2VlcCB0aGUgZmxvdyBtb3JlIGNvbnNpc3RlbnQgd2l0aCB0aGUgb3RoZXIgY29tbWFuZHNcclxuICAgICAgcmV0dXJuIHAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ3NvdXJjZVNlYXJjaCc6XHJcbiAgICBjYXNlICdzb3VyY2VFeHRyYWN0Jzoge1xyXG4gICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIHRleHQgLyByZWd1bGFyIGV4cHJlc3Npb24gdG8gc2VhcmNoIGZvcicpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhIHZhcmlhYmxlIHRvIHNhdmUgdGhlIHJlc3VsdCcpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGdldE1hdGNoQW5kQ2FwdHVyZUluZGV4ID0gKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vblplcm9JbmRleCA9IChuLCBvZmZzZXQgPSAwKSA9PiB7XHJcbiAgICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkKSAgcmV0dXJuIDBcclxuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBwYXJzZUludChuLCAxMCkgKyBvZmZzZXQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG0gPSAvQFxccyooXFxkKykoPzpcXHMqLFxccyooXFxkKykpP1xccyokLy5leGVjKHN0cilcclxuXHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN0OiAgICAgICAgIHN0cixcclxuICAgICAgICAgICAgbWF0Y2hJbmRleDogICAwLFxyXG4gICAgICAgICAgICBjYXB0dXJlSW5kZXg6IDBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByZXN0OiAgICAgICAgIHN0ci5zdWJzdHJpbmcoMCwgbS5pbmRleCksXHJcbiAgICAgICAgICBtYXRjaEluZGV4OiAgIG5vblplcm9JbmRleChtWzFdLCAtMSksXHJcbiAgICAgICAgICBjYXB0dXJlSW5kZXg6IG5vblplcm9JbmRleChtWzJdKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm90ZTogZ2V0IG1hdGNoSW5kZXggY2FwdHVyZUluZGV4IGZpcnN0LCBubyBtYXR0ZXIgaXQncyBmb3IgcmVnZXhwIG9yIHNpbXBsZSB0ZXh0XHJcbiAgICAgIGNvbnN0IHsgcmVzdCwgbWF0Y2hJbmRleCwgY2FwdHVyZUluZGV4IH0gPSBnZXRNYXRjaEFuZENhcHR1cmVJbmRleCh0YXJnZXQpXHJcblxyXG4gICAgICBpZiAoY21kID09PSAnc291cmNlU2VhcmNoJyAmJiByZXN0ICE9PSB0YXJnZXQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBAIHBhcmFtZXRlciBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzb3VyY2VFeHRyYWN0JylcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVnZXhwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIS9ecmVnZXgoPXw6KS9pLnRlc3QocmVzdCkpICByZXR1cm4gbnVsbFxyXG5cclxuICAgICAgICBjb25zdCByYXcgICAgICAgICA9IHJlc3QucmVwbGFjZSgvXnJlZ2V4KD18OikvaSwgJycpXHJcbiAgICAgICAgY29uc3QgcmVnZXhwVGV4dCAgPSByYXcucmVwbGFjZSgvXlxcL3xcXC9nPyQvZywgJycpXHJcblxyXG4gICAgICAgIHJldHVybiB0b1JlZ0V4cChcclxuICAgICAgICAgIHJlZ2V4cFRleHQsXHJcbiAgICAgICAgICB7IG5lZWRFbmNvZGU6IGZhbHNlLCBmbGFnOiAnZycgfVxyXG4gICAgICAgIClcclxuICAgICAgfSkoKVxyXG4gICAgICBjb25zdCByZWdleHBGb3JUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocmVnZXhwKSByZXR1cm4gbnVsbFxyXG4gICAgICAgIGNvbnN0IHJhdyA9IHJlc3QucmVwbGFjZSgvXnRleHQoPXw6KS9pLCAnJylcclxuXHJcbiAgICAgICAgaWYgKGNtZCA9PT0gJ3NvdXJjZUV4dHJhY3QnICYmICEvXFwqLy50ZXN0KHJhdykpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyAqIG9yIFJFR0VYIGluIHNvdXJjZUV4dHJhY3QuIEV4dHJhY3RpbmcgYSBwbGFpbiB0ZXh0IGRvZXNuXFwndCBtYWtlIG11Y2ggc2Vuc2UnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdsb2IycmVnKHJhdywgeyBjYXB0dXJlOiB0cnVlLCBmbGFnczogJ2cnIH0pXHJcbiAgICAgIH0pKClcclxuICAgICAgY29uc3QgbWF0Y2hlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgaHRtbCAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUxcclxuICAgICAgICBjb25zdCByZWcgICAgID0gcmVnZXhwIHx8IHJlZ2V4cEZvclRleHRcclxuICAgICAgICBjb25zdCByZXN1bHQgID0gW11cclxuICAgICAgICBsZXQgbVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICAgICAgICB3aGlsZSAobSA9IHJlZy5leGVjKGh0bWwpKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChtKVxyXG5cclxuICAgICAgICAgIC8vIE5vdGU6IHNhdmUgc29tZSBlbmVyZ3ksIGlmIGl0J3MgYWxyZWFkeSBlbm91Z2ggdG8gZ2V0IHdoYXQgdXNlcnMgd2FudFxyXG4gICAgICAgICAgaWYgKGNtZCA9PT0gJ3NvdXJjZUV4dHJhY3QnICYmIHJlc3VsdC5sZW5ndGggPj0gbWF0Y2hJbmRleCArIDEpIHtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgfSkoKVxyXG5cclxuICAgICAgbG9nKCdtYXRjaGVzJywgbWF0Y2hlcywgcmVnZXhwLCByZWdleHBGb3JUZXh0KVxyXG5cclxuICAgICAgaWYgKGNtZCA9PT0gJ3NvdXJjZVNlYXJjaCcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdmFyczoge1xyXG4gICAgICAgICAgICBbdmFsdWVdOiBtYXRjaGVzLmxlbmd0aFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNtZCA9PT0gJ3NvdXJjZUV4dHJhY3QnKSB7XHJcbiAgICAgICAgY29uc3QgZ3VhcmQgICA9IHN0ciA9PiBzdHIgIT09IHVuZGVmaW5lZCA/IHN0ciA6ICcjbm9tYXRjaGZvdW5kJ1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdmFyczoge1xyXG4gICAgICAgICAgICBbdmFsdWVdOiBndWFyZChcclxuICAgICAgICAgICAgICAobWF0Y2hlc1ttYXRjaEluZGV4XSB8fCBbXSlbY2FwdHVyZUluZGV4XVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcG9zc2libGUgdG8gcmVhY2ggaGVyZScpXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAndmlzaW9uTGltaXRTZWFyY2hBcmVhJzpcclxuICAgIGNhc2UgJ3N0b3JlSW1hZ2UnOiB7XHJcbiAgICAgIGNvbnN0IHJ1biA9IChsb2NhdG9yLCBmaWxlTmFtZSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBfX2dldEVsZW1lbnRCeUxvY2F0b3IobG9jYXRvcilcclxuICAgICAgICAudGhlbihlbCA9PiB7XHJcbiAgICAgICAgICBpZiAoIWZpbGVOYW1lIHx8ICFmaWxlTmFtZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdG9yZUltYWdlOiAndmFsdWUnIGlzIHJlcXVpcmVkIGFzIGltYWdlIG5hbWVgKVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgICAgY29uc3QgcFNvdXJjZU9mZnNldCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cudG9wID09PSB3aW5kb3cpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgeDogMCwgeTogMCB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RlOiBpdCdzIHRvbyBjb21wbGljYXRlZCB0byB0YWtlIHNjcmVlbnNob3Qgb2YgZWxlbWVudCBkZWVwIGluIGlmcmFtZSBzdGFja1xyXG4gICAgICAgICAgICAvLyBpZiB5b3UgaGF2ZSB0byBzY3JvbGwgZWFjaCBsZXZlbCBvZiBpZnJhbWUgdG8gZ2V0IHRoZSBmdWxsIGltYWdlIG9mIGl0LlxyXG4gICAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2Uod2luZG93LnBhcmVudCwgd2luZG93LCB7XHJcbiAgICAgICAgICAgICAgYWN0aW9uOiAnU09VUkNFX1BBR0VfT0ZGU0VUJyxcclxuICAgICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfSkoKVxyXG5cclxuICAgICAgICAgIHJldHVybiBwU291cmNlT2Zmc2V0LnRoZW4oc291cmNlT2Zmc2V0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHtcclxuICAgICAgICAgICAgICB4OiAgICAgIHNvdXJjZU9mZnNldC54ICsgY2xpZW50UmVjdC54ICsgc2Nyb2xsTGVmdChkb2N1bWVudCksXHJcbiAgICAgICAgICAgICAgeTogICAgICBzb3VyY2VPZmZzZXQueSArIGNsaWVudFJlY3QueSArIHNjcm9sbFRvcChkb2N1bWVudCksXHJcbiAgICAgICAgICAgICAgd2lkdGg6ICBjbGllbnRSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNzSXBjLmFzaygnQ1NfU1RPUkVfU0NSRUVOU0hPVF9JTl9TRUxFQ1RJT04nLCB7XHJcbiAgICAgICAgICAgICAgcmVjdCxcclxuICAgICAgICAgICAgICBmaWxlTmFtZTogZW5zdXJlRXh0TmFtZSgnLnBuZycsIGZpbGVOYW1lKSxcclxuICAgICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiAoe1xyXG4gICAgICAgICAgICAgIHZhcnM6IHtcclxuICAgICAgICAgICAgICAgICchc3RvcmVkSW1hZ2VSZWN0JzogcmVjdFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBsb2NhdG9yLCBmaWxlTmFtZVxyXG5cclxuICAgICAgaWYgKGNtZCA9PT0gJ3N0b3JlSW1hZ2UnKSB7XHJcbiAgICAgICAgbG9jYXRvciAgID0gdGFyZ2V0XHJcbiAgICAgICAgZmlsZU5hbWUgID0gdmFsdWVcclxuICAgICAgfSBlbHNlIGlmIChjbWQgPT09ICd2aXNpb25MaW1pdFNlYXJjaEFyZWEnKSB7XHJcbiAgICAgICAgbG9jYXRvciAgID0gdGFyZ2V0LnRyaW0oKS5yZXBsYWNlKC9eZWxlbWVudDovaSwgJycpLnRyaW0oKVxyXG4gICAgICAgIGZpbGVOYW1lICA9IExBU1RfU0NSRUVOU0hPVF9GSUxFX05BTUVcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJ1bihsb2NhdG9yLCBmaWxlTmFtZSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdjYXB0dXJlU2NyZWVuc2hvdCc6IHtcclxuICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhcHR1cmVTY3JlZW5zaG90OiAndGFyZ2V0JyBpcyByZXF1aXJlZCBhcyBmaWxlIG5hbWVgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY3NJcGMuYXNrKCdDU19DQVBUVVJFX1NDUkVFTlNIT1QnLCB7IGZpbGVOYW1lOiBlbnN1cmVFeHROYW1lKCcucG5nJywgdGFyZ2V0KSB9KVxyXG4gICAgICAudGhlbigoeyBmaWxlTmFtZSwgdXJsIH0pID0+ICh7XHJcbiAgICAgICAgc2NyZWVuc2hvdDoge1xyXG4gICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgbmFtZTogZmlsZU5hbWVcclxuICAgICAgICB9XHJcbiAgICAgIH0pKVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ2NhcHR1cmVFbnRpcmVQYWdlU2NyZWVuc2hvdCc6IHtcclxuICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhcHR1cmVFbnRpcmVQYWdlU2NyZWVuc2hvdDogJ3RhcmdldCcgaXMgcmVxdWlyZWQgYXMgZmlsZSBuYW1lYClcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNzSXBjLmFzaygnQ1NfQ0FQVFVSRV9GVUxMX1NDUkVFTlNIT1QnLCB7IGZpbGVOYW1lOiBlbnN1cmVFeHROYW1lKCcucG5nJywgdGFyZ2V0KSB9KVxyXG4gICAgICAudGhlbigoeyBmaWxlTmFtZSwgdXJsIH0pID0+ICh7XHJcbiAgICAgICAgc2NyZWVuc2hvdDoge1xyXG4gICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgbmFtZTogZmlsZU5hbWVcclxuICAgICAgICB9XHJcbiAgICAgIH0pKVxyXG4gICAgfVxyXG5cclxuICAgIGNhc2UgJ29uRG93bmxvYWQnOiB7XHJcbiAgICAgIHJldHVybiBjc0lwYy5hc2soJ0NTX09OX0RPV05MT0FEJywge1xyXG4gICAgICAgIGZpbGVOYW1lOiB0YXJnZXQsXHJcbiAgICAgICAgd2FpdDogKHZhbHVlIHx8ICcnKS50cmltKCkgPT09ICd0cnVlJyxcclxuICAgICAgICB0aW1lb3V0OiBleHRyYS50aW1lb3V0RG93bmxvYWQgKiAxMDAwLFxyXG4gICAgICAgIHRpbWVvdXRGb3JTdGFydDogTWF0aC5tYXgoMTAsIGV4dHJhLnRpbWVvdXRFbGVtZW50KSAqIDEwMDBcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjYXNlICdkZWxldGVBbGxDb29raWVzJzoge1xyXG4gICAgICByZXR1cm4gY3NJcGMuYXNrKCdDU19ERUxFVEVfQUxMX0NPT0tJRVMnLCB7XHJcbiAgICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKCgpID0+IHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgY2FzZSAnaWYnOlxyXG4gICAgY2FzZSAnd2hpbGUnOlxyXG4gICAgY2FzZSAnZ290b0lmJzoge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXZhbFxyXG4gICAgICAgICAgY29uZGl0aW9uOiB3aW5kb3cuZXZhbCh0YXJnZXQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBydW5FdmFsIGNvbmRpdGlvbiBvZiAke2NtZH06ICR7ZS5tZXNzYWdlfWApXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbW1hbmQgJHtjbWR9IG5vdCBzdXBwb3J0ZWQgeWV0YClcclxuICB9XHJcbn1cclxuIiwiXHJcbmNvbnN0IG1rID0gKGxpc3QpID0+IGxpc3QucmVkdWNlKChwcmV2LCBrZXkpID0+IHtcclxuICBwcmV2W2tleV0gPSBrZXk7XHJcbiAgcmV0dXJuIHByZXZcclxufSwge30pXHJcblxyXG5leHBvcnQgY29uc3QgQVBQX1NUQVRVUyA9IG1rKFtcclxuICAnTk9STUFMJyxcclxuICAnSU5TUEVDVE9SJyxcclxuICAnUkVDT1JERVInLFxyXG4gICdQTEFZRVInXHJcbl0pXHJcblxyXG5leHBvcnQgY29uc3QgSU5TUEVDVE9SX1NUQVRVUyA9IG1rKFtcclxuICAnUEVORElORycsXHJcbiAgJ0lOU1BFQ1RJTkcnLFxyXG4gICdTVE9QUEVEJ1xyXG5dKVxyXG5cclxuZXhwb3J0IGNvbnN0IFJFQ09SREVSX1NUQVRVUyA9IG1rKFtcclxuICAnUEVORElORycsXHJcbiAgJ1JFQ09SRElORycsXHJcbiAgJ1NUT1BQRUQnXHJcbl0pXHJcblxyXG5leHBvcnQgY29uc3QgUExBWUVSX1NUQVRVUyA9IG1rKFtcclxuICAnUExBWUlORycsXHJcbiAgJ1BBVVNFRCcsXHJcbiAgJ1NUT1BQRUQnXHJcbl0pXHJcblxyXG5leHBvcnQgY29uc3QgUExBWUVSX01PREUgPSBtayhbXHJcbiAgJ1RFU1RfQ0FTRScsXHJcbiAgJ1RFU1RfU1VJVEUnXHJcbl0pXHJcblxyXG5leHBvcnQgY29uc3QgQ09OVEVOVF9TQ1JJUFRfU1RBVFVTID0gbWsoW1xyXG4gICdOT1JNQUwnLFxyXG4gICdSRUNPUkRJTkcnLFxyXG4gICdJTlNQRUNUSU5HJyxcclxuICAnUExBWUlORydcclxuXSlcclxuXHJcbmV4cG9ydCBjb25zdCBURVNUX0NBU0VfU1RBVFVTID0gbWsoW1xyXG4gICdOT1JNQUwnLFxyXG4gICdTVUNDRVNTJyxcclxuICAnRVJST1InXHJcbl0pXHJcblxyXG5leHBvcnQgY29uc3QgTEFTVF9TQ1JFRU5TSE9UX0ZJTEVfTkFNRSA9ICdfX2xhc3RzY3JlZW5zaG90J1xyXG4iLCJpbXBvcnQgeyBhbmQgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFN0eWxlID0gZnVuY3Rpb24gKGRvbSkge1xyXG4gIGlmICghZG9tKSAgIHRocm93IG5ldyBFcnJvcignZ2V0U3R5bGU6IGRvbSBkb2VzIG5vdCBleGlzdCcpXHJcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZG9tKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc2V0U3R5bGUgPSBmdW5jdGlvbiAoZG9tLCBzdHlsZSkge1xyXG4gIGlmICghZG9tKSAgIHRocm93IG5ldyBFcnJvcignc2V0U3R5bGU6IGRvbSBkb2VzIG5vdCBleGlzdCcpXHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoc3R5bGUpLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBkb20uc3R5bGVba2V5c1tpXV0gPSBzdHlsZVtrZXlzW2ldXVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRvbVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcGl4ZWwgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgaWYgKChudW0gKyAnJykuaW5kZXhPZigncHgnKSAhPT0gLTEpICByZXR1cm4gbnVtXHJcbiAgcmV0dXJuIChudW0gfHwgMCkgKyAncHgnXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBiaW5kRHJhZyA9ICh7IG9uRHJhZ1N0YXJ0LCBvbkRyYWdFbmQsIG9uRHJhZywgJGVsLCBkb2MgPSBkb2N1bWVudCB9KSA9PiB7XHJcbiAgbGV0IGlzRHJhZ2dpbmcgPSBmYWxzZVxyXG4gIGxldCBzdGFydFBvcyA9IHsgeDogMCwgeTogMCB9XHJcblxyXG4gIGNvbnN0IG9uTW91c2VEb3duID0gKGUpID0+IHtcclxuICAgIGlzRHJhZ2dpbmcgPSB0cnVlXHJcbiAgICBzdGFydFBvcyA9IHsgeDogZS5zY3JlZW5YLCB5OiBlLnNjcmVlblkgfVxyXG4gICAgb25EcmFnU3RhcnQoZSlcclxuICB9XHJcbiAgY29uc3Qgb25Nb3VzZVVwID0gKGUpID0+IHtcclxuICAgIGlmICghaXNEcmFnZ2luZykgIHJldHVyblxyXG4gICAgaXNEcmFnZ2luZyA9IGZhbHNlXHJcbiAgICBjb25zdCBkeCA9IGUuc2NyZWVuWCAtIHN0YXJ0UG9zLnhcclxuICAgIGNvbnN0IGR5ID0gZS5zY3JlZW5ZIC0gc3RhcnRQb3MueVxyXG4gICAgb25EcmFnRW5kKGUsIHsgZHgsIGR5IH0pXHJcbiAgfVxyXG4gIGNvbnN0IG9uTW91c2VNb3ZlID0gKGUpID0+IHtcclxuICAgIGlmICghaXNEcmFnZ2luZykgIHJldHVyblxyXG5cclxuICAgIGNvbnN0IGR4ID0gZS5zY3JlZW5YIC0gc3RhcnRQb3MueFxyXG4gICAgY29uc3QgZHkgPSBlLnNjcmVlblkgLSBzdGFydFBvcy55XHJcbiAgICBvbkRyYWcoZSwgeyBkeCwgZHkgfSlcclxuXHJcbiAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICB9XHJcbiAgY29uc3Qgb25DbGljayA9IChlKSA9PiB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICB9XHJcblxyXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpXHJcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCB0cnVlKVxyXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCB0cnVlKVxyXG4gICRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgdHJ1ZSlcclxuXHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpXHJcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIHRydWUpXHJcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgdHJ1ZSlcclxuICAgICRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgdHJ1ZSlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBiaW5kQ29udGVudEVkaXRhYmxlQ2hhbmdlID0gKHsgb25DaGFuZ2UsIGRvYyA9IGRvY3VtZW50IH0pID0+IHtcclxuICBsZXQgY3VycmVudENFICAgPSBudWxsXHJcbiAgbGV0IG9sZENvbnRlbnQgID0gbnVsbFxyXG5cclxuICBjb25zdCBvbkZvY3VzID0gKGUpID0+IHtcclxuICAgIGlmIChlLnRhcmdldC5jb250ZW50RWRpdGFibGUgIT09ICd0cnVlJykgIHJldHVyblxyXG4gICAgY3VycmVudENFICAgPSBlLnRhcmdldFxyXG4gICAgb2xkQ29udGVudCAgPSBjdXJyZW50Q0UuaW5uZXJIVE1MXHJcbiAgfVxyXG4gIGNvbnN0IG9uQmx1ciA9IChlKSA9PiB7XHJcbiAgICBpZiAoZS50YXJnZXQgIT09IGN1cnJlbnRDRSkge1xyXG4gICAgICAvLyBEbyBub3RoaW5nXHJcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRDRS5pbm5lckhUTUwgIT09IG9sZENvbnRlbnQpIHtcclxuICAgICAgb25DaGFuZ2UoZSlcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50Q0UgICA9IG51bGxcclxuICAgIG9sZENvbnRlbnQgID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25Gb2N1cywgdHJ1ZSlcclxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1ciwgdHJ1ZSlcclxuXHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIG9uRm9jdXMsIHRydWUpXHJcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1ciwgdHJ1ZSlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBzY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBzY3JvbGxUb3AgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcclxuICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZG9tVGV4dCA9ICgkZG9tKSA9PiB7XHJcbiAgY29uc3QgaXQgID0gJGRvbS5pbm5lclRleHQgJiYgJGRvbS5pbm5lclRleHQudHJpbSgpXHJcbiAgY29uc3QgdGMgID0gJGRvbS50ZXh0Q29udGVudFxyXG4gIGNvbnN0IHBvcyA9IHRjLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihpdC50b1VwcGVyQ2FzZSgpKVxyXG5cclxuICByZXR1cm4gdGMuc3Vic3RyKHBvcywgaXQubGVuZ3RoKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgaWYgKGVsID09PSB3aW5kb3cuZG9jdW1lbnQpIHJldHVybiB0cnVlXHJcbiAgaWYgKCFlbCkgIHJldHVybiB0cnVlXHJcblxyXG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXHJcbiAgaWYgKHN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCBzdHlsZS5vcGFjaXR5ID09PSAnMCcgfHwgc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpICByZXR1cm4gZmFsc2VcclxuXHJcbiAgcmV0dXJuIGlzVmlzaWJsZShlbC5wYXJlbnROb2RlKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3NzU2VsZWN0b3IgPSBmdW5jdGlvbiAoZG9tKSB7XHJcbiAgaWYgKGRvbS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuICcnXHJcbiAgaWYgKGRvbS50YWdOYW1lID09PSAnQk9EWScpIHJldHVybiAnYm9keSdcclxuICBpZiAoZG9tLmlkKSByZXR1cm4gJyMnICsgZG9tLmlkXHJcblxyXG4gIHZhciBjbGFzc2VzID0gZG9tLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICYmIGl0ZW0ubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgdmFyIGNoaWxkcmVuID0gQXJyYXkuZnJvbShkb20ucGFyZW50Tm9kZS5jaGlsZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKCRlbCkge1xyXG4gICAgcmV0dXJuICRlbC5ub2RlVHlwZSA9PT0gMVxyXG4gIH0pXHJcblxyXG4gIHZhciBzYW1lVGFnID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICgkZWwpIHtcclxuICAgIHJldHVybiAkZWwudGFnTmFtZSA9PT0gZG9tLnRhZ05hbWVcclxuICB9KVxyXG5cclxuICB2YXIgc2FtZUNsYXNzID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICgkZWwpIHtcclxuICAgIHZhciBjcyA9ICRlbC5jbGFzc05hbWUuc3BsaXQoL1xccysvZylcclxuXHJcbiAgICByZXR1cm4gYW5kKC4uLmNsYXNzZXMubWFwKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgIHJldHVybiBjcy5pbmRleE9mKGMpICE9PSAtMVxyXG4gICAgfSkpXHJcbiAgfSlcclxuXHJcbiAgdmFyIGV4dHJhID0gJydcclxuXHJcbiAgaWYgKHNhbWVUYWcubGVuZ3RoID09PSAxKSB7XHJcbiAgICBleHRyYSA9ICcnXHJcbiAgfSBlbHNlIGlmIChjbGFzc2VzLmxlbmd0aCAmJiBzYW1lQ2xhc3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICBleHRyYSA9ICcuJyArIGNsYXNzZXMuam9pbignLicpXHJcbiAgfSBlbHNlIHtcclxuICAgIGV4dHJhID0gJzpudGgtY2hpbGQoJyArICgxICsgY2hpbGRyZW4uZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtID09PSBkb207IH0pKSArICcpJ1xyXG4gIH1cclxuXHJcbiAgdmFyIG1lID0gZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArIGV4dHJhXHJcblxyXG4gIC8vIE5vdGU6IGJyb3dzZXIgd2lsbCBhZGQgYW4gZXh0cmEgJ3Rib2R5JyB3aGVuIHRyIGRpcmVjdGx5IGluIHRhYmxlLCB3aGljaCB3aWxsIGNhdXNlIGFuIHdyb25nIHNlbGVjdG9yLFxyXG4gIC8vIHNvIHRoZSBoYWNrIGlzIHRvIHJlbW92ZSBhbGwgdGJvZHkgaGVyZVxyXG4gIHZhciByZXQgPSBjc3NTZWxlY3Rvcihkb20ucGFyZW50Tm9kZSkgKyAnID4gJyArIG1lXHJcbiAgcmV0dXJuIHJldFxyXG4gIC8vIHJldHVybiByZXQucmVwbGFjZSgvXFxzKj5cXHMqdGJvZHlcXHMqPj8vZywgJyAnKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaXNQb3NpdGlvbkZpeGVkID0gKCRkb20pID0+IHtcclxuICBpZiAoISRkb20gfHwgJGRvbSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8ICRkb20gPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiBmYWxzZVxyXG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKCRkb20pWydwb3NpdGlvbiddID09PSAnZml4ZWQnIHx8IGlzUG9zaXRpb25GaXhlZCgkZG9tLnBhcmVudE5vZGUpXHJcbn1cclxuIiwiXHJcbmZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnJheSwgaXRlbSkge1xyXG4gIHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XHJcblxyXG4gIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbnZhciBEYXRhVHJhbnNmZXIgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLmRhdGFCeUZvcm1hdCA9IHt9O1xyXG5cclxuICB0aGlzLmRyb3BFZmZlY3QgPSAnbm9uZSc7XHJcbiAgdGhpcy5lZmZlY3RBbGxvd2VkID0gJ2FsbCc7XHJcbiAgdGhpcy5maWxlcyA9IFtdO1xyXG4gIHRoaXMudHlwZXMgPSBbXTtcclxufTtcclxuXHJcbkRhdGFUcmFuc2Zlci5wcm90b3R5cGUuY2xlYXJEYXRhID0gZnVuY3Rpb24oZGF0YUZvcm1hdCkge1xyXG4gIGlmIChkYXRhRm9ybWF0KSB7XHJcbiAgICBkZWxldGUgdGhpcy5kYXRhQnlGb3JtYXRbZGF0YUZvcm1hdF07XHJcbiAgICByZW1vdmVGcm9tQXJyYXkodGhpcy50eXBlcywgZGF0YUZvcm1hdCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZGF0YUJ5Rm9ybWF0ID0ge307XHJcbiAgICB0aGlzLnR5cGVzID0gW107XHJcbiAgfVxyXG59O1xyXG5cclxuRGF0YVRyYW5zZmVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24oZGF0YUZvcm1hdCkge1xyXG4gIHJldHVybiB0aGlzLmRhdGFCeUZvcm1hdFtkYXRhRm9ybWF0XTtcclxufTtcclxuXHJcbkRhdGFUcmFuc2Zlci5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGFGb3JtYXQsIGRhdGEpIHtcclxuICB0aGlzLmRhdGFCeUZvcm1hdFtkYXRhRm9ybWF0XSA9IGRhdGE7XHJcblxyXG4gIGlmICh0aGlzLnR5cGVzLmluZGV4T2YoZGF0YUZvcm1hdCkgPCAwKSB7XHJcbiAgICB0aGlzLnR5cGVzLnB1c2goZGF0YUZvcm1hdCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkRhdGFUcmFuc2Zlci5wcm90b3R5cGUuc2V0RHJhZ0ltYWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgKHRoZSBzdHViIGp1c3QgbWFrZXMgc3VyZSB0aGVyZSBpcyBubyBlcnJvciB0aHJvd24gaWYgc29tZW9uZSB0cmllcyB0byBjYWxsIHRoZSBtZXRob2QpXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgLy8gTm90ZTogaW4gRmlyZWZveCwgd2luZG93LkRhdGFUcmFuc2ZlciBleGlzdHMsIGJ1dCBpdCBjYW4ndCBiZSB1c2VkIGFzIGNvbnN0cnVjdG9yXHJcbiAgLy8gSW4gRmlyZWZveCwgYG5ldyB3aW5kb3cuRGF0YVRyYW5zZmVyKClgIHRocm93cyBlcnJvcnMgbGlrZSAnVHlwZUVycm9yOiBJbGxlZ2FsIGNvbnN0cnVjdG9yJ1xyXG4gIGlmICh3aW5kb3cuRGF0YVRyYW5zZmVyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0bXAgPSBuZXcgd2luZG93LkRhdGFUcmFuc2ZlcigpXHJcbiAgICAgIHJldHVybiB3aW5kb3cuRGF0YVRyYW5zZmVyXHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIERhdGFUcmFuc2ZlclxyXG59KSgpXHJcbiIsIlxyXG52YXIgZXZlbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9ldmVudEZhY3RvcnknKVxyXG4gICwgRGF0YVRyYW5zZmVyID0gcmVxdWlyZSgnLi9EYXRhVHJhbnNmZXInKTtcclxuXHJcblxyXG5mdW5jdGlvbiBfbm9vcCgpIHt9XHJcblxyXG5cclxuZnVuY3Rpb24gcGFyc2VQYXJhbXModGFyZ2V0RWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaykge1xyXG4gIGlmICh0eXBlb2YgZXZlbnRQcm9wZXJ0aWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBjb25maWdDYWxsYmFjayA9IGV2ZW50UHJvcGVydGllcztcclxuICAgIGV2ZW50UHJvcGVydGllcyA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoIXRhcmdldEVsZW1lbnQgfHwgdHlwZW9mIHRhcmdldEVsZW1lbnQgIT09ICdvYmplY3QnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGZpcnN0IHBhcmFtZXRlciB0byBiZSBhIHRhcmdldEVsZW1lbnQuIEluc3RlYWQgZ290OiAnICsgdGFyZ2V0RWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudCxcclxuICAgIGV2ZW50UHJvcGVydGllczogZXZlbnRQcm9wZXJ0aWVzIHx8IHt9LFxyXG4gICAgY29uZmlnQ2FsbGJhY2s6IGNvbmZpZ0NhbGxiYWNrIHx8IF9ub29wXHJcbiAgfTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGN1c3RvbWl6ZUV2ZW50KGV2ZW50LCBjb25maWdDYWxsYmFjaywgaXNQcmltYXJ5RXZlbnQpIHtcclxuICBpZiAoY29uZmlnQ2FsbGJhY2spIHtcclxuICAgIC8vIGNhbGwgY29uZmlnQ2FsbGJhY2sgb25seSBmb3IgdGhlIHByaW1hcnkgZXZlbnQgaWYgdGhlIGNhbGxiYWNrIHRha2VzIGxlc3MgdGhhbiB0d28gYXJndW1lbnRzXHJcbiAgICBpZiAoY29uZmlnQ2FsbGJhY2subGVuZ3RoIDwgMikge1xyXG4gICAgICBpZiAoaXNQcmltYXJ5RXZlbnQpIHsgY29uZmlnQ2FsbGJhY2soZXZlbnQpOyB9XHJcbiAgICB9XHJcbiAgICAvLyBjYWxsIGNvbmZpZ0NhbGxiYWNrIGZvciBlYWNoIGV2ZW50IGlmIHRoZSBjYWxsYmFjayB0YWtlcyB0d28gYXJndW1lbnRzXHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uZmlnQ2FsbGJhY2soZXZlbnQsIGV2ZW50LnR5cGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFuZERpc3BhdGNoRXZlbnRzKHRhcmdldEVsZW1lbnQsIGV2ZW50TmFtZXMsIHByaW1hcnlFdmVudE5hbWUsIGRhdGFUcmFuc2ZlciwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaykge1xyXG4gIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcclxuICAgIHZhciBldmVudCA9IGV2ZW50RmFjdG9yeS5jcmVhdGVFdmVudChldmVudE5hbWUsIGV2ZW50UHJvcGVydGllcywgZGF0YVRyYW5zZmVyKTtcclxuICAgIHZhciBpc1ByaW1hcnlFdmVudCA9IGV2ZW50TmFtZSA9PT0gcHJpbWFyeUV2ZW50TmFtZTtcclxuXHJcbiAgICBjdXN0b21pemVFdmVudChldmVudCwgY29uZmlnQ2FsbGJhY2ssIGlzUHJpbWFyeUV2ZW50KTtcclxuXHJcbiAgICB0YXJnZXRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5cclxudmFyIERyYWdEcm9wQWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5sYXN0RHJhZ1NvdXJjZSA9IG51bGw7XHJcbiAgdGhpcy5sYXN0RGF0YVRyYW5zZmVyID0gbnVsbDtcclxuICB0aGlzLnBlbmRpbmdBY3Rpb25zUXVldWUgPSBbXTtcclxufTtcclxuXHJcblxyXG5EcmFnRHJvcEFjdGlvbi5wcm90b3R5cGUuX3F1ZXVlID0gZnVuY3Rpb24oZm4pIHtcclxuICB0aGlzLnBlbmRpbmdBY3Rpb25zUXVldWUucHVzaChmbik7XHJcblxyXG4gIGlmICh0aGlzLnBlbmRpbmdBY3Rpb25zUXVldWUubGVuZ3RoID09PSAxKSB7XHJcbiAgICB0aGlzLl9xdWV1ZUV4ZWN1dGVOZXh0KCk7XHJcbiAgfVxyXG59O1xyXG5cclxuRHJhZ0Ryb3BBY3Rpb24ucHJvdG90eXBlLl9xdWV1ZUV4ZWN1dGVOZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKHRoaXMucGVuZGluZ0FjdGlvbnNRdWV1ZS5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XHJcblxyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICB2YXIgZmlyc3RQZW5kaW5nQWN0aW9uID0gdGhpcy5wZW5kaW5nQWN0aW9uc1F1ZXVlWzBdO1xyXG5cclxuICB2YXIgZG9uZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLnBlbmRpbmdBY3Rpb25zUXVldWUuc2hpZnQoKTtcclxuICAgIHNlbGYuX3F1ZXVlRXhlY3V0ZU5leHQoKTtcclxuICB9O1xyXG5cclxuICBpZiAoZmlyc3RQZW5kaW5nQWN0aW9uLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZmlyc3RQZW5kaW5nQWN0aW9uLmNhbGwodGhpcyk7XHJcbiAgICBkb25lQ2FsbGJhY2soKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZmlyc3RQZW5kaW5nQWN0aW9uLmNhbGwodGhpcywgZG9uZUNhbGxiYWNrKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuRHJhZ0Ryb3BBY3Rpb24ucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQsIGV2ZW50UHJvcGVydGllcywgY29uZmlnQ2FsbGJhY2spIHtcclxuICB2YXIgcGFyYW1zID0gcGFyc2VQYXJhbXModGFyZ2V0RWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaylcclxuICAgICwgZXZlbnRzID0gWydtb3VzZWRvd24nLCAnZHJhZ3N0YXJ0JywgJ2RyYWcnXVxyXG4gICAgLCBkYXRhVHJhbnNmZXIgPSBuZXcgRGF0YVRyYW5zZmVyKCk7XHJcblxyXG4gIHRoaXMuX3F1ZXVlKGZ1bmN0aW9uKCkge1xyXG4gICAgY3JlYXRlQW5kRGlzcGF0Y2hFdmVudHMocGFyYW1zLnRhcmdldEVsZW1lbnQsIGV2ZW50cywgJ2RyYWcnLCBkYXRhVHJhbnNmZXIsIHBhcmFtcy5ldmVudFByb3BlcnRpZXMsIHBhcmFtcy5jb25maWdDYWxsYmFjayk7XHJcblxyXG4gICAgdGhpcy5sYXN0RHJhZ1NvdXJjZSA9IHRhcmdldEVsZW1lbnQ7XHJcbiAgICB0aGlzLmxhc3REYXRhVHJhbnNmZXIgPSBkYXRhVHJhbnNmZXI7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbkRyYWdEcm9wQWN0aW9uLnByb3RvdHlwZS5kcmFnRW50ZXIgPSBmdW5jdGlvbihvdmVyRWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaykge1xyXG4gIHZhciBwYXJhbXMgPSBwYXJzZVBhcmFtcyhvdmVyRWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaylcclxuICAgICwgZXZlbnRzID0gWydtb3VzZW1vdmUnLCAnbW91c2VvdmVyJywgJ2RyYWdlbnRlciddO1xyXG5cclxuICB0aGlzLl9xdWV1ZShmdW5jdGlvbigpIHtcclxuICAgIGNyZWF0ZUFuZERpc3BhdGNoRXZlbnRzKHBhcmFtcy50YXJnZXRFbGVtZW50LCBldmVudHMsICdkcmFnZW50ZXInLCB0aGlzLmxhc3REYXRhVHJhbnNmZXIsIHBhcmFtcy5ldmVudFByb3BlcnRpZXMsIHBhcmFtcy5jb25maWdDYWxsYmFjayk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRHJhZ0Ryb3BBY3Rpb24ucHJvdG90eXBlLmRyYWdPdmVyID0gZnVuY3Rpb24ob3ZlckVsZW1lbnQsIGV2ZW50UHJvcGVydGllcywgY29uZmlnQ2FsbGJhY2spIHtcclxuICB2YXIgcGFyYW1zID0gcGFyc2VQYXJhbXMob3ZlckVsZW1lbnQsIGV2ZW50UHJvcGVydGllcywgY29uZmlnQ2FsbGJhY2spXHJcbiAgICAsIGV2ZW50cyA9IFsnbW91c2Vtb3ZlJywgJ21vdXNlb3ZlcicsICdkcmFnb3ZlciddO1xyXG5cclxuICB0aGlzLl9xdWV1ZShmdW5jdGlvbigpIHtcclxuICAgIGNyZWF0ZUFuZERpc3BhdGNoRXZlbnRzKHBhcmFtcy50YXJnZXRFbGVtZW50LCBldmVudHMsICdkcmFnJywgdGhpcy5sYXN0RGF0YVRyYW5zZmVyLCBwYXJhbXMuZXZlbnRQcm9wZXJ0aWVzLCBwYXJhbXMuY29uZmlnQ2FsbGJhY2spO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdEcm9wQWN0aW9uLnByb3RvdHlwZS5kcmFnTGVhdmUgPSBmdW5jdGlvbihvdmVyRWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaykge1xyXG4gIHZhciBwYXJhbXMgPSBwYXJzZVBhcmFtcyhvdmVyRWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaylcclxuICAgICwgZXZlbnRzID0gWydtb3VzZW1vdmUnLCAnbW91c2VvdmVyJywgJ2RyYWdsZWF2ZSddO1xyXG5cclxuICB0aGlzLl9xdWV1ZShmdW5jdGlvbigpIHtcclxuICAgIGNyZWF0ZUFuZERpc3BhdGNoRXZlbnRzKHBhcmFtcy50YXJnZXRFbGVtZW50LCBldmVudHMsICdkcmFnbGVhdmUnLCB0aGlzLmxhc3REYXRhVHJhbnNmZXIsIHBhcmFtcy5ldmVudFByb3BlcnRpZXMsIHBhcmFtcy5jb25maWdDYWxsYmFjayk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRHJhZ0Ryb3BBY3Rpb24ucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50LCBldmVudFByb3BlcnRpZXMsIGNvbmZpZ0NhbGxiYWNrKSB7XHJcbiAgdmFyIHBhcmFtcyA9IHBhcnNlUGFyYW1zKHRhcmdldEVsZW1lbnQsIGV2ZW50UHJvcGVydGllcywgY29uZmlnQ2FsbGJhY2spO1xyXG4gIHZhciBldmVudHNPbkRyb3BUYXJnZXQgPSBbJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ2Ryb3AnXTtcclxuICB2YXIgZXZlbnRzT25EcmFnU291cmNlID0gWydkcmFnZW5kJ107XHJcblxyXG4gIHRoaXMuX3F1ZXVlKGZ1bmN0aW9uKCkge1xyXG4gICAgY3JlYXRlQW5kRGlzcGF0Y2hFdmVudHMocGFyYW1zLnRhcmdldEVsZW1lbnQsIGV2ZW50c09uRHJvcFRhcmdldCwgJ2Ryb3AnLCB0aGlzLmxhc3REYXRhVHJhbnNmZXIsIHBhcmFtcy5ldmVudFByb3BlcnRpZXMsIHBhcmFtcy5jb25maWdDYWxsYmFjayk7XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdERyYWdTb3VyY2UpIHtcclxuICAgICAgLy8gdHJpZ2dlciBkcmFnZW5kIGV2ZW50IG9uIGxhc3QgZHJhZyBzb3VyY2UgZWxlbWVudFxyXG4gICAgICBjcmVhdGVBbmREaXNwYXRjaEV2ZW50cyh0aGlzLmxhc3REcmFnU291cmNlLCBldmVudHNPbkRyYWdTb3VyY2UsICdkcm9wJywgdGhpcy5sYXN0RGF0YVRyYW5zZmVyLCBwYXJhbXMuZXZlbnRQcm9wZXJ0aWVzLCBwYXJhbXMuY29uZmlnQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkRyYWdEcm9wQWN0aW9uLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICB0aGlzLl9xdWV1ZShmdW5jdGlvbigpIHsgY2FsbGJhY2suY2FsbCh0aGlzKTsgfSk7ICAgIC8vIG1ha2Ugc3VyZSBfcXVldWUoKSBpcyBnaXZlbiBhIGNhbGxiYWNrIHdpdGggbm8gYXJndW1lbnRzXHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRHJhZ0Ryb3BBY3Rpb24ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24od2FpdGluZ1RpbWVNcykge1xyXG4gIHRoaXMuX3F1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGRvbmUsIHdhaXRpbmdUaW1lTXMpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhZ0Ryb3BBY3Rpb247XHJcbiIsIlxyXG52YXIgRGF0YVRyYW5zZmVyID0gcmVxdWlyZSgnLi9EYXRhVHJhbnNmZXInKTtcclxuXHJcbnZhciBkYXRhVHJhbnNmZXJFdmVudHMgPSBbJ2RyYWcnLCAnZHJhZ3N0YXJ0JywgJ2RyYWdlbnRlcicsICdkcmFnb3ZlcicsICdkcmFnZW5kJywgJ2Ryb3AnLCAnZHJhZ2xlYXZlJ107XHJcblxyXG5cclxuZnVuY3Rpb24gbWVyZ2VJbnRvKGRlc3RPYmosIHNyY09iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBzcmNPYmopIHtcclxuICAgIGlmICghc3JjT2JqLmhhc093blByb3BlcnR5KGtleSkpIHsgY29udGludWU7IH0gICAvLyBpZ25vcmUgaW5oZXJpdGVkIHByb3BlcnRpZXNcclxuXHJcbiAgICBkZXN0T2JqW2tleV0gPSBzcmNPYmpba2V5XTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkZXN0T2JqO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ZpcmVmb3ggKCkge1xyXG4gIHJldHVybiAvRmlyZWZveC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTW9kZXJuRXZlbnQoZXZlbnROYW1lLCBldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcykge1xyXG4gIC8vIGlmIChldmVudFR5cGUgPT09ICdEcmFnRXZlbnQnKSB7IGV2ZW50VHlwZSA9ICdDdXN0b21FdmVudCc7IH0gICAgIC8vIEZpcmVmb3ggZml4IChzaW5jZSBGRiBkb2VzIG5vdCBhbGxvdyB1cyB0byBvdmVycmlkZSBkYXRhVHJhbnNmZXIpXHJcblxyXG4gIHZhciBjb25zdHJ1Y3RvciA9IHdpbmRvd1tldmVudFR5cGVdO1xyXG4gIHZhciBvcHRpb25zID0geyB2aWV3OiB3aW5kb3csIGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfTtcclxuXHJcbiAgbWVyZ2VJbnRvKG9wdGlvbnMsIGV2ZW50UHJvcGVydGllcyk7XHJcblxyXG4gIHZhciBldmVudCA9IG5ldyBjb25zdHJ1Y3RvcihldmVudE5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICBtZXJnZUludG8oZXZlbnQsIGV2ZW50UHJvcGVydGllcyk7XHJcblxyXG4gIHJldHVybiBldmVudDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMpIHtcclxuICB2YXIgZXZlbnQ7XHJcblxyXG4gIHN3aXRjaCAoZXZlbnRUeXBlKSB7XHJcbiAgICBjYXNlICdNb3VzZUV2ZW50JzpcclxuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xyXG4gICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcclxuICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBjb3B5IGV2ZW50UHJvcGVydGllcyBpbnRvIGV2ZW50XHJcbiAgaWYgKGV2ZW50UHJvcGVydGllcykge1xyXG4gICAgbWVyZ2VJbnRvKGV2ZW50LCBldmVudFByb3BlcnRpZXMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV2ZW50O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRXZlbnQoZXZlbnROYW1lLCBldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcykge1xyXG4gIGlmIChpc0ZpcmVmb3goKSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUxlZ2FjeUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBjcmVhdGVNb2Rlcm5FdmVudChldmVudE5hbWUsIGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUxlZ2FjeUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbnZhciBFdmVudEZhY3RvcnkgPSB7XHJcbiAgY3JlYXRlRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRQcm9wZXJ0aWVzLCBkYXRhVHJhbnNmZXIpIHtcclxuICAgIHZhciBldmVudFR5cGUgPSAnQ3VzdG9tRXZlbnQnO1xyXG5cclxuICAgIGlmIChldmVudE5hbWUubWF0Y2goL15tb3VzZS8pKSB7XHJcbiAgICAgIGV2ZW50VHlwZSA9ICdNb3VzZUV2ZW50JztcclxuICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lLm1hdGNoKC9eKGRyYWd8ZHJvcCkvKSkge1xyXG4gICAgICBldmVudFR5cGUgPSAnRHJhZ0V2ZW50J1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhVHJhbnNmZXJFdmVudHMuaW5kZXhPZihldmVudE5hbWUpID4gLTEpIHtcclxuICAgICAgZXZlbnRQcm9wZXJ0aWVzLmRhdGFUcmFuc2ZlciA9IGRhdGFUcmFuc2ZlciB8fCBuZXcgRGF0YVRyYW5zZmVyKClcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXZlbnQgPSBjcmVhdGVFdmVudChldmVudE5hbWUsIGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzKTtcclxuXHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEZhY3Rvcnk7XHJcbiIsIlxyXG52YXIgRHJhZ0Ryb3BBY3Rpb24gPSByZXF1aXJlKCcuL0RyYWdEcm9wQWN0aW9uJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gY2FsbChpbnN0YW5jZSwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gIHJldHVybiBpbnN0YW5jZVttZXRob2ROYW1lXS5hcHBseShpbnN0YW5jZSwgYXJncyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyaWdnZXJEcmFnRXZlbnQgKGVsZW1lbnQsIHRhcmdldCkge1xyXG4gIHZhciBnZXRYcGF0aE9mRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVsZW1lbnQucGFyZW50RWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gJy8nICsgZWxlbWVudC50YWdOYW1lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2libGluZ0VsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW47XHJcbiAgICAgIHZhciB0YWdDb3VudCA9IDA7XHJcbiAgICAgIHZhciB0b3RhbFRhZ0NvdW50ID0gMDtcclxuICAgICAgdmFyIGlzRm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2libGluZ0VsZW1lbnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChzaWJsaW5nRWxlbWVudFtpXS50YWdOYW1lID09IGVsZW1lbnQudGFnTmFtZSAmJiAhaXNGb3VuZCkge1xyXG4gICAgICAgICAgICAgIHRhZ0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgdG90YWxUYWdDb3VudCsrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzaWJsaW5nRWxlbWVudFtpXS50YWdOYW1lID09IGVsZW1lbnQudGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgIHRvdGFsVGFnQ291bnQrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzaWJsaW5nRWxlbWVudFtpXSA9PSBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgaXNGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0b3RhbFRhZ0NvdW50ID4gMSkge1xyXG4gICAgICAgICAgcmV0dXJuIGdldFhwYXRoT2ZFbGVtZW50KGVsZW1lbnQucGFyZW50RWxlbWVudCkgKyBcIi9cIiArIGVsZW1lbnQudGFnTmFtZSArIFwiW1wiICsgdGFnQ291bnQgKyBcIl1cIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGdldFhwYXRoT2ZFbGVtZW50KGVsZW1lbnQucGFyZW50RWxlbWVudCkgKyBcIi9cIiArIGVsZW1lbnQudGFnTmFtZTtcclxuICB9O1xyXG4gIHZhciBzY3JpcHQgPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICBmdW5jdGlvbiBzaW11bGF0ZURyYWdEcm9wKHNvdXJjZU5vZGUsIGRlc3RpbmF0aW9uTm9kZSl7XFxcclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnQodHlwZSkgeyAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7ICAgICAgICBcXFxyXG4gICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIG51bGwpOyAgICAgXFxcclxuICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2ZlciA9IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICAgICAgZGF0YTogeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICAgICAgICAgIH0sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICAgICAgICAgICAgICBzZXREYXRhOiBmdW5jdGlvbih0eXBlLCB2YWwpIHsgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVt0eXBlXSA9IHZhbDsgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICAgICAgICAgIH0sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICAgICAgICAgICAgICBnZXREYXRhOiBmdW5jdGlvbih0eXBlKSB7ICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbdHlwZV07ICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICAgICAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBldmVudCkgeyAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICBpZiAobm9kZS5kaXNwYXRjaEV2ZW50KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICAgICAgICAgIHJldHVybiBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpOyAgICAgICAgICAgICAgXFxcclxuICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgICAgICBpZiAobm9kZS5maXJlRXZlbnQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICAgICAgICAgIHJldHVybiBub2RlLmZpcmVFdmVudCgnb24nICsgdHlwZSwgZXZlbnQpOyAgICAgXFxcclxuICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICB2YXIgZXZlbnQgPSBjcmVhdGVDdXN0b21FdmVudCgnZHJhZ3N0YXJ0Jyk7ICAgICAgICAgICAgXFxcclxuICAgICAgZGlzcGF0Y2hFdmVudChzb3VyY2VOb2RlLCAnZHJhZ3N0YXJ0JywgZXZlbnQpOyAgICAgICAgIFxcXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxyXG4gICAgICB2YXIgZHJvcEV2ZW50ID0gY3JlYXRlQ3VzdG9tRXZlbnQoJ2Ryb3AnKTsgICAgICAgICAgICAgXFxcclxuICAgICAgZHJvcEV2ZW50LmRhdGFUcmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2ZlcjsgICAgICAgICAgIFxcXHJcbiAgICAgIGRpc3BhdGNoRXZlbnQoZGVzdGluYXRpb25Ob2RlLCAnZHJvcCcsIGRyb3BFdmVudCk7ICAgICBcXFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICAgICAgdmFyIGRyYWdFbmRFdmVudCA9IGNyZWF0ZUN1c3RvbUV2ZW50KCdkcmFnZW5kJyk7ICAgICAgIFxcXHJcbiAgICAgIGRyYWdFbmRFdmVudC5kYXRhVHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXI7ICAgICAgICBcXFxyXG4gICAgICBkaXNwYXRjaEV2ZW50KHNvdXJjZU5vZGUsICdkcmFnZW5kJywgZHJhZ0VuZEV2ZW50KTsgICAgXFxcclxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXHJcbiAgc2ltdWxhdGVEcmFnRHJvcChkb2N1bWVudC5ldmFsdWF0ZSgnXCIgKyBnZXRYcGF0aE9mRWxlbWVudChlbGVtZW50KSArIFwiJywgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkZJUlNUX09SREVSRURfTk9ERV9UWVBFLCBudWxsKS5zaW5nbGVOb2RlVmFsdWUsIGRvY3VtZW50LmV2YWx1YXRlKCdcIiArIGdldFhwYXRoT2ZFbGVtZW50KHRhcmdldCkgKyBcIicsIGRvY3VtZW50LCBudWxsLCBYUGF0aFJlc3VsdC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRSwgbnVsbCkuc2luZ2xlTm9kZVZhbHVlKTtcXFxyXG4gIFwiO1xyXG4gIHZhciB3aW4gPSB3aW5kb3c7XHJcbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcclxuICB2YXIgc2NyaXB0VGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgc2NyaXB0VGFnLnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xyXG4gIHNjcmlwdFRhZy50ZXh0ID0gc2NyaXB0O1xyXG4gIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XHJcbn1cclxuXHJcblxyXG52YXIgZHJhZ01vY2sgPSB7XHJcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbih0YXJnZXRFbGVtZW50LCBldmVudFByb3BlcnRpZXMsIGNvbmZpZ0NhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gY2FsbChuZXcgRHJhZ0Ryb3BBY3Rpb24oKSwgJ2RyYWdTdGFydCcsIGFyZ3VtZW50cyk7XHJcbiAgfSxcclxuICBkcmFnRW50ZXI6IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQsIGV2ZW50UHJvcGVydGllcywgY29uZmlnQ2FsbGJhY2spIHtcclxuICAgIHJldHVybiBjYWxsKG5ldyBEcmFnRHJvcEFjdGlvbigpLCAnZHJhZ0VudGVyJywgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIGRyYWdPdmVyOiBmdW5jdGlvbih0YXJnZXRFbGVtZW50LCBldmVudFByb3BlcnRpZXMsIGNvbmZpZ0NhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gY2FsbChuZXcgRHJhZ0Ryb3BBY3Rpb24oKSwgJ2RyYWdPdmVyJywgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIGRyYWdMZWF2ZTogZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIGNhbGwobmV3IERyYWdEcm9wQWN0aW9uKCksICdkcmFnTGVhdmUnLCBhcmd1bWVudHMpO1xyXG4gIH0sXHJcbiAgZHJvcDogZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnRQcm9wZXJ0aWVzLCBjb25maWdDYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIGNhbGwobmV3IERyYWdEcm9wQWN0aW9uKCksICdkcm9wJywgYXJndW1lbnRzKTtcclxuICB9LFxyXG4gIGRlbGF5OiBmdW5jdGlvbih0YXJnZXRFbGVtZW50LCBldmVudFByb3BlcnRpZXMsIGNvbmZpZ0NhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gY2FsbChuZXcgRHJhZ0Ryb3BBY3Rpb24oKSwgJ2RlbGF5JywgYXJndW1lbnRzKTtcclxuICB9LFxyXG5cclxuICB0cmlnZ2VyRHJhZ0V2ZW50LFxyXG5cclxuICAvLyBKdXN0IGZvciB1bml0IHRlc3Rpbmc6XHJcbiAgRGF0YVRyYW5zZmVyOiByZXF1aXJlKCcuL0RhdGFUcmFuc2ZlcicpLFxyXG4gIERyYWdEcm9wQWN0aW9uOiByZXF1aXJlKCcuL0RyYWdEcm9wQWN0aW9uJyksXHJcbiAgZXZlbnRGYWN0b3J5OiByZXF1aXJlKCcuL2V2ZW50RmFjdG9yeScpXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRyYWdNb2NrO1xyXG4iLCJpbXBvcnQgcGJrZGYyIGZyb20gJ3Bia2RmMidcclxuaW1wb3J0IGFlc2pzIGZyb20gJ2Flcy1qcydcclxuaW1wb3J0IEV4dCBmcm9tICcuL3dlYl9leHRlbnNpb24nXHJcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSdcclxuXHJcbmNvbnN0IFJBV19QUkVGSVggPSAnQF9LQU5UVV9AJ1xyXG5jb25zdCBDSVBIRVJfUFJFRklYID0gJ19fS0FOVFVfRU5DUllQVEVEX18nXHJcbmNvbnN0IFJBV19QUkVGSVhfUkVHID0gbmV3IFJlZ0V4cCgnXicgKyBSQVdfUFJFRklYKVxyXG5jb25zdCBDSVBIRVJfUFJFRklYX1JFRyA9IG5ldyBSZWdFeHAoJ14nICsgQ0lQSEVSX1BSRUZJWClcclxuXHJcbmNvbnN0IGdldEVuY3J5cHRDb25maWcgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIHN0b3JhZ2UuZ2V0KCdjb25maWcnKVxyXG4gIC50aGVuKGNvbmZpZyA9PiAoe1xyXG4gICAgc2hvdWxkRW5jcnlwdDogY29uZmlnLnNob3VsZEVuY3J5cHRQYXNzd29yZCA9PT0gJ21hc3Rlcl9wYXNzd29yZCcsXHJcbiAgICBtYXN0ZXJQYXNzd29yZDogY29uZmlnLm1hc3RlclBhc3N3b3JkXHJcbiAgfSkpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhZXNFbmNyeXB0ID0gKHRleHQsIHBhc3N3b3JkKSA9PiB7XHJcbiAgY29uc3Qga2V5ICAgICA9IHBia2RmMi5wYmtkZjJTeW5jKHBhc3N3b3JkLCAnc2FsdCcsIDEsIDI1NiAvIDgsICdzaGE1MTInKVxyXG4gIGNvbnN0IGVuZ2luZSAgPSBuZXcgYWVzanMuTW9kZU9mT3BlcmF0aW9uLmN0cihrZXkpXHJcblxyXG4gIHJldHVybiBhZXNqcy51dGlscy5oZXguZnJvbUJ5dGVzKFxyXG4gICAgZW5naW5lLmVuY3J5cHQoXHJcbiAgICAgIGFlc2pzLnV0aWxzLnV0ZjgudG9CeXRlcyh0ZXh0KVxyXG4gICAgKVxyXG4gIClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFlc0RlY3J5cHQgPSAodGV4dCwgcGFzc3dvcmQpID0+IHtcclxuICBjb25zdCBrZXkgICAgID0gcGJrZGYyLnBia2RmMlN5bmMocGFzc3dvcmQsICdzYWx0JywgMSwgMjU2IC8gOCwgJ3NoYTUxMicpXHJcbiAgY29uc3QgZW5naW5lICA9IG5ldyBhZXNqcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKGtleSlcclxuXHJcbiAgcmV0dXJuIGFlc2pzLnV0aWxzLnV0ZjguZnJvbUJ5dGVzKFxyXG4gICAgZW5naW5lLmRlY3J5cHQoXHJcbiAgICAgIGFlc2pzLnV0aWxzLmhleC50b0J5dGVzKHRleHQpXHJcbiAgICApXHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZW5jcnlwdCA9ICh0ZXh0KSA9PiB7XHJcbiAgcmV0dXJuIGdldEVuY3J5cHRDb25maWcoKVxyXG4gIC50aGVuKCh7IHNob3VsZEVuY3J5cHQsIG1hc3RlclBhc3N3b3JkIH0pID0+IHtcclxuICAgIGlmICghc2hvdWxkRW5jcnlwdCkgcmV0dXJuIHRleHRcclxuICAgIHJldHVybiBgJHtDSVBIRVJfUFJFRklYfSR7YWVzRW5jcnlwdChSQVdfUFJFRklYICsgdGV4dCwgbWFzdGVyUGFzc3dvcmQpfWBcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGVjcnlwdCA9ICh0ZXh0KSA9PiB7XHJcbiAgcmV0dXJuIGdldEVuY3J5cHRDb25maWcoKVxyXG4gIC50aGVuKCh7IHNob3VsZEVuY3J5cHQsIG1hc3RlclBhc3N3b3JkIH0pID0+IHtcclxuICAgIGlmICghc2hvdWxkRW5jcnlwdCkgcmV0dXJuIHRleHRcclxuICAgIGNvbnN0IHJhdyA9IGFlc0RlY3J5cHQodGV4dC5yZXBsYWNlKENJUEhFUl9QUkVGSVhfUkVHLCAnJyksIG1hc3RlclBhc3N3b3JkKVxyXG4gICAgaWYgKHJhdy5pbmRleE9mKFJBV19QUkVGSVgpICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG1hc3RlciBwYXNzd29yZCcpXHJcbiAgICByZXR1cm4gcmF3LnJlcGxhY2UoUkFXX1BSRUZJWF9SRUcsICcnKVxyXG4gIH0pXHJcbiAgLmNhdGNoKGUgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZCBzdHJpbmcgaW52YWxpZCcpXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGVuY3J5cHRJZk5lZWRlZCA9ICh0ZXh0LCBkb20pID0+IHtcclxuICBpZiAoZG9tICYmIGRvbS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTlBVVCcgJiYgZG9tLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcclxuICAgIHJldHVybiBlbmNyeXB0KHRleHQpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHQpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBkZWNyeXB0SWZOZWVkZWQgPSAodGV4dCwgZG9tKSA9PiB7XHJcbiAgaWYgKENJUEhFUl9QUkVGSVhfUkVHLnRlc3QodGV4dCkgJiYgZG9tICYmIGRvbS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTlBVVCcgJiYgZG9tLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcclxuICAgIHJldHVybiBkZWNyeXB0KHRleHQpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHQpXHJcbn1cclxuIiwiaW1wb3J0IGZzIGZyb20gJy4vZmlsZXN5c3RlbSdcclxuaW1wb3J0IEV4dCBmcm9tICcuL3dlYl9leHRlbnNpb24nXHJcbmltcG9ydCB7IHZhbGlkYXRlU3RhbmRhcmROYW1lLCB3aXRoRmlsZUV4dGVuc2lvbiB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG5jb25zdCByZWFkYWJsZVNpemUgPSAoc2l6ZSkgPT4ge1xyXG4gIGNvbnN0IGtiID0gMTAyNFxyXG4gIGNvbnN0IG1iID0ga2IgKiBrYlxyXG5cclxuICBpZiAoc2l6ZSA8IGtiKSB7XHJcbiAgICByZXR1cm4gc2l6ZSArICcgYnl0ZSdcclxuICB9XHJcblxyXG4gIGlmIChzaXplIDwgbWIpIHtcclxuICAgIHJldHVybiAoc2l6ZSAvIGtiKS50b0ZpeGVkKDEpICsgJyBLQidcclxuICB9XHJcblxyXG4gIHJldHVybiAoc2l6ZSAvIG1iKS50b0ZpeGVkKDEpICsgJyBNQidcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZU1hbiB7XHJcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBiYXNlRGlyID0gJ3NoYXJlJyB9ID0gb3B0c1xyXG5cclxuICAgIGlmICghYmFzZURpciB8fCBiYXNlRGlyID09PSAnLycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhc2VEaXIsICR7YmFzZURpcn1gKVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYmFzZURpciA9IGJhc2VEaXJcclxuXHJcbiAgICAvLyBOb3RlOiBjcmVhdGUgdGhlIGZvbGRlciBpbiB3aGljaCB3ZSB3aWxsIHN0b3JlIGNzdiBmaWxlc1xyXG4gICAgZnMuZ2V0RGlyZWN0b3J5KGJhc2VEaXIsIHRydWUpXHJcbiAgfVxyXG5cclxuICBjaGVja0ZpbGVOYW1lIChmaWxlTmFtZSkge1xyXG4gICAgd2l0aEZpbGVFeHRlbnNpb24oZmlsZU5hbWUsIChiYXNlTmFtZSkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RhbmRhcmROYW1lKGJhc2VOYW1lLCB0cnVlKVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbGUgbmFtZSAnJHtmaWxlTmFtZX0nLiBGaWxlIG5hbWUgYCArIGUubWVzc2FnZSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZU5hbWVcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBnZXRMaW5rIChmaWxlTmFtZSkge1xyXG4gICAgY29uc3QgdG1wID0gRXh0LmV4dGVuc2lvbi5nZXRVUkwoJ3RlbXBvcmFyeScpXHJcbiAgICByZXR1cm4gYGZpbGVzeXN0ZW06JHt0bXB9LyR7dGhpcy5fX2ZpbGVQYXRoKGVuY29kZVVSSUNvbXBvbmVudChmaWxlTmFtZSkpfWBcclxuICB9XHJcblxyXG4gIGxpc3QgKCkge1xyXG4gICAgcmV0dXJuIGZzLmxpc3QodGhpcy5iYXNlRGlyKVxyXG4gICAgLnRoZW4oZmlsZUVudHJpZXMgPT4ge1xyXG4gICAgICBjb25zdCBwcyA9IGZpbGVFbnRyaWVzLm1hcChmaWxlRW50cnkgPT4ge1xyXG4gICAgICAgIHJldHVybiBmcy5nZXRNZXRhZGF0YShmaWxlRW50cnkpXHJcbiAgICAgICAgLnRoZW4obWV0YSA9PiAoe1xyXG4gICAgICAgICAgZGlyOiB0aGlzLmJhc2VEaXIsXHJcbiAgICAgICAgICBmaWxlTmFtZTogZmlsZUVudHJ5Lm5hbWUsXHJcbiAgICAgICAgICBzaXplOiByZWFkYWJsZVNpemUobWV0YS5zaXplKSxcclxuICAgICAgICAgIGxhc3RNb2RpZmllZDogbWV0YS5tb2RpZmljYXRpb25UaW1lXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcylcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBleGlzdHMgKGZpbGVOYW1lKSB7XHJcbiAgICByZXR1cm4gZnMuZXhpc3RzKHRoaXMuX19maWxlUGF0aChmaWxlTmFtZSksIHsgdHlwZTogJ2ZpbGUnIH0pXHJcbiAgfVxyXG5cclxuICByZWFkIChmaWxlTmFtZSkge1xyXG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlKHRoaXMuX19maWxlUGF0aChmaWxlTmFtZSksICdUZXh0JylcclxuICB9XHJcblxyXG4gIHdyaXRlIChmaWxlTmFtZSwgdGV4dCkge1xyXG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZSh0aGlzLl9fZmlsZVBhdGgoZmlsZU5hbWUsIHRydWUpLCBuZXcgQmxvYihbdGV4dF0pKVxyXG4gIH1cclxuXHJcbiAgLy8gTm90ZTogd2hlbiB5b3UgdHJ5IHRvIHdyaXRlIG9uIGFuIGV4aXN0aW5nIGZpbGUgd2l0aCBmaWxlIHN5c3RlbSBhcGksXHJcbiAgLy8gaXQgd29uJ3QgY2xlYXIgb2xkIGNvbnRlbnQsIHNvIHdlIGhhdmUgdG8gZG8gaXQgbWFubnVhbGx5XHJcbiAgb3ZlcndyaXRlIChmaWxlTmFtZSwgdGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlKGZpbGVOYW1lKS5jYXRjaCgoKSA9PiB7IC8qIElnbm9yZSBhbnkgZXJyb3IgKi8gfSlcclxuICAgIC50aGVuKCgpID0+IHRoaXMud3JpdGUoZmlsZU5hbWUsIHRleHQpKVxyXG4gIH1cclxuXHJcbiAgY2xlYXIgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubGlzdCgpXHJcbiAgICAudGhlbihsaXN0ID0+IHtcclxuICAgICAgY29uc3QgcHMgPSBsaXN0Lm1hcChmaWxlID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoZmlsZS5maWxlTmFtZSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcylcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICByZW1vdmUgKGZpbGVOYW1lKSB7XHJcbiAgICByZXR1cm4gZnMucmVtb3ZlRmlsZSh0aGlzLl9fZmlsZVBhdGgoZmlsZU5hbWUpKVxyXG4gIH1cclxuXHJcbiAgcmVuYW1lIChmaWxlTmFtZSwgbmV3TmFtZSkge1xyXG4gICAgcmV0dXJuIGZzLm1vdmVGaWxlKHRoaXMuX19maWxlUGF0aChmaWxlTmFtZSksIHRoaXMuX19maWxlUGF0aChuZXdOYW1lLCB0cnVlKSlcclxuICB9XHJcblxyXG4gIG1ldGFkYXRhIChmaWxlTmFtZSkge1xyXG4gICAgcmV0dXJuIGZzLmdldE1ldGFkYXRhKHRoaXMuX19maWxlUGF0aChmaWxlTmFtZSkpXHJcbiAgfVxyXG5cclxuICBfX2ZpbGVQYXRoIChmaWxlTmFtZSwgZm9yY2VDaGVjaykge1xyXG4gICAgaWYgKGZvcmNlQ2hlY2spIHtcclxuICAgICAgdGhpcy5jaGVja0ZpbGVOYW1lKGZpbGVOYW1lKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmJhc2VEaXIgKyAnLycgKyBmaWxlTmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCAnaWRiLmZpbGVzeXN0ZW0uanMnXHJcblxyXG5jb25zdCBmcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3QgcmVxdWVzdEZpbGVTeXN0ZW0gPSB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gfHwgd2luZG93LndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtXHJcblxyXG4gIGlmICghcmVxdWVzdEZpbGVTeXN0ZW0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWVzdEZpbGVTeXN0ZW0gbm90IHN1cHBvcnRlZCcpXHJcbiAgfVxyXG5cclxuICBjb25zdCBkdW1iU2l6ZSAgPSAxMDI0ICogMTAyNFxyXG4gIGNvbnN0IG1heFNpemUgICA9IDUgKiAxMDI0ICogMTAyNFxyXG4gIGNvbnN0IGdldEZTID0gKHNpemUpID0+IHtcclxuICAgIHNpemUgPSBzaXplIHx8IG1heFNpemVcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICByZXF1ZXN0RmlsZVN5c3RlbSh3aW5kb3cuVEVNUE9SQVJZLCBzaXplLCByZXNvbHZlLCByZWplY3QpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZ2V0RGlyZWN0b3J5ID0gKGRpciwgc2hvdWxkQ3JlYXRlLCBmcykgPT4ge1xyXG4gICAgY29uc3QgcGFydHMgICA9IChBcnJheS5pc0FycmF5KGRpcikgPyBkaXIgOiBkaXIuc3BsaXQoJy8nKSkuZmlsdGVyKHAgPT4gcCAmJiBwLmxlbmd0aClcclxuICAgIGNvbnN0IGdldERpciAgPSAocGFydHMsIGRpcmVjdG9yeUVudHJ5KSA9PiB7XHJcbiAgICAgIGlmICghcGFydHMgfHwgIXBhcnRzLmxlbmd0aCkgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGlyZWN0b3J5RW50cnkpXHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGRpcmVjdG9yeUVudHJ5LmdldERpcmVjdG9yeShcclxuICAgICAgICAgIHBhcnRzWzBdLFxyXG4gICAgICAgICAgeyBjcmVhdGU6ICEhc2hvdWxkQ3JlYXRlIH0sXHJcbiAgICAgICAgICAoZGlyRW50cnkpID0+IHJlc29sdmUoZGlyRW50cnkpLFxyXG4gICAgICAgICAgKGUpID0+IHJlamVjdChlKVxyXG4gICAgICAgIClcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4oZW50cnkgPT4gZ2V0RGlyKHBhcnRzLnNsaWNlKDEpLCBlbnRyeSkpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcEZTID0gZnMgPyBQcm9taXNlLnJlc29sdmUoZnMpIDogZ2V0RlMoZHVtYlNpemUpXHJcbiAgICByZXR1cm4gcEZTLnRoZW4oZnMgPT4gZ2V0RGlyKHBhcnRzLCBmcy5yb290KSlcclxuICB9XHJcblxyXG4gIC8vIEByZXR1cm4gYSBQcm9taXNlIG9mIFtGaWxlU3lzdGVtRW50cmllc11cclxuICBjb25zdCBsaXN0ID0gKGRpciA9ICcvJykgPT4ge1xyXG4gICAgcmV0dXJuIGdldEZTKGR1bWJTaXplKVxyXG4gICAgLnRoZW4oZnMgPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGdldERpcmVjdG9yeShkaXIpLnRoZW4oZGlyRW50cnkgPT4ge1xyXG4gICAgICAgICAgbGV0IHJlc3VsdCAgICAgID0gW11cclxuICAgICAgICAgIGNvbnN0IGRpclJlYWRlciA9IGRpckVudHJ5LmNyZWF0ZVJlYWRlcigpXHJcbiAgICAgICAgICBjb25zdCByZWFkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBkaXJSZWFkZXIucmVhZEVudHJpZXMoZW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5zb3J0KCkpXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoQXJyYXkuZnJvbShlbnRyaWVzKSlcclxuICAgICAgICAgICAgICAgIHJlYWQoKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcmVqZWN0KVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlYWQoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKHJlamVjdClcclxuICAgICAgfSlcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBjb25zdCBmaWxlTG9jYXRvciA9IChmaWxlUGF0aCwgZnMpID0+IHtcclxuICAgIGNvbnN0IHBhcnRzID0gZmlsZVBhdGguc3BsaXQoJy8nKVxyXG4gICAgcmV0dXJuIGdldERpcmVjdG9yeShwYXJ0cy5zbGljZSgwLCAtMSksIGZhbHNlLCBmcylcclxuICAgIC50aGVuKGRpcmVjdG9yeUVudHJ5ID0+ICh7XHJcbiAgICAgIGRpcmVjdG9yeUVudHJ5LFxyXG4gICAgICBmaWxlTmFtZTogcGFydHMuc2xpY2UoLTEpWzBdXHJcbiAgICB9KSlcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlYWRGaWxlID0gKGZpbGVQYXRoLCB0eXBlKSA9PiB7XHJcbiAgICBpZiAoWydBcnJheUJ1ZmZlcicsICdCaW5hcnlTdHJpbmcnLCAnRGF0YVVSTCcsICdUZXh0J10uaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHJlYWRGaWxlIHR5cGUsICcke3R5cGV9J2ApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdldEZTKClcclxuICAgIC50aGVuKGZzID0+IHtcclxuICAgICAgcmV0dXJuIGZpbGVMb2NhdG9yKGZpbGVQYXRoLCBmcylcclxuICAgICAgLnRoZW4oKHsgZGlyZWN0b3J5RW50cnksIGZpbGVOYW1lIH0pID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RmlsZShmaWxlTmFtZSwge30sIChmaWxlRW50cnkpID0+IHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5LmZpbGUoZmlsZSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxyXG5cclxuICAgICAgICAgICAgICByZWFkZXIub25lcnJvciAgICA9IHJlamVjdFxyXG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3VsdClcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyYXlCdWZmZXInOiAgIHJldHVybiByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSlcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0JpbmFyeVN0cmluZyc6ICByZXR1cm4gcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhmaWxlKVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnRGF0YVVSTCc6ICAgICAgIHJldHVybiByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnVGV4dCc6ICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlLCAnJHt0eXBlfWApXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCByZWplY3QpXHJcbiAgICAgICAgICB9LCByZWplY3QpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBjb25zdCB3cml0ZUZpbGUgPSAoZmlsZVBhdGgsIGJsb2IsIHNpemUpID0+IHtcclxuICAgIHJldHVybiBnZXRGUyhzaXplKVxyXG4gICAgLnRoZW4oZnMgPT4ge1xyXG4gICAgICByZXR1cm4gZmlsZUxvY2F0b3IoZmlsZVBhdGgsIGZzKVxyXG4gICAgICAudGhlbigoeyBkaXJlY3RvcnlFbnRyeSwgZmlsZU5hbWUgfSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICBkaXJlY3RvcnlFbnRyeS5nZXRGaWxlKGZpbGVOYW1lLCB7IGNyZWF0ZTogdHJ1ZSB9LCAoZmlsZUVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGZpbGVFbnRyeS5jcmVhdGVXcml0ZXIoZmlsZVdyaXRlciA9PiB7XHJcbiAgICAgICAgICAgICAgZmlsZVdyaXRlci5vbndyaXRlZW5kID0gKCkgPT4gcmVzb2x2ZShmaWxlRW50cnkudG9VUkwoKSlcclxuICAgICAgICAgICAgICBmaWxlV3JpdGVyLm9uZXJyb3IgICAgPSByZWplY3RcclxuXHJcbiAgICAgICAgICAgICAgZmlsZVdyaXRlci53cml0ZShibG9iKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfSwgcmVqZWN0KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVtb3ZlRmlsZSA9IChmaWxlUGF0aCkgPT4ge1xyXG4gICAgcmV0dXJuIGdldEZTKClcclxuICAgIC50aGVuKGZzID0+IHtcclxuICAgICAgcmV0dXJuIGZpbGVMb2NhdG9yKGZpbGVQYXRoLCBmcylcclxuICAgICAgLnRoZW4oKHsgZGlyZWN0b3J5RW50cnksIGZpbGVOYW1lIH0pID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RmlsZShmaWxlTmFtZSwgeyBjcmVhdGU6IHRydWUgfSwgKGZpbGVFbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkucmVtb3ZlKHJlc29sdmUsIHJlamVjdClcclxuICAgICAgICAgIH0sIHJlamVjdClcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGNvbnN0IG1vdmVGaWxlID0gKHNyY1BhdGgsIHRhcmdldFBhdGgpID0+IHtcclxuICAgIHJldHVybiBnZXRGUygpXHJcbiAgICAudGhlbihmcyA9PiB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgZmlsZUxvY2F0b3Ioc3JjUGF0aCwgZnMpLFxyXG4gICAgICAgIGZpbGVMb2NhdG9yKHRhcmdldFBhdGgsIGZzKVxyXG4gICAgICBdKVxyXG4gICAgICAudGhlbih0dXBsZSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3JjRGlyRW50cnkgPSB0dXBsZVswXS5kaXJlY3RvcnlFbnRyeVxyXG4gICAgICAgIGNvbnN0IHNyY0ZpbGVOYW1lID0gdHVwbGVbMF0uZmlsZU5hbWVcclxuICAgICAgICBjb25zdCB0Z3REaXJFbnRyeSA9IHR1cGxlWzFdLmRpcmVjdG9yeUVudHJ5XHJcbiAgICAgICAgY29uc3QgdGd0RmlsZU5hbWUgPSB0dXBsZVsxXS5maWxlTmFtZVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgc3JjRGlyRW50cnkuZ2V0RmlsZShzcmNGaWxlTmFtZSwge30sIChmaWxlRW50cnkpID0+IHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5Lm1vdmVUbyh0Z3REaXJFbnRyeSwgdGd0RmlsZU5hbWUsIHJlc29sdmUsIHJlamVjdClcclxuICAgICAgICAgIH0sIHJlamVjdClcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGdldE1ldGFkYXRhID0gKGZpbGVQYXRoKSA9PiB7XHJcbiAgICByZXR1cm4gZ2V0RlMoKVxyXG4gICAgLnRoZW4oZnMgPT4ge1xyXG4gICAgICBpZiAoZmlsZVBhdGguZ2V0TWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbGVQYXRoLmdldE1ldGFkYXRhKHJlc29sdmUpXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZpbGVMb2NhdG9yKGZpbGVQYXRoLCBmcylcclxuICAgICAgLnRoZW4oKHsgZGlyZWN0b3J5RW50cnksIGZpbGVOYW1lIH0pID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RmlsZShmaWxlTmFtZSwgeyBjcmVhdGU6IHRydWUgfSwgKGZpbGVFbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkuZ2V0TWV0YWRhdGEocmVzb2x2ZSlcclxuICAgICAgICAgIH0sIHJlamVjdClcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGV4aXN0cyA9IChmaWxlUGF0aCwgeyB0eXBlIH0gPSB7fSkgPT4ge1xyXG4gICAgcmV0dXJuIGdldEZTKClcclxuICAgIC50aGVuKGZzID0+IHtcclxuICAgICAgcmV0dXJuIGZpbGVMb2NhdG9yKGZpbGVQYXRoLCBmcylcclxuICAgICAgLnRoZW4oKHsgZGlyZWN0b3J5RW50cnksIGZpbGVOYW1lIH0pID0+IHtcclxuICAgICAgICBjb25zdCBpc1NvbWVFbnRyeSA9IChnZXRNZXRob2ROYW1lKSA9PiAge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGRpcmVjdG9yeUVudHJ5W2dldE1ldGhvZE5hbWVdKFxyXG4gICAgICAgICAgICAgIGZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgIHsgY3JlYXRlOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAgICgpID0+IHJlc29sdmUodHJ1ZSksXHJcbiAgICAgICAgICAgICAgKCkgPT4gcmVzb2x2ZShmYWxzZSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBJc0ZpbGUgPSBpc1NvbWVFbnRyeSgnZ2V0RmlsZScpXHJcbiAgICAgICAgY29uc3QgcElzRGlyICA9IGlzU29tZUVudHJ5KCdnZXREaXJlY3RvcnknKVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3BJc0ZpbGUsIHBJc0Rpcl0pXHJcbiAgICAgICAgLnRoZW4oKFtpc0ZpbGUsIGlzRGlyXSkgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOiAgICAgICAgcmV0dXJuIGlzRmlsZVxyXG4gICAgICAgICAgICBjYXNlICdkaXJlY3RvcnknOiAgIHJldHVybiBpc0RpclxyXG4gICAgICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgIHJldHVybiBpc0ZpbGUgfHwgaXNEaXJcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBsaXN0LFxyXG4gICAgcmVhZEZpbGUsXHJcbiAgICB3cml0ZUZpbGUsXHJcbiAgICByZW1vdmVGaWxlLFxyXG4gICAgbW92ZUZpbGUsXHJcbiAgICBnZXREaXJlY3RvcnksXHJcbiAgICBnZXRNZXRhZGF0YSxcclxuICAgIGV4aXN0c1xyXG4gIH1cclxufSkoKVxyXG5cclxuLy8gRm9yIHRlc3Qgb25seVxyXG53aW5kb3cuZnMgPSBmc1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnNcclxuIiwiXHJcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2cnXHJcbmltcG9ydCB7IGdldEVsZW1lbnRCeUxvY2F0b3IgfSBmcm9tICcuL2NvbW1hbmRfcnVubmVyJ1xyXG5cclxuLypcclxuICogQmFzaWMgdG9vbCBmdW5jdGlvblxyXG4gKi9cclxuXHJcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cylcclxuICB2YXIgbGVuICA9IGFyZ3MubGVuZ3RoXHJcblxyXG4gIGlmIChsZW4gPD0gMCkgICByZXR1cm4ge31cclxuICBpZiAobGVuID09PSAxKSAgcmV0dXJuIGFyZ3NbMF1cclxuXHJcbiAgdmFyIGhlYWQgPSBhcmdzWzBdXHJcbiAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKDEpXHJcblxyXG4gIHJldHVybiByZXN0LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGN1ciksIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgcHJldltrZXlzW2ldXSA9IGN1cltrZXlzW2ldXVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcmV2XHJcbiAgfSwgaGVhZClcclxufVxyXG5cclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5XHJcblxyXG52YXIgaWQgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfVxyXG5cclxudmFyIHRyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJylcclxufVxyXG5cclxudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAobGlzdCkge1xyXG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGxpc3QpXHJcbn1cclxuXHJcbnZhciBzdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGxpc3QgPSBBcnJheS5mcm9tKGFyZ3VtZW50cylcclxuICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xyXG4gICAgcmV0dXJuIHByZXYgKyBjdXJcclxuICB9LCAwKVxyXG59XHJcblxyXG52YXIgbGFzdCA9IGZ1bmN0aW9uIChsaXN0KSB7XHJcbiAgcmV0dXJuIGxpc3RbbGlzdC5sZW5ndGggLSAxXVxyXG59XHJcblxyXG52YXIgb3IgPSBmdW5jdGlvbiAobGlzdCkge1xyXG4gIHJldHVybiAobGlzdCB8fCBbXSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcclxuICAgIHJldHVybiBwcmV2IHx8IGN1clxyXG4gIH0sIGZhbHNlKVxyXG59XHJcblxyXG52YXIgYW5kID0gZnVuY3Rpb24gKGxpc3QpIHtcclxuICByZXR1cm4gKGxpc3QgfHwgW10pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XHJcbiAgICByZXR1cm4gcHJldiAmJiBjdXJcclxuICB9LCB0cnVlKVxyXG59XHJcblxyXG52YXIgemlwV2l0aCA9IGZ1bmN0aW9uIChmbikge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgICByZXR1cm4gbnVsbFxyXG5cclxuICB2YXIgbGlzdCA9IEFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgxKVxyXG4gIHZhciBsZW4gID0gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgY3VyKSB7XHJcbiAgICByZXR1cm4gY3VyLmxlbmd0aCA8IG1pbiA/IGN1ci5sZW5ndGggOiBtaW5cclxuICB9LCBJbmZpbml0eSlcclxuICB2YXIgcmV0ICA9IFtdXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHJldC5wdXNoKGZuLmFwcGx5KG51bGwsIGxpc3QubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtW2ldOyB9KSkpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbnZhciBpbnRlcnNlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGxpc3QgPSBBcnJheS5mcm9tKGFyZ3VtZW50cylcclxuICB2YXIgbGVuICA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGxpc3QubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmxlbmd0aDsgfSkpXHJcbiAgdmFyIHJlc3VsdCA9IFtdXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHZhciB2YWwgPSBsaXN0WzBdW2ldXHJcbiAgICB2YXIgbm8gID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIGl0ZW1baV0gIT09IHZhbFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAobm8gJiYgbm8ubGVuZ3RoKSAgYnJlYWtcclxuXHJcbiAgICByZXN1bHQucHVzaCh2YWwpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbnZhciBkZWVwRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHtcclxuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYW5kKHppcFdpdGgoZGVlcEVxdWFsLCBhLCBiKSlcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBUT0RPXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIHJldHVybiBhID09PSBiXHJcbn1cclxuXHJcbi8qXHJcbiAqIERvbSBoZWxwZXIgZnVuY3Rpb25cclxuICovXHJcblxyXG52YXIgcGl4ZWwgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgaWYgKChudW0gKyAnJykuaW5kZXhPZigncHgnKSAhPT0gLTEpICByZXR1cm4gbnVtXHJcbiAgcmV0dXJuIChudW0gfHwgMCkgKyAncHgnXHJcbn1cclxuXHJcbnZhciBnZXRTdHlsZSA9IGZ1bmN0aW9uIChkb20sIHN0eWxlTmFtZSkge1xyXG4gIGlmICghZG9tKSAgIHRocm93IG5ldyBFcnJvcignZ2V0U3R5bGU6IGRvbSBkb2VzIG5vdCBleGlzdCcpXHJcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZG9tKVtzdHlsZU5hbWVdXHJcbn1cclxuXHJcbnZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uIChkb20sIHN0eWxlKSB7XHJcbiAgaWYgKCFkb20pICAgdGhyb3cgbmV3IEVycm9yKCdzZXRTdHlsZTogZG9tIGRvZXMgbm90IGV4aXN0JylcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZSksIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGRvbS5zdHlsZVtrZXlzW2ldXSA9IHN0eWxlW2tleXNbaV1dXHJcbiAgfVxyXG5cclxuICByZXR1cm4gZG9tXHJcbn1cclxuXHJcbnZhciBjc3NTdW0gPSBmdW5jdGlvbiAoZG9tLCBsaXN0KSB7XHJcbiAgdmFyIGlzSW5saW5lID0gZ2V0U3R5bGUoZG9tLCAnZGlzcGxheScpID09PSAnaW5saW5lJ1xyXG5cclxuICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xyXG4gICAgdmFyIHZhbCA9IChpc0lubGluZSAmJiBbJ3dpZHRoJywgJ2hlaWdodCddLmluZGV4T2YoY3VyKSAhPT0gLTEpXHJcbiAgICAgICAgICA/IGRvbS5nZXRDbGllbnRSZWN0cygpWzBdW2N1cl1cclxuICAgICAgICAgIDogZ2V0U3R5bGUoZG9tLCBjdXIpXHJcblxyXG4gICAgcmV0dXJuIHByZXYgKyBwYXJzZUludCh2YWwgfHwgJzAnLCAxMClcclxuICB9LCAwKVxyXG59XHJcblxyXG52YXIgb2Zmc2V0ID0gZnVuY3Rpb24gKGRvbSwgbm9QeCkge1xyXG4gIGlmICghZG9tKSByZXR1cm4geyBsZWZ0OiAwLCB0b3A6IDAgfVxyXG5cclxuICB2YXIgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gIHZhciBmbiAgID0gbm9QeCA/IGlkIDogcGl4ZWxcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGxlZnQ6IGZuKHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYKSxcclxuICAgIHRvcDogZm4ocmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSlcclxuICB9XHJcbn1cclxuXHJcbnZhciByZWN0ID0gZnVuY3Rpb24gKGRvbSwgbm9QeCkge1xyXG4gIHZhciBwb3MgICAgICAgPSBvZmZzZXQoZG9tLCBub1B4KVxyXG4gIHZhciBpc0lubGluZSAgPSBnZXRTdHlsZShkb20sICdkaXNwbGF5JykgPT09ICdpbmxpbmUnXHJcbiAgdmFyIHcgICAgICAgICA9IGlzSW5saW5lID8gZG9tLmdldENsaWVudFJlY3RzKClbMF1bJ3dpZHRoJ10gIDogZ2V0U3R5bGUoZG9tLCAnd2lkdGgnKVxyXG4gIHZhciBoICAgICAgICAgPSBpc0lubGluZSA/IGRvbS5nZXRDbGllbnRSZWN0cygpWzBdWydoZWlnaHQnXSA6IGdldFN0eWxlKGRvbSwgJ2hlaWdodCcpXHJcbiAgdmFyIGZuICAgICAgICA9IG5vUHggPyBpZCA6IHBpeGVsXHJcblxyXG4gIHJldHVybiBleHRlbmQoe3dpZHRoOiBmbih3KSwgaGVpZ2h0OiBmbihoKX0sIHBvcylcclxufVxyXG5cclxuLy8gUmVmZXJlbmNlOiBodHRwOi8vcnlhbnZlLmNvbS9sYWIvZGltZW5zaW9ucy9cclxudmFyIGNsaWVudFdpZHRoID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxyXG59XHJcblxyXG52YXIgY2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcclxufVxyXG5cclxudmFyIHJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKGRvbSwgcHJlZGljYXRlKSB7XHJcbiAgdmFyIHByZWQgPSBwcmVkaWNhdGUgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9XHJcbiAgdmFyIGNoaWxkcmVuID0gZG9tLmNoaWxkTm9kZXNcclxuXHJcbiAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBpZiAocHJlZChjaGlsZHJlbltpXSkpIHtcclxuICAgICAgZG9tLnJlbW92ZUNoaWxkKGNoaWxkcmVuW2ldKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIGluRG9tID0gZnVuY3Rpb24gKCRvdXRlciwgJGVsKSB7XHJcbiAgaWYgKCEkZWwpIHJldHVybiBmYWxzZVxyXG4gIGlmICgkb3V0ZXIgPT09ICRlbCkgIHJldHVybiB0cnVlXHJcbiAgcmV0dXJuIGluRG9tKCRvdXRlciwgJGVsLnBhcmVudE5vZGUpXHJcbn1cclxuXHJcbnZhciBpbkRvbUxpc3QgPSBmdW5jdGlvbiAobGlzdCwgJGVsKSB7XHJcbiAgcmV0dXJuIG9yKGxpc3QubWFwKGZ1bmN0aW9uICgkb3V0ZXIpIHtcclxuICAgIHJldHVybiBpbkRvbSgkb3V0ZXIsICRlbClcclxuICB9KSlcclxufVxyXG5cclxudmFyIHBhcmVudFdpdGhUYWcgPSBmdW5jdGlvbiAodGFnLCAkZWwpIHtcclxuICB2YXIgbG93ZXJUYWcgPSB0YWcudG9Mb3dlckNhc2UoKVxyXG4gIHZhciAkZG9tID0gJGVsXHJcblxyXG4gIHdoaWxlICgkZG9tKSB7XHJcbiAgICBpZiAoJGRvbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyVGFnKSB7XHJcbiAgICAgIHJldHVybiAkZG9tXHJcbiAgICB9XHJcblxyXG4gICAgJGRvbSA9ICRkb20ucGFyZW50Tm9kZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGxcclxufVxyXG5cclxudmFyIHBhcmVudFdpdGhDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsICRlbCkge1xyXG4gIHZhciAkZG9tID0gJGVsXHJcblxyXG4gIHdoaWxlICgkZG9tKSB7XHJcbiAgICAvLyBOb3RlOiBJbiBGaXJlZm94LCBIVE1MIERvY3VtZW50IG9iamVjdCBkb2Vzbid0IGhhdmUgYGNsYXNzTGlzdGAgcHJvcGVydHlcclxuICAgIGlmICgkZG9tLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkICYmICRkb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcclxuICAgICAgcmV0dXJuICRkb21cclxuICAgIH1cclxuXHJcbiAgICAkZG9tID0gJGRvbS5wYXJlbnROb2RlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbFxyXG59XHJcblxyXG52YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiAoZG9tKSB7XHJcbiAgaWYgKGRvbS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuICcnXHJcbiAgaWYgKGRvbS50YWdOYW1lID09PSAnQk9EWScpIHJldHVybiAnYm9keSdcclxuICBpZiAoZG9tLmlkKSByZXR1cm4gJyMnICsgZG9tLmlkXHJcblxyXG4gIHZhciBjbGFzc2VzID0gKGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgvXFxzKy9nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgdmFyIGNoaWxkcmVuID0gQXJyYXkuZnJvbShkb20ucGFyZW50Tm9kZS5jaGlsZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKCRlbCkge1xyXG4gICAgcmV0dXJuICRlbC5ub2RlVHlwZSA9PT0gMVxyXG4gIH0pXHJcblxyXG4gIHZhciBzYW1lVGFnID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICgkZWwpIHtcclxuICAgIHJldHVybiAkZWwudGFnTmFtZSA9PT0gZG9tLnRhZ05hbWVcclxuICB9KVxyXG5cclxuICB2YXIgc2FtZUNsYXNzID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uICgkZWwpIHtcclxuICAgIHZhciBjcyA9ICgkZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgvXFxzKy9nKVxyXG5cclxuICAgIHJldHVybiBhbmQoY2xhc3Nlcy5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgcmV0dXJuIGNzLmluZGV4T2YoYykgIT09IC0xXHJcbiAgICB9KSlcclxuICB9KVxyXG5cclxuICB2YXIgZXh0cmEgPSAnJ1xyXG5cclxuICBpZiAoc2FtZVRhZy5sZW5ndGggPT09IDEpIHtcclxuICAgIGV4dHJhID0gJydcclxuICB9IGVsc2UgaWYgKGNsYXNzZXMubGVuZ3RoICYmIHNhbWVDbGFzcy5sZW5ndGggPT09IDEpIHtcclxuICAgIGV4dHJhID0gJy4nICsgY2xhc3Nlcy5qb2luKCcuJylcclxuICB9IGVsc2Uge1xyXG4gICAgZXh0cmEgPSAnOm50aC1jaGlsZCgnICsgKDEgKyBjaGlsZHJlbi5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gPT09IGRvbTsgfSkpICsgJyknXHJcbiAgfVxyXG5cclxuICB2YXIgbWUgPSBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgZXh0cmFcclxuXHJcbiAgLy8gTm90ZTogYnJvd3NlciB3aWxsIGFkZCBhbiBleHRyYSAndGJvZHknIHdoZW4gdHIgZGlyZWN0bHkgaW4gdGFibGUsIHdoaWNoIHdpbGwgY2F1c2UgYW4gd3Jvbmcgc2VsZWN0b3IsXHJcbiAgLy8gc28gdGhlIGhhY2sgaXMgdG8gcmVtb3ZlIGFsbCB0Ym9keSBoZXJlXHJcbiAgdmFyIHJldCA9IHNlbGVjdG9yKGRvbS5wYXJlbnROb2RlKSArICcgPiAnICsgbWVcclxuICByZXR1cm4gcmV0XHJcbiAgLy8gcmV0dXJuIHJldC5yZXBsYWNlKC9cXHMqPlxccyp0Ym9keVxccyo+Py9nLCAnICcpXHJcbn1cclxuXHJcbnZhciB4cGF0aCA9IGZ1bmN0aW9uIChkb20sIGN1ciwgbGlzdCkge1xyXG4gIHZhciBnZXRUYWdJbmRleCA9IGZ1bmN0aW9uIChkb20pIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKGRvbS5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICByZXR1cm4gaXRlbS5ub2RlVHlwZSA9PT0gZG9tLm5vZGVUeXBlICYmIGl0ZW0udGFnTmFtZSA9PT0gZG9tLnRhZ05hbWVcclxuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbm9kZSwgaSkge1xyXG4gICAgICBpZiAocHJldiAhPT0gbnVsbCkgIHJldHVybiBwcmV2XHJcbiAgICAgIHJldHVybiBub2RlID09PSBkb20gPyAoaSArIDEpIDogcHJldlxyXG4gICAgfSwgbnVsbClcclxuICB9XHJcblxyXG4gIHZhciBuYW1lID0gZnVuY3Rpb24gKGRvbSkge1xyXG4gICAgaWYgKCFkb20pICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PT0gMykgICByZXR1cm4gJ0B0ZXh0J1xyXG5cclxuICAgIHZhciBpbmRleCA9IGdldFRhZ0luZGV4KGRvbSlcclxuICAgIHZhciBjb3VudCA9IEFycmF5LmZyb20oZG9tLnBhcmVudE5vZGUuY2hpbGROb2RlcykuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIHJldHVybiBpdGVtLm5vZGVUeXBlID09PSBkb20ubm9kZVR5cGUgJiYgaXRlbS50YWdOYW1lID09PSBkb20udGFnTmFtZVxyXG4gICAgfSkubGVuZ3RoXHJcbiAgICB2YXIgdGFnICAgPSBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpXHJcblxyXG4gICAgcmV0dXJuIGNvdW50ID4gMSA/ICh0YWcgKyAnWycgKyBpbmRleCArICddJykgOiB0YWdcclxuICB9XHJcblxyXG4gIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoZG9tLCBjdXIsIGxpc3QpIHtcclxuICAgIGlmICghZG9tKSAgIHJldHVybiBudWxsXHJcblxyXG4gICAgaWYgKCFjdXIpIHtcclxuICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiBoZWxwZXIoZG9tLnBhcmVudE5vZGUpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGhlbHBlcihkb20sIGRvbSwgW10pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWN1ci5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHJldHVybiBbJ2h0bWwnXS5jb25jYXQobGlzdClcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VyLnRhZ05hbWUgPT09ICdCT0RZJykge1xyXG4gICAgICByZXR1cm4gWydodG1sJywgJ2JvZHknXS5jb25jYXQobGlzdClcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VyLmlkKSB7XHJcbiAgICAgIHJldHVybiBbYCpbQGlkPVwiJHtjdXIuaWR9XCJdYF0uY29uY2F0KGxpc3QpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhlbHBlcihkb20sIGN1ci5wYXJlbnROb2RlLCBbbmFtZShjdXIpXS5jb25jYXQobGlzdCkpXHJcbiAgfVxyXG5cclxuICB2YXIgcGFydHMgICA9IGhlbHBlcihkb20sIGN1ciwgbGlzdClcclxuICB2YXIgcHJlZml4ICA9IHBhcnRzWzBdID09PSAnaHRtbCcgPyAnLycgOiAnLy8nXHJcbiAgdmFyIHJldCAgICAgPSBwcmVmaXggKyBwYXJ0cy5qb2luKCcvJylcclxuXHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG52YXIgYXRYUGF0aCA9IGZ1bmN0aW9uICh4cGF0aCwgZG9jdW1lbnQpIHtcclxuICB2YXIgbG93ZXIgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIgJiYgc3RyLnRvTG93ZXJDYXNlKCk7IH1cclxuICB2YXIgcmVnICAgPSAvXihbYS16QS1aMC05XSspKFxcWyhcXGQrKVxcXSk/JC9cclxuXHJcbiAgcmV0dXJuIHhwYXRoLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XHJcbiAgICBpZiAoIXByZXYpICByZXR1cm4gcHJldlxyXG4gICAgaWYgKCFwcmV2LmNoaWxkTm9kZXMgfHwgIXByZXYuY2hpbGROb2Rlcy5sZW5ndGgpICByZXR1cm4gbnVsbFxyXG5cclxuICAgIHZhciBtYXRjaCA9IGN1ci5tYXRjaChyZWcpXHJcbiAgICB2YXIgdGFnICAgPSBtYXRjaFsxXVxyXG4gICAgdmFyIGluZGV4ID0gbWF0Y2hbM10gPyBwYXJzZUludChtYXRjaFszXSwgMTApIDogMVxyXG4gICAgdmFyIGxpc3QgID0gQXJyYXkuZnJvbShwcmV2LmNoaWxkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICByZXR1cm4gaXRlbS5ub2RlVHlwZSA9PT0gMSAmJiBsb3dlcihpdGVtLnRhZ05hbWUpID09PSBsb3dlcih0YWcpXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBsaXN0W2luZGV4IC0gMV1cclxuICB9LCBkb2N1bWVudClcclxufVxyXG5cclxudmFyIGRvbVRleHQgPSAoJGRvbSkgPT4ge1xyXG4gIGNvbnN0IGl0ICA9ICRkb20uaW5uZXJUZXh0ICYmICRkb20uaW5uZXJUZXh0LnRyaW0oKVxyXG4gIGNvbnN0IHRjICA9ICRkb20udGV4dENvbnRlbnRcclxuICBjb25zdCBwb3MgPSB0Yy50b1VwcGVyQ2FzZSgpLmluZGV4T2YoaXQudG9VcHBlckNhc2UoKSlcclxuXHJcbiAgcmV0dXJuIHRjLnN1YnN0cihwb3MsIGl0Lmxlbmd0aClcclxufVxyXG5cclxudmFyIGdldEZpcnN0V29ya2luZ0xvY2F0b3IgPSAobG9jYXRvcnMsICRlbCkgPT4ge1xyXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgaWYgKCRlbCA9PT0gZ2V0RWxlbWVudEJ5TG9jYXRvcihsb2NhdG9yc1tpXSkpIHtcclxuICAgICAgcmV0dXJuIGxvY2F0b3JzW2ldXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbFxyXG59XHJcblxyXG4vLyBOb3RlOiBnZXQgdGhlIGxvY2F0b3Igb2YgYSBET01cclxudmFyIGdldExvY2F0b3IgPSAoJGRvbSwgd2l0aEFsbE9wdGlvbnMpID0+IHtcclxuICBjb25zdCBpZCAgICAgID0gJGRvbS5nZXRBdHRyaWJ1dGUoJ2lkJylcclxuICBjb25zdCBuYW1lICAgID0gJGRvbS5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxyXG4gIGNvbnN0IGlzTGluayAgPSAkZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnXHJcbiAgY29uc3QgdGV4dCAgICA9IGRvbVRleHQoJGRvbSlcclxuICBjb25zdCBjbGFzc2VzID0gQXJyYXkuZnJvbSgkZG9tLmNsYXNzTGlzdClcclxuICBjb25zdCBjYW5kaWRhdGVzID0gW11cclxuXHJcbiAgLy8gbGlua1xyXG4gIGlmIChpc0xpbmsgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgY29uc3QgbGlua3MgICA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKSlcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsaW5rcy5maWx0ZXIoJGVsID0+IGRvbVRleHQoJGVsKSA9PT0gdGV4dClcclxuICAgIGNvbnN0IGluZGV4ICAgPSBtYXRjaGVzLmZpbmRJbmRleCgkZWwgPT4gJGVsID09PSAkZG9tKVxyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgY2FuZGlkYXRlcy5wdXNoKFxyXG4gICAgICAgIGluZGV4ID09PSAwID8gYGxpbms9JHt0ZXh0fWAgOiBgbGluaz0ke3RleHR9QFBPUz0ke2luZGV4ICsgMX1gXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGlkXHJcbiAgaWYgKGlkICYmIGlkLmxlbmd0aCkge1xyXG4gICAgY2FuZGlkYXRlcy5wdXNoKGBpZD0ke2lkfWApXHJcbiAgfVxyXG5cclxuICAvLyBuYW1lXHJcbiAgaWYgKG5hbWUgJiYgbmFtZS5sZW5ndGgpIHtcclxuICAgIGNhbmRpZGF0ZXMucHVzaChgbmFtZT0ke25hbWV9YClcclxuICB9XHJcblxyXG4gIC8vIHhwYXRoXHJcbiAgY2FuZGlkYXRlcy5wdXNoKHhwYXRoKCRkb20pKVxyXG5cclxuICAvLyBjc3NcclxuICAvLyBUcnkgd2l0aCBzaW1wbGUgY3NzIHNlbGVjdG9yIGZpcnN0LiBJZiBub3QgdW5xaXVlLCB1c2UgZnVsbCBjc3Mgc2VsZWN0b3JcclxuICAvKipcclxuICAgKiBCZWxvdyBpcyB0aGUgb2xkIGxvZ2ljIHdpdGggYSBzaG9ydGVyIGNzcyBzZWxlY3RvclxyXG4gICAqXHJcblxyXG4gIGxldCBzZWwgPSBudWxsXHJcblxyXG4gIGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgIHNlbCA9ICRkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgY2xhc3Nlcy5tYXAoYyA9PiAnLicgKyBjKS5qb2luKCcnKVxyXG5cclxuICAgIGlmICgkZG9tICE9PSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbClbMF0pIHtcclxuICAgICAgc2VsID0gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFzZWwpIHtcclxuICAgIHNlbCA9IHNlbGVjdG9yKCRkb20pXHJcbiAgfVxyXG4gICovXHJcbiAgY2FuZGlkYXRlcy5wdXNoKGBjc3M9JHtzZWxlY3RvcigkZG9tKX1gKVxyXG5cclxuICAvLyBHZXQgdGhlIGZpcnN0IG9uZSB3b3JraW5nXHJcbiAgY29uc3QgY2hvc2VuID0gZ2V0Rmlyc3RXb3JraW5nTG9jYXRvcihjYW5kaWRhdGVzLCAkZG9tKVxyXG5cclxuICBpZiAod2l0aEFsbE9wdGlvbnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRhcmdldDogY2hvc2VuLFxyXG4gICAgICB0YXJnZXRPcHRpb25zOiBjYW5kaWRhdGVzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2hvc2VuXHJcbn1cclxuXHJcbnZhciBjaGVja0lmcmFtZSA9IChpZnJhbWVXaW4pID0+IHtcclxuICB2YXIga2V5ID0gbmV3IERhdGUoKSAqIDEgKyAnJyArIE1hdGgucmFuZG9tKClcclxuXHJcbiAgdHJ5IHtcclxuICAgIGlmcmFtZVdpbltrZXldID0gJ2FzZCdcclxuICAgIHJldHVybiBpZnJhbWVXaW5ba2V5XSA9PT0gJ2FzZCdcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbi8vIE5vdGU6IGdldCB0aGUgbG9jYXRvciBmb3IgZnJhbWVcclxudmFyIGdldEZyYW1lTG9jYXRvciA9IChmcmFtZVdpbiwgd2luKSA9PiB7XHJcbiAgaWYgKGNoZWNrSWZyYW1lKGZyYW1lV2luKSkge1xyXG4gICAgY29uc3QgZnJhbWVEb20gPSBmcmFtZVdpbi5mcmFtZUVsZW1lbnRcclxuICAgIGNvbnN0IGxvY2F0b3IgID0gZ2V0TG9jYXRvcihmcmFtZURvbSlcclxuXHJcbiAgICBpZiAoL15pZD0vLnRlc3QobG9jYXRvcikgfHwgL15uYW1lPS8udGVzdChsb2NhdG9yKSkge1xyXG4gICAgICByZXR1cm4gbG9jYXRvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHdpbi5mcmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmICh3aW4uZnJhbWVzW2ldID09PSBmcmFtZVdpbikge1xyXG4gICAgICByZXR1cm4gYGluZGV4PSR7aX1gXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lIGxvY2F0b3Igbm90IGZvdW5kJylcclxufVxyXG5cclxuLypcclxuICogTWFzayByZWxhdGVkXHJcbiAqL1xyXG5cclxudmFyIG1hc2tGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjYWNoZSAgICAgICA9IFtdXHJcbiAgdmFyIHByZWZpeCAgICAgID0gJ19fbWFza19fJyArIChuZXcgRGF0ZSgpICogMSkgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArICdfXydcclxuICB2YXIgdWlkICAgICAgICAgPSAxXHJcbiAgdmFyIGRlZmF1bHRTdHlsZSAgPSB7XHJcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgIHpJbmRleDogJzk5OScsXHJcbiAgICBkaXNwbGF5OiAnbm9uZScsXHJcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JlZCcsXHJcbiAgICBvcGFjaXR5OiAwLjUsXHJcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcclxuICB9XHJcblxyXG4gIHZhciBnZW5NYXNrID0gZnVuY3Rpb24gKHN0eWxlLCBkb20pIHtcclxuICAgIHZhciBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuXHJcbiAgICBpZiAoZG9tKSB7XHJcbiAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBkZWZhdWx0U3R5bGUsIHN0eWxlIHx8IHt9LCByZWN0KGRvbSkpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgZGVmYXVsdFN0eWxlLCBzdHlsZSB8fCB7fSlcclxuICAgIH1cclxuXHJcbiAgICBzZXRTdHlsZShtYXNrLCBzdHlsZSlcclxuICAgIG1hc2suaWQgPSBwcmVmaXggKyAodWlkKyspXHJcbiAgICBjYWNoZS5wdXNoKG1hc2spXHJcblxyXG4gICAgcmV0dXJuIG1hc2tcclxuICB9XHJcblxyXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWNoZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB2YXIgbWFzayA9IGNhY2hlW2ldXHJcblxyXG4gICAgICBpZiAobWFzayAmJiBtYXNrLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBtYXNrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobWFzaylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGdlbjogZ2VuTWFzayxcclxuICAgIGNsZWFyOiAgY2xlYXJcclxuICB9XHJcbn1cclxuXHJcbnZhciBzaG93TWFza092ZXIgPSBmdW5jdGlvbiAobWFzaywgZWwpIHtcclxuICB2YXIgcG9zID0gb2Zmc2V0KGVsKVxyXG4gIHZhciB3ICAgPSBjc3NTdW0oZWwsIFsnd2lkdGgnLCAgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdSaWdodCcsICAnYm9yZGVyTGVmdFdpZHRoJywgJ2JvcmRlclJpZ2h0V2lkdGgnXSlcclxuICB2YXIgaCAgID0gY3NzU3VtKGVsLCBbJ2hlaWdodCcsICdwYWRkaW5nVG9wJywgICdwYWRkaW5nQm90dG9tJywgJ2JvcmRlclRvcFdpZHRoJywgJyBib3JkZXJCb3R0b21XaWR0aCddKVxyXG5cclxuICBzZXRTdHlsZShtYXNrLCBleHRlbmQocG9zLCB7XHJcbiAgICB3aWR0aDogcGl4ZWwodyksXHJcbiAgICBoZWlnaHQ6IHBpeGVsKGgpLFxyXG4gICAgZGlzcGxheTogJ2Jsb2NrJ1xyXG4gIH0pKVxyXG59XHJcblxyXG52YXIgaXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgaWYgKGVsID09PSB3aW5kb3cuZG9jdW1lbnQpIHJldHVybiB0cnVlXHJcbiAgaWYgKCFlbCkgIHJldHVybiB0cnVlXHJcblxyXG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXHJcbiAgaWYgKHN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCBzdHlsZS5vcGFjaXR5ID09PSAnMCcgfHwgc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpICByZXR1cm4gZmFsc2VcclxuXHJcbiAgcmV0dXJuIGlzVmlzaWJsZShlbC5wYXJlbnROb2RlKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgb2Zmc2V0LFxyXG4gIHNldFN0eWxlLFxyXG4gIHNlbGVjdG9yLFxyXG4gIHhwYXRoLFxyXG4gIGF0WFBhdGgsXHJcbiAgZG9tVGV4dCxcclxuICBnZXRMb2NhdG9yLFxyXG4gIGdldEZyYW1lTG9jYXRvcixcclxuICBtYXNrRmFjdG9yeSxcclxuICBzaG93TWFza092ZXIsXHJcbiAgaW5Eb20sXHJcbiAgaXNWaXNpYmxlLFxyXG4gIHBhcmVudFdpdGhUYWcsXHJcbiAgcGFyZW50V2l0aENsYXNzXHJcbn1cclxuIiwiXHJcbmNvbnN0IFRZUEUgPSAnU0VMRU5JVU1fSURFX0NTX01TRydcclxuXHJcbmV4cG9ydCBjb25zdCBwb3N0TWVzc2FnZSA9ICh0YXJnZXRXaW4sIG15V2luLCBwYXlsb2FkLCB0YXJnZXQgPSAnKicsIHRpbWVvdXQgPSA2MDAwMCkgPT4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBpZiAoIXRhcmdldFdpbiB8fCAhdGFyZ2V0V2luLnBvc3RNZXNzYWdlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3NQb3N0TWVzc2FnZTogdGFyZ2V0V2luIGlzIG5vdCBhIHdpbmRvdycsIHRhcmdldFdpbilcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW15V2luIHx8ICFteVdpbi5hZGRFdmVudExpc3RlbmVyIHx8ICFteVdpbi5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3NQb3N0TWVzc2FnZTogbXlXaW4gaXMgbm90IGEgd2luZG93JywgbXlXaW4pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VjcmV0ICA9IE1hdGgucmFuZG9tKClcclxuICAgIGNvbnN0IHR5cGUgICAgPSBUWVBFXHJcblxyXG4gICAgLy8gTm90ZTogY3JlYXRlIGEgbGlzdGVuZXIgd2l0aCBhIGNvcnJlc3BvbmRpbmcgc2VjcmV0IGV2ZXJ5IHRpbWVcclxuICAgIGNvbnN0IG9uTXNnICAgPSAoZSkgPT4ge1xyXG4gICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS50eXBlID09PSBUWVBFICYmICFlLmRhdGEuaXNSZXF1ZXN0ICYmIGUuZGF0YS5zZWNyZXQgPT09IHNlY3JldCkge1xyXG4gICAgICAgIG15V2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1zZylcclxuICAgICAgICBjb25zdCB7IHBheWxvYWQsIGVycm9yIH0gPSBlLmRhdGFcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGVycm9yKSlcclxuICAgICAgICBpZiAocGF5bG9hZCAhPT0gdW5kZWZpbmVkKSAgcmV0dXJuIHJlc29sdmUocGF5bG9hZClcclxuXHJcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignY3NQb3N0TWVzc2FnZTogTm8gcGF5bG9hZCBub3IgZXJyb3IgZm91bmQnKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG15V2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1zZylcclxuXHJcbiAgICAvLyBOb3RlOlxyXG4gICAgLy8gKiBgdHlwZWAgdG8gbWFrZSBzdXJlIHdlIGNoZWNrIG91ciBvd24gbXNnIG9ubHlcclxuICAgIC8vICogYHNlY3JldGAgaXMgZm9yIDEgdG8gMSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIG1zZyBhbmQgYSBsaXN0ZW5lclxyXG4gICAgLy8gKiBgcGF5bG9hZGAgaXMgdGhlIHJlYWwgZGF0YSB5b3Ugd2FudCB0byBzZW5kXHJcbiAgICAvLyAqIGBpc1JlcXVlc3RgIGlzIHRvIG1hcmsgdGhhdCBpdCdzIG5vdCBhbiBhbnN3ZXIgdG8gc29tZSBwcmV2aW91cyByZXF1ZXN0XHJcbiAgICB0YXJnZXRXaW4ucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICB0eXBlLFxyXG4gICAgICBzZWNyZXQsXHJcbiAgICAgIHBheWxvYWQsXHJcbiAgICAgIGlzUmVxdWVzdDogdHJ1ZVxyXG4gICAgfSwgdGFyZ2V0KVxyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICByZWplY3QobmV3IEVycm9yKGBjc1Bvc3RNZXNzYWdlOiB0aW1lb3V0ICR7dGltZW91dH0gbXNgKSlcclxuICAgIH0sIHRpbWVvdXQpXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG9uTWVzc2FnZSA9ICh3aW4sIGZuKSA9PiB7XHJcbiAgaWYgKCF3aW4gfHwgIXdpbi5hZGRFdmVudExpc3RlbmVyIHx8ICF3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjc09uTWVzc2FnZTogbm90IGEgd2luZG93Jywgd2luKVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgb25Nc2cgPSAoZSkgPT4ge1xyXG4gICAgLy8gTm90ZTogb25seSByZXNwb25kIHRvIG1zZyB3aXRoIGBpc1JlcXVlc3RgIGFzIHRydWVcclxuICAgIGlmIChlICYmIGUuZGF0YSAmJiBlLmRhdGEudHlwZSA9PT0gVFlQRSAmJiBlLmRhdGEuaXNSZXF1ZXN0ICYmIGUuZGF0YS5zZWNyZXQpIHtcclxuICAgICAgY29uc3QgdHBsID0ge1xyXG4gICAgICAgIHR5cGU6IFRZUEUsXHJcbiAgICAgICAgc2VjcmV0OiBlLmRhdGEuc2VjcmV0XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vdGU6IHdyYXBwZWQgd2l0aCBhIG5ldyBQcm9taXNlIHRvIGNhdGNoIGFueSBleGNlcHRpb24gZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgZm5cclxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCByZXQ7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXQgPSBmbihlLmRhdGEucGF5bG9hZCwge1xyXG4gICAgICAgICAgICBzb3VyY2U6IGUuc291cmNlXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgcmVqZWN0KGVycilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdGU6IG9ubHkgcmVzb2x2ZSBpZiByZXR1cm5lZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLiBXaXRoIHRoaXMsIHdlIGNhbiBoYXZlIG11bHRpcGxlXHJcbiAgICAgICAgLy8gbGlzdGVuZXJzIGFkZGVkIHRvIG9uTWVzc2FnZSwgYW5kIGVhY2ggb25lIHRha2VzIGNhcmUgb2Ygd2hhdCBpdCByZWFsbHkgY2FyZXNcclxuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJlc29sdmUocmV0KVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLnRoZW4oXHJcbiAgICAgICAgKHJlcykgPT4ge1xyXG4gICAgICAgICAgZS5zb3VyY2UucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAuLi50cGwsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc1xyXG4gICAgICAgICAgfSwgJyonKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgKGVycikgPT4ge1xyXG4gICAgICAgICAgZS5zb3VyY2UucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAuLi50cGwsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnIubWVzc2FnZVxyXG4gICAgICAgICAgfSwgJyonKVxyXG4gICAgICAgIH1cclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1zZylcclxuICByZXR1cm4gKCkgPT4gd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1zZylcclxufVxyXG4iLCJpbXBvcnQgaXBjUHJvbWlzZSBmcm9tICcuL2lwY19wcm9taXNlJ1xyXG5pbXBvcnQgeyBnZXRJcGNDYWNoZSB9IGZyb20gJy4vaXBjX2NhY2hlJ1xyXG5pbXBvcnQgRXh0IGZyb20gJy4uL3dlYl9leHRlbnNpb24nXHJcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nJ1xyXG5pbXBvcnQgeyByZXRyeSwgd2l0aFRpbWVvdXQsIG1vY2tBUElXaXRoIH0gZnJvbSAnLi4vdXRpbHMnXHJcblxyXG5jb25zdCBUSU1FT1VUID0gLTFcclxuXHJcbi8vIE5vdGU6IGBjdWlkYCBpcyBhIGtpbmQgb2YgdW5pcXVlIGlkIHNvIHRoYXQgeW91IGNhbiBjcmVhdGUgbXVsdGlwbGVcclxuLy8gaXBjIHByb21pc2UgaW5zdGFuY2VzIGJldHdlZW4gdGhlIHNhbWUgdHdvIGVuZCBwb2ludHNcclxuZXhwb3J0IGNvbnN0IG9wZW5CZ1dpdGhDcyA9IChjdWlkKSA9PiB7XHJcbiAgY29uc3Qgd3JhcCA9IChzdHIpID0+IHN0ciArICdfJyArIGN1aWRcclxuXHJcbiAgLy8gZmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBpcGMgcHJvbWlzZSBpbnN0YW5jZSBmb3IgYmFja2dyb3VuZFxyXG4gIC8vIGB0YWJJZGAgaXMgbmVlZGVkIHRvIGlkZW50aWZ5IHdoaWNoIHRhYiB0byBzZW5kIG1lc3NhZ2VzIHRvXHJcbiAgY29uc3QgaXBjQmcgPSAodGFiSWQpID0+IHtcclxuICAgIGxldCBiZ0xpc3RlbmVycyA9IFtdXHJcblxyXG4gICAgLy8gYHNlbmRlcmAgY29udGFpbnMgdGFiIGluZm8uIEJhY2tncm91bmQgbWF5IG5lZWQgdGhpcyB0byBzdG9yZSB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAgLy8gcmVsYXRpb25zaGlwIGJldHdlZW4gdGFiSWQgYW5kIGlwYyBpbnN0YW5jZVxyXG4gICAgY29uc3QgYWRkU2VuZGVyID0gKG9iaiwgc2VuZGVyKSA9PiB7XHJcbiAgICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSAgcmV0dXJuIG9ialxyXG5cclxuICAgICAgb2JqLnNlbmRlciAgPSBzZW5kZXJcclxuICAgICAgcmV0dXJuIG9ialxyXG4gICAgfVxyXG5cclxuICAgIEV4dC5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigocmVxLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xyXG4gICAgICBiZ0xpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHJlcSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gaXBjUHJvbWlzZSh7XHJcbiAgICAgIHRpbWVvdXQ6IFRJTUVPVVQsXHJcbiAgICAgIGFzazogZnVuY3Rpb24gKHVpZCwgY21kLCBhcmdzKSB7XHJcbiAgICAgICAgRXh0LnRhYnMuc2VuZE1lc3NhZ2UodGFiSWQsIHtcclxuICAgICAgICAgIHR5cGU6IHdyYXAoJ0JHX0FTS19DUycpLFxyXG4gICAgICAgICAgdWlkLFxyXG4gICAgICAgICAgY21kLFxyXG4gICAgICAgICAgYXJnc1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uQW5zd2VyOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBiZ0xpc3RlbmVycy5wdXNoKChyZXEsIHNlbmRlciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gd3JhcCgnQ1NfQU5TV0VSX0JHJykpICByZXR1cm5cclxuICAgICAgICAgIGZuKHJlcS51aWQsIHJlcS5lcnIsIGFkZFNlbmRlcihyZXEuZGF0YSwgc2VuZGVyKSlcclxuICAgICAgICB9KVxyXG4gICAgICB9LFxyXG4gICAgICBvbkFzazogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgYmdMaXN0ZW5lcnMucHVzaCgocmVxLCBzZW5kZXIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IHdyYXAoJ0NTX0FTS19CRycpKSAgcmV0dXJuXHJcbiAgICAgICAgICBmbihyZXEudWlkLCByZXEuY21kLCBhZGRTZW5kZXIocmVxLmFyZ3MsIHNlbmRlcikpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSxcclxuICAgICAgYW5zd2VyOiBmdW5jdGlvbiAodWlkLCBlcnIsIGRhdGEpIHtcclxuICAgICAgICBFeHQudGFicy5zZW5kTWVzc2FnZSh0YWJJZCwge1xyXG4gICAgICAgICAgdHlwZTogd3JhcCgnQkdfQU5TV0VSX0NTJyksXHJcbiAgICAgICAgICB1aWQsXHJcbiAgICAgICAgICBlcnIsXHJcbiAgICAgICAgICBkYXRhXHJcbiAgICAgICAgfSlcclxuICAgICAgfSxcclxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGJnTGlzdGVuZXJzID0gW11cclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8vIGZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgaXBjIHByb21pc2UgZm9yIGNvbnRlbnQgc2NyaXB0c1xyXG4gIGNvbnN0IGlwY0NzID0gKGNoZWNrUmVhZHkpID0+IHtcclxuICAgIGxldCBjc0xpc3RlbmVycyA9IFtdXHJcblxyXG4gICAgRXh0LnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKChyZXEsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSA9PiB7XHJcbiAgICAgIGNzTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIocmVxLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBpcGNQcm9taXNlKHtcclxuICAgICAgdGltZW91dDogVElNRU9VVCxcclxuICAgICAgY2hlY2tSZWFkeTogY2hlY2tSZWFkeSxcclxuICAgICAgYXNrOiBmdW5jdGlvbiAodWlkLCBjbWQsIGFyZ3MpIHtcclxuICAgICAgICAvLyBsb2coJ2NzIGFzaycsIHVpZCwgY21kLCBhcmdzKVxyXG4gICAgICAgIEV4dC5ydW50aW1lLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgIHR5cGU6IHdyYXAoJ0NTX0FTS19CRycpLFxyXG4gICAgICAgICAgdWlkLFxyXG4gICAgICAgICAgY21kLFxyXG4gICAgICAgICAgYXJnc1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uQW5zd2VyOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBjc0xpc3RlbmVycy5wdXNoKChyZXEsIHNlbmRlciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gd3JhcCgnQkdfQU5TV0VSX0NTJykpICByZXR1cm5cclxuICAgICAgICAgIGZuKHJlcS51aWQsIHJlcS5lcnIsIHJlcS5kYXRhKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uQXNrOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBjc0xpc3RlbmVycy5wdXNoKChyZXEsIHNlbmRlciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gd3JhcCgnQkdfQVNLX0NTJykpICByZXR1cm5cclxuICAgICAgICAgIGZuKHJlcS51aWQsIHJlcS5jbWQsIHJlcS5hcmdzKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIGFuc3dlcjogZnVuY3Rpb24gKHVpZCwgZXJyLCBkYXRhKSB7XHJcbiAgICAgICAgRXh0LnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgdHlwZTogd3JhcCgnQ1NfQU5TV0VSX0JHJyksXHJcbiAgICAgICAgICB1aWQsXHJcbiAgICAgICAgICBlcnIsXHJcbiAgICAgICAgICBkYXRhXHJcbiAgICAgICAgfSlcclxuICAgICAgfSxcclxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNzTGlzdGVuZXJzID0gW11cclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpcGNDcyxcclxuICAgIGlwY0JnXHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gaW5pdCBpcGMgcHJvbWlzZSBpbnN0YW5jZSBmb3IgY29udGVudCBzY3JpcHRzXHJcbi8vIFRoZSBpZGVhIGhlcmUgaXMgdG8gc2VuZCBDT05ORUNUIG1lc3NhZ2UgdG8gYmFja2dyb3VuZCB3aGVuIGluaXRpYWxpemluZ1xyXG5leHBvcnQgY29uc3QgY3NJbml0ID0gKCkgPT4ge1xyXG4gIGNvbnN0IGN1aWQgPSAnJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKVxyXG5cclxuICBsb2coJ3NlbmRpbmcgQ29ubmVjdC4uLicpXHJcblxyXG4gIC8vIE5vdGU6IEV4dC5leHRlbnNpb24uZ2V0VVJMIGlzIGF2YWlsYWJsZSBpbiBjb250ZW50IHNjcmlwdCwgYnV0IG5vdCBpbmplY3RlZCBqc1xyXG4gIC8vIFdlIHVzZSBpdCBoZXJlIHRvIGRldGVjdCB3aGV0aGVyIGl0IGlzIGxvYWRlZCBieSBjb250ZW50IHNjcmlwdCBvciBpbmplY3RlZFxyXG4gIC8vIENhbGxpbmcgcnVudGltZS5zZW5kTWVzc2FnZSBpbiBpbmplY3RlZCBqcyB3aWxsIGNhdXNlIGFuIHVuY2F0Y2hhYmxlIGV4Y2VwdGlvblxyXG4gIGlmICghRXh0LmV4dGVuc2lvbi5nZXRVUkwpIHJldHVyblxyXG5cclxuICAvLyB0cnkgdGhpcyBwcm9jZXNzIGluIGNhc2Ugd2UncmUgaW4gbm9uZS1zcmMgZnJhbWVcclxuICB0cnkge1xyXG4gICAgLy8gbGV0IGNvbm5lY3RlZCAgICAgPSBmYWxzZVxyXG4gICAgLy8gY29uc3QgY2hlY2tSZWFkeSAgPSAoKSA9PiB7XHJcbiAgICAvLyAgIGlmIChjb25uZWN0ZWQpICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpXHJcbiAgICAvLyAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2NzIG5vdCBjb25uZWN0ZWQgd2l0aCBiZyB5ZXQnKSlcclxuICAgIC8vIH1cclxuICAgIGNvbnN0IHJlY29ubmVjdCAgID0gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoNTAwLCAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIEV4dC5ydW50aW1lLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgIHR5cGU6ICdSRUNPTk5FQ1QnXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihjdWlkID0+IHtcclxuICAgICAgICAgIGxvZygnZ290IGV4aXN0aW5nIGN1aWQnLCBjdWlkKVxyXG4gICAgICAgICAgaWYgKGN1aWQpIHJldHVybiBvcGVuQmdXaXRoQ3MoY3VpZCkuaXBjQ3MoKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcmVjb25uZWN0JylcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29ubmVjdEJnICAgPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiB3aXRoVGltZW91dCgxMDAwLCAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIEV4dC5ydW50aW1lLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgIHR5cGU6ICdDT05ORUNUJyxcclxuICAgICAgICAgIGN1aWQ6IGN1aWRcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGRvbmUgPT4ge1xyXG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBvcGVuQmdXaXRoQ3MoY3VpZCkuaXBjQ3MoKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZG9uZScpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIGNvbnN0IHRyeUNvbm5lY3QgPSByZXRyeShjb25uZWN0QmcsIHtcclxuICAgICAgc2hvdWxkUmV0cnk6ICgpID0+IHRydWUsXHJcbiAgICAgIHJldHJ5SW50ZXJ2YWw6IDAsXHJcbiAgICAgIHRpbWVvdXQ6IDUwMDBcclxuICAgIH0pXHJcblxyXG4gICAgLy8gTm90ZTogU3RyYXRlZ3kgaGVyZVxyXG4gICAgLy8gMS4gVHJ5IHRvIHJlY292ZXIgY29ubmVjdGlvbiB3aXRoIGJhY2tncm91bmQgKGdldCB0aGUgZXhpc3RpbmcgY3VpZClcclxuICAgIC8vIDIuIElmIGN1aWQgbm90IGZvdW5kLCB0cnkgdG8gY3JlYXRlIG5ldyBjb25uZWN0aW9uIChjdWlkKSB3aXRoIGJhY2tncm91bmRcclxuICAgIC8vIDMuIEJvdGggb2YgdGhlc2UgdHdvIHN0ZXBzIGFib3ZlIGFyZSBhc3luYywgYnV0IHRoaXMgYXBpIGl0c2VsZiBpcyBzeW5jaHJvbm91cyxcclxuICAgIC8vICAgIHNvIHdlIGhhdmUgdG8gY3JlYXRlIGEgbW9jayBBUEkgYW5kIHJldHVybiBpdCBmaXJzdFxyXG4gICAgcmV0dXJuIG1vY2tBUElXaXRoKFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJlY29ubmVjdCgpXHJcbiAgICAgICAgLmNhdGNoKCgpID0+IHRyeUNvbm5lY3QoKSlcclxuICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICBsb2cuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY3MgaXBjJylcclxuICAgICAgICAgIHRocm93IGVcclxuICAgICAgICB9KVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgYXNrOiAoKSA9PiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ21vY2sgYXNrJykpLFxyXG4gICAgICAgIG9uQXNrOiAoLi4uYXJncykgPT4geyBsb2coJ21vY2sgb25Bc2snLCAuLi5hcmdzKSB9LFxyXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHt9XHJcbiAgICAgIH0sXHJcbiAgICAgIFsnYXNrJ11cclxuICAgIClcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBsb2cuZXJyb3IoZS5zdGFjaylcclxuICB9XHJcbn1cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBpbml0IGlwYyBwcm9taXNlIGluc3RhbmNlIGZvciBiYWNrZ3JvdW5kXHJcbi8vIGl0IGFjY2VwdHMgYSBgZm5gIGZ1bmN0aW9uIHRvIGhhbmRsZSBDT05ORUNUIG1lc3NhZ2UgZnJvbSBjb250ZW50IHNjcmlwdHNcclxuZXhwb3J0IGNvbnN0IGJnSW5pdCA9IChmbikgPT4ge1xyXG4gIEV4dC5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigocmVxLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xyXG4gICAgc3dpdGNoIChyZXEudHlwZSkge1xyXG4gICAgICBjYXNlICdDT05ORUNUJzoge1xyXG4gICAgICAgIGlmIChyZXEuY3VpZCkge1xyXG4gICAgICAgICAgZm4oc2VuZGVyLnRhYi5pZCwgcmVxLmN1aWQsIG9wZW5CZ1dpdGhDcyhyZXEuY3VpZCkuaXBjQmcoc2VuZGVyLnRhYi5pZCkpXHJcbiAgICAgICAgICBzZW5kUmVzcG9uc2UodHJ1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSAnUkVDT05ORUNUJzoge1xyXG4gICAgICAgIGNvbnN0IGN1aWQgPSBnZXRJcGNDYWNoZSgpLmdldEN1aWQoc2VuZGVyLnRhYi5pZClcclxuXHJcbiAgICAgICAgaWYgKGN1aWQpIHtcclxuICAgICAgICAgIGdldElwY0NhY2hlKCkuZW5hYmxlKHNlbmRlci50YWIuaWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZW5kUmVzcG9uc2UoY3VpZCB8fCBudWxsKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH0pXHJcbn1cclxuIiwiaW1wb3J0IHsgdW50aWwgfSBmcm9tICcuLi91dGlscydcclxuXHJcbmV4cG9ydCBjbGFzcyBJcGNDYWNoZSB7XHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgdGhpcy5jYWNoZSA9IHt9XHJcbiAgfVxyXG5cclxuICBnZXQgKHRhYklkLCB0aW1lb3V0ID0gMjAwMCwgYmVmb3JlID0gSW5maW5pdHkpIHtcclxuICAgIHJldHVybiB1bnRpbCgnaXBjIGJ5IHRhYiBpZCcsICgpID0+IHtcclxuICAgICAgY29uc3QgaXBjT2JqICA9IHRoaXMuY2FjaGVbdGFiSWRdXHJcbiAgICAgIGNvbnN0IGVuYWJsZWQgPSBpcGNPYmogJiYgaXBjT2JqLnN0YXR1cyA9PT0gMVxyXG4gICAgICBjb25zdCBpcGMgICAgID0gaXBjT2JqICYmIGlwY09iai5pcGNcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFzczogICBlbmFibGVkICYmICEhaXBjICYmIChiZWZvcmUgPT09IEluZmluaXR5IHx8IGJlZm9yZSA+IGlwY09iai50aW1lc3RhbXApLFxyXG4gICAgICAgIHJlc3VsdDogaXBjXHJcbiAgICAgIH1cclxuICAgIH0sIDEwMCwgdGltZW91dClcclxuICB9XHJcblxyXG4gIHNldCAodGFiSWQsIGlwYywgY3VpZCkge1xyXG4gICAgdGhpcy5jYWNoZVt0YWJJZF0gPSB7XHJcbiAgICAgIGlwYyxcclxuICAgICAgY3VpZCxcclxuICAgICAgc3RhdHVzOiAxLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRTdGF0dXMgKHRhYklkLCBzdGF0dXMsIHVwZGF0ZVRpbWVzdGFtcCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IHRoaXMuY2FjaGVbdGFiSWRdXHJcbiAgICBpZiAoIWZvdW5kKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICBmb3VuZC5zdGF0dXMgPSBzdGF0dXNcclxuXHJcbiAgICBpZiAodXBkYXRlVGltZXN0YW1wKSB7XHJcbiAgICAgIGZvdW5kLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIGVuYWJsZSAodGFiSWQpIHtcclxuICAgIHJldHVybiB0aGlzLnNldFN0YXR1cyh0YWJJZCwgMSwgdHJ1ZSlcclxuICB9XHJcblxyXG4gIGRpc2FibGUgKHRhYklkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRTdGF0dXModGFiSWQsIDApXHJcbiAgfVxyXG5cclxuICBnZXRDdWlkICh0YWJJZCkge1xyXG4gICAgY29uc3QgZm91bmQgPSB0aGlzLmNhY2hlW3RhYklkXVxyXG4gICAgaWYgKCFmb3VuZCkgcmV0dXJuIG51bGxcclxuICAgIHJldHVybiBmb3VuZC5jdWlkXHJcbiAgfVxyXG5cclxuICBkZWwgKHRhYklkKSB7XHJcbiAgICBkZWxldGUgdGhpcy5jYWNoZVt0YWJJZF1cclxuICB9XHJcbn1cclxuXHJcbmxldCBpbnN0YW5jZVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldElwY0NhY2hlICgpIHtcclxuICBpZiAoaW5zdGFuY2UpIHJldHVybiBpbnN0YW5jZVxyXG4gIGluc3RhbmNlID0gbmV3IElwY0NhY2hlKClcclxuICByZXR1cm4gaW5zdGFuY2VcclxufVxyXG4iLCJpbXBvcnQgeyBjc0luaXQgfSBmcm9tICcuL2lwY19iZ19jcydcclxuXHJcbmNvbnN0IHRocm93Tm90VG9wID0gKCkgPT4ge1xyXG4gIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgYSB0b3Agd2luZG93LCBub3QgYWxsb3dlZCB0byBpbml0aWFsaXplL3VzZSBjc0lwYycpXHJcbn1cclxuXHJcbi8vIE5vdGU6IGNzSXBjIGlzIG9ubHkgYXZhaWxhYmxlIHRvIHRvcCB3aW5kb3dcclxuY29uc3QgaXBjID0gd2luZG93LnRvcCA9PT0gd2luZG93ID8gY3NJbml0KCkgOiB7XHJcbiAgYXNrOiB0aHJvd05vdFRvcCxcclxuICBzZW5kOiB0aHJvd05vdFRvcCxcclxuICBvbkFzazogdGhyb3dOb3RUb3AsXHJcbiAgZGVzdHJveTogdGhyb3dOb3RUb3BcclxufVxyXG5cclxuLy8gTm90ZTogb25lIGlwYyBzaW5nbGV0b24gcGVyIGNvbnRlbnQgc2NyaXB0XHJcbmV4cG9ydCBkZWZhdWx0IGlwY1xyXG4iLCJjb25zdCB7IHJldHJ5IH0gPSByZXF1aXJlKCcuLi91dGlscycpXHJcblxyXG52YXIgVE9fQkVfUkVNT1ZFRCA9IGZhbHNlO1xyXG5cclxudmFyIGxvZyA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZykgY29uc29sZS5sb2cobXNnKTtcclxufTtcclxuXHJcbnZhciB0cmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzRXJyb3I6IHRydWUsXHJcbiAgICAgIG5hbWU6IGVyci5uYW1lLFxyXG4gICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVyci5zdGFja1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVyclxyXG59XHJcblxyXG4vLyBOb3RlOiBUaGUgd2hvbGUgaWRlYSBvZiBpcGMgcHJvbWlzZSBpcyBhYm91dCB0cmFuc2Zvcm1pbmcgdGhlIGNhbGxiYWNrIHN0eWxlXHJcbi8vIGlwYyBjb21tdW5pY2F0aW9uIEFQSSB0byBhIFByb21pc2Ugc3R5bGVcclxuLy9cclxuLy8gZWcuIE9yaWduaWFsOiAgICBgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe30sICgpID0+IHt9KWBcclxuLy8gICAgIGlwY1Byb21pc2U6ICBgaXBjLmFzayh7fSkudGhlbigoKSA9PiB7fSlgXHJcbi8vXHJcbi8vIFRoZSBiZW5pZml0IGlzXHJcbi8vIDEuIFlvdSBjYW4gY2hhaW4gdGhpcyBwcm9taXNlIHdpdGggb3RoZXJzXHJcbi8vIDIuIENyZWF0ZSBraW5kIG9mIGNvbm5lY3RlZCBjaGFubmVscyBiZXR3ZWVuIHR3byBpcGMgZW5kc1xyXG4vL1xyXG4vLyBUaGlzIGlzIGEgZ2VuZXJpYyBpbnRlcmZhY2UgdG8gZGVmaW5lIGEgaXBjIHByb21pc2UgdXRpbGl0eVxyXG4vLyBBbGwgeW91IG5lZWQgdG8gZGVjbGFyZSBpcyA0IGZ1bmN0aW9uc1xyXG4vL1xyXG4vLyBlLmcuXHJcbi8vIGBgYFxyXG4vLyBpcGNQcm9taXNlKHtcclxuLy8gICBhc2s6IGZ1bmN0aW9uICh1aWQsIGNtZCwgYXJncykgeyAuLi4gfSxcclxuLy8gICBhbnN3ZXI6IGZ1bmN0aW9uICh1aWQsIGVyciwgZGF0YSkgeyAuLi4gfSxcclxuLy8gICBvbkFzazogZnVuY3Rpb24gKGZuKSB7IC4uLiB9LFxyXG4vLyAgIG9uQW5zd2VyOiBmdW5jdGlvbiAoZm4pIHsgLi4uIH0sXHJcbi8vIH0pXHJcbi8vIGBgYFxyXG5mdW5jdGlvbiBpcGNQcm9taXNlIChvcHRpb25zKSB7XHJcbiAgdmFyIGFzayAgICAgICAgID0gb3B0aW9ucy5hc2tcclxuICB2YXIgYW5zd2VyICAgICAgPSBvcHRpb25zLmFuc3dlclxyXG4gIHZhciB0aW1lb3V0ICAgICA9IG9wdGlvbnMudGltZW91dFxyXG4gIHZhciBvbkFuc3dlciAgICA9IG9wdGlvbnMub25BbnN3ZXJcclxuICB2YXIgb25Bc2sgICAgICAgPSBvcHRpb25zLm9uQXNrXHJcbiAgdmFyIHVzZXJEZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95XHJcbiAgdmFyIGNoZWNrUmVhZHkgID0gb3B0aW9ucy5jaGVja1JlYWR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKSB9XHJcblxyXG4gIHZhciBhc2tDYWNoZSA9IHt9XHJcbiAgdmFyIHVuaGFuZGxlZEFzayA9IFtdXHJcbiAgdmFyIG1hcmtVbmhhbmRsZWQgPSBmdW5jdGlvbiAodWlkLCBjbWQsIGFyZ3MpIHtcclxuICAgIHVuaGFuZGxlZEFzay5wdXNoKHsgdWlkOiB1aWQsIGNtZDogY21kLCBhcmdzOiBhcmdzIH0pO1xyXG4gIH1cclxuICB2YXIgaGFuZGxlciA9IG1hcmtVbmhhbmRsZWRcclxuXHJcbiAgdmFyIHJ1bkhhbmRsZXJzID0gKGhhbmRsZXJzLCBjbWQsIGFyZ3MsIHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHZhciByZXNcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmVzID0gaGFuZGxlcnNbaV0oY21kLCBhcmdzKVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlamVjdChlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE5vdGU6IERPIE5PVCByZXNvbHZlIGFueXRoaW5nIGlmIGFsbCBoYW5kbGVycyByZXR1cm4gdW5kZWZpbmVkXHJcbiAgfVxyXG5cclxuICAvLyBib3RoIGZvciBhc2sgYW5kIHVuaGFuZGxlZEFza1xyXG4gIHRpbWVvdXQgPSB0aW1lb3V0IHx8IC0xO1xyXG5cclxuICBvbkFuc3dlcihmdW5jdGlvbiAodWlkLCBlcnIsIGRhdGEpIHtcclxuICAgIGlmICh1aWQgJiYgYXNrQ2FjaGVbdWlkXSA9PT0gVE9fQkVfUkVNT1ZFRCkge1xyXG4gICAgICBkZWxldGUgYXNrQ2FjaGVbdWlkXTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdWlkIHx8ICFhc2tDYWNoZVt1aWRdKSB7XHJcbiAgICAgIC8vIGxvZygnaXBjUHJvbWlzZTogcmVzcG9uc2UgdWlkIGludmFsaWQ6ICcgKyB1aWQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc29sdmUgPSBhc2tDYWNoZVt1aWRdWzBdO1xyXG4gICAgdmFyIHJlamVjdCAgPSBhc2tDYWNoZVt1aWRdWzFdO1xyXG5cclxuICAgIGRlbGV0ZSBhc2tDYWNoZVt1aWRdO1xyXG5cclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgcmVqZWN0KHRyYW5zZm9ybUVycm9yKGVycikpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgb25Bc2soZnVuY3Rpb24gKHVpZCwgY21kLCBhcmdzKSB7XHJcbiAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gdW5oYW5kbGVkQXNrICYmIHVuaGFuZGxlZEFzay5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXRlbS51aWQgPT09IHVpZDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFmb3VuZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBhbnN3ZXIodWlkLCBuZXcgRXJyb3IoJ2lwY1Byb21pc2U6IGFuc3dlciB0aW1lb3V0ICcgKyB0aW1lb3V0ICsgJyBmb3IgY21kIFwiJyArIGNtZCArICdcIiwgYXJncyBcIicgICsgYXJncyArICdcIicpKTtcclxuICAgICAgfSwgdGltZW91dCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhbmRsZXIgPT09IG1hcmtVbmhhbmRsZWQpIHtcclxuICAgICAgbWFya1VuaGFuZGxlZCh1aWQsIGNtZCwgYXJncyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBydW5IYW5kbGVycyhoYW5kbGVyLCBjbWQsIGFyZ3MsIHJlc29sdmUsIHJlamVjdClcclxuICAgIH0pXHJcbiAgICAudGhlbihcclxuICAgICAgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAvLyBub3RlOiBoYW5kbGVyIGRvZW5zJ3QgaGFuZGxlIHRoZSBjbWQgPT4gcmV0dXJuIHVuZGVmaW5lZCwgc2hvdWxkIHdhaXQgZm9yIHRpbWVvdXRcclxuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSAgcmV0dXJuIG1hcmtVbmhhbmRsZWQodWlkLCBjbWQsIGFyZ3MpO1xyXG4gICAgICAgIGFuc3dlcih1aWQsIG51bGwsIGRhdGEpXHJcbiAgICAgIH0sXHJcbiAgICAgIGZ1bmN0aW9uIChlcnIpICB7IGFuc3dlcih1aWQsIHRyYW5zZm9ybUVycm9yKGVyciksIG51bGwpIH1cclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHZhciB3cmFwQXNrID0gZnVuY3Rpb24gKGNtZCwgYXJncywgdGltZW91dFRvT3ZlcnJpZGUpIHtcclxuICAgIHZhciB1aWQgPSAnaXBjcF8nICsgbmV3IERhdGUoKSAqIDEgKyAnXycgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwKTtcclxuICAgIHZhciBmaW5hbFRpbWVvdXQgPSB0aW1lb3V0VG9PdmVycmlkZSB8fCB0aW1lb3V0XHJcblxyXG4gICAgLy8gTm90ZTogbWFrZSBpdCBwb3NzaWJsZSB0byBkaXNhYmxlIHRpbWVvdXRcclxuICAgIGlmIChmaW5hbFRpbWVvdXQgPiAwKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWplY3Q7XHJcblxyXG4gICAgICAgIGlmIChhc2tDYWNoZSAmJiBhc2tDYWNoZVt1aWRdKSB7XHJcbiAgICAgICAgICByZWplY3QgPSBhc2tDYWNoZVt1aWRdWzFdO1xyXG4gICAgICAgICAgYXNrQ2FjaGVbdWlkXSA9IFRPX0JFX1JFTU9WRUQ7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdpcGNQcm9taXNlOiBvbkFzayB0aW1lb3V0ICcgKyBmaW5hbFRpbWVvdXQgKyAnIGZvciBjbWQgXCInICsgY21kICsgJ1wiLCBhcmdzIFwiJyAgKyBhcmdzICsgJ1wiJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZmluYWxUaW1lb3V0KTtcclxuICAgIH1cclxuXHJcbiAgICBhc2sodWlkLCBjbWQsIGFyZ3MgfHwgW10pO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIGFza0NhY2hlW3VpZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHdyYXBPbkFzayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcclxuICAgICAgaGFuZGxlci5wdXNoKGZuKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGFuZGxlciA9IFtmbl1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHMgPSB1bmhhbmRsZWRBc2subWFwKGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgcnVuSGFuZGxlcnMoaGFuZGxlciwgdGFzay5jbWQsIHRhc2suYXJncywgcmVzb2x2ZSwgcmVqZWN0KVxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihcclxuICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgLy8gbm90ZTogaGFuZGxlciBkb2Vucyd0IGhhbmRsZSB0aGUgY21kID0+IHJldHVybiB1bmRlZmluZWQsIHNob3VsZCB3YWl0IGZvciB0aW1lb3V0XHJcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSAgcmV0dXJuO1xyXG4gICAgICAgICAgYW5zd2VyKHRhc2sudWlkLCBudWxsLCBkYXRhKTtcclxuICAgICAgICAgIHJldHVybiB0YXNrLnVpZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgIGFuc3dlcih0YXNrLnVpZCwgZXJyLCBudWxsKTtcclxuICAgICAgICAgIHJldHVybiB0YXNrLnVpZDtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBQcm9taXNlLmFsbChwcykudGhlbihmdW5jdGlvbiAodWlkcykge1xyXG4gICAgICBmb3IgKHZhciB1aWQgb2YgdWlkcykge1xyXG4gICAgICAgIGlmICh1aWQgPT09IHVuZGVmaW5lZCkgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB1bmhhbmRsZWRBc2suZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXRlbS51aWQgPT09IHVpZDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdW5oYW5kbGVkQXNrLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHZhciBkZXN0cm95ID0gZnVuY3Rpb24gKG5vUmVqZWN0KSB7XHJcbiAgICB1c2VyRGVzdHJveSAmJiB1c2VyRGVzdHJveSgpO1xyXG5cclxuICAgIGFzayA9IG51bGw7XHJcbiAgICBhbnN3ZXIgPSBudWxsO1xyXG4gICAgb25BbnN3ZXIgPSBudWxsO1xyXG4gICAgb25Bc2sgPSBudWxsO1xyXG4gICAgdW5oYW5kbGVkQXNrID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIW5vUmVqZWN0KSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKGFza0NhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICB2YXIgdHVwbGUgPSBhc2tDYWNoZVt1aWRdO1xyXG4gICAgICAgIHZhciByZWplY3QgPSB0dXBsZVsxXTtcclxuICAgICAgICByZWplY3QgJiYgcmVqZWN0KG5ldyBFcnJvcignSVBDIFByb21pc2UgaGFzIGJlZW4gRGVzdHJveWVkLicpKTtcclxuICAgICAgICBkZWxldGUgYXNrQ2FjaGVbdWlkXTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHdhaXRGb3JSZWFkeSA9IGZ1bmN0aW9uIChjaGVja1JlYWR5LCBmbikge1xyXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1ha2VTdXJlUmVhZHkgPSByZXRyeShjaGVja1JlYWR5LCB7XHJcbiAgICAgICAgc2hvdWxkUmV0cnk6ICgpID0+IHRydWUsXHJcbiAgICAgICAgcmV0cnlJbnRlcnZhbDogMTAwLFxyXG4gICAgICAgIHRpbWVvdXQ6IDUwMDBcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiBtYWtlU3VyZVJlYWR5KCkudGhlbigoKSA9PiBmbiguLi5hcmdzKSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBhc2s6IHdhaXRGb3JSZWFkeShjaGVja1JlYWR5LCB3cmFwQXNrKSxcclxuICAgIG9uQXNrOiB3cmFwT25Bc2ssXHJcbiAgICBkZXN0cm95OiBkZXN0cm95XHJcbiAgfTtcclxufVxyXG5cclxuaXBjUHJvbWlzZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFzazogZnVuY3Rpb24gKGNtZCwgYXJncywgdGltZW91dCkge1xyXG4gICAgICByZXR1cm4gb2JqLmFzayhjbWQsIEpTT04uc3RyaW5naWZ5KGFyZ3MpLCB0aW1lb3V0KTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Bc2s6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICByZXR1cm4gb2JqLm9uQXNrKGZ1bmN0aW9uIChjbWQsIGFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gZm4oY21kLCBKU09OLnBhcnNlKGFyZ3MpKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IG9iai5kZXN0cm95XHJcbiAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXBjUHJvbWlzZTtcclxuIiwiaW1wb3J0IGlzRWRpdGFibGUgZnJvbSAnZG9tLWVsZW1lbnQtaXMtbmF0aXZlbHktZWRpdGFibGUnO1xyXG5cclxuY29uc3QgQ1RSTCA9IDEgPDwgMDtcclxuY29uc3QgTUVUQSA9IDEgPDwgMTtcclxuY29uc3QgQUxUID0gMSA8PCAyO1xyXG5jb25zdCBTSElGVCA9IDEgPDwgMztcclxuXHJcbi8vIEtleSBFdmVudHNcclxuZXhwb3J0IGNvbnN0IEtleUV2ZW50cyA9IHtcclxuICBET1dOOiAxIDw8IDAsXHJcbiAgUFJFU1M6IDEgPDwgMSxcclxuICBVUDogMSA8PCAyLFxyXG4gIElOUFVUOiAxIDw8IDNcclxufTtcclxuS2V5RXZlbnRzLkFMTCA9IEtleUV2ZW50cy5ET1dOIHwgS2V5RXZlbnRzLlBSRVNTIHwgS2V5RXZlbnRzLlVQIHwgS2V5RXZlbnRzLklOUFVUO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBrZXlzdHJva2UsIG9yIGEgc2luZ2xlIGtleSBjb2RlIHdpdGggYSBzZXQgb2YgYWN0aXZlIG1vZGlmaWVycy5cclxuICpcclxuICogQGNsYXNzIEtleXN0cm9rZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEtleXN0cm9rZSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vZGlmaWVycyBBIGJpdG1hc2sgZm9ybWVkIGJ5IENUUkwsIE1FVEEsIEFMVCwgYW5kIFNISUZULlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlDb2RlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IgKG1vZGlmaWVycywga2V5Q29kZSkge1xyXG4gICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XHJcbiAgICB0aGlzLmN0cmxLZXkgPSAhIShtb2RpZmllcnMgJiBDVFJMKTtcclxuICAgIHRoaXMubWV0YUtleSA9ICEhKG1vZGlmaWVycyAmIE1FVEEpO1xyXG4gICAgdGhpcy5hbHRLZXkgPSAhIShtb2RpZmllcnMgJiBBTFQpO1xyXG4gICAgdGhpcy5zaGlmdEtleSA9ICEhKG1vZGlmaWVycyAmIFNISUZUKTtcclxuICAgIHRoaXMua2V5Q29kZSA9IGtleUNvZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBiaXRtYXNrIHZhbHVlIGZvciB0aGUgXCJjb250cm9sXCIgbW9kaWZpZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBDVFJMID0gQ1RSTDtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgYml0bWFzayB2YWx1ZSBmb3IgdGhlIFwibWV0YVwiIG1vZGlmaWVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBNRVRBID0gTUVUQTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgYml0bWFzayB2YWx1ZSBmb3IgdGhlIFwiYWx0XCIgbW9kaWZpZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIEFMVCA9IEFMVDtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgYml0bWFzayB2YWx1ZSBmb3IgdGhlIFwic2hpZnRcIiBtb2RpZmllci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgU0hJRlQgPSBTSElGVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbXVsYXRlcyBhIGtleWJvYXJkIHdpdGggYSBwYXJ0aWN1bGFyIGtleS10by1jaGFyYWN0ZXIgYW5kIGtleS10by1hY3Rpb25cclxuICogbWFwcGluZy4gVXNlIGBVU19FTkdMSVNIYCB0byBnZXQgYSBwcmUtY29uZmlndXJlZCBrZXlib2FyZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBLZXlib2FyZCB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3QuPG51bWJlciwgS2V5c3Ryb2tlPn0gY2hhckNvZGVLZXlDb2RlTWFwXHJcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYWN0aW9uS2V5Q29kZU1hcFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yIChjaGFyQ29kZUtleUNvZGVNYXAsIGFjdGlvbktleUNvZGVNYXApIHtcclxuICAgIHRoaXMuX2NoYXJDb2RlS2V5Q29kZU1hcCA9IGNoYXJDb2RlS2V5Q29kZU1hcDtcclxuICAgIHRoaXMuX2FjdGlvbktleUNvZGVNYXAgPSBhY3Rpb25LZXlDb2RlTWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgY2hhcmFjdGVyIGNvZGUgZ2VuZXJhdGVkIGJ5IHByZXNzaW5nIHRoZSBnaXZlbiBrZXlzdHJva2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0tleXN0cm9rZX0ga2V5c3Ryb2tlXHJcbiAgICogQHJldHVybiB7P251bWJlcn1cclxuICAgKi9cclxuICBjaGFyQ29kZUZvcktleXN0cm9rZSAoa2V5c3Ryb2tlKSB7XHJcbiAgICBsZXQgbWFwID0gdGhpcy5fY2hhckNvZGVLZXlDb2RlTWFwO1xyXG4gICAgZm9yIChsZXQgY2hhckNvZGUgaW4gbWFwKSB7XHJcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBjaGFyQ29kZSkpIHtcclxuICAgICAgICBsZXQga2V5c3Ryb2tlRm9yQ2hhckNvZGUgPSBtYXBbY2hhckNvZGVdO1xyXG4gICAgICAgIGlmIChrZXlzdHJva2Uua2V5Q29kZSA9PT0ga2V5c3Ryb2tlRm9yQ2hhckNvZGUua2V5Q29kZSAmJlxyXG4gICAgICAgICAga2V5c3Ryb2tlLm1vZGlmaWVycyA9PT0ga2V5c3Ryb2tlRm9yQ2hhckNvZGUubW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2hhckNvZGUsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBldmVudCByZWFkeSBmb3IgZGlzcGF0Y2hpbmcgb250byB0aGUgZ2l2ZW4gdGFyZ2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgT25lIG9mIFwia2V5ZG93blwiLCBcImtleXByZXNzXCIsIFwia2V5dXBcIiwgXCJ0ZXh0SW5wdXRcIiBvciBcImlucHV0XCIuXHJcbiAgICogQHBhcmFtIHtLZXlzdHJva2V9IGtleXN0cm9rZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0V2ZW50fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSAodHlwZSwga2V5c3Ryb2tlLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGRvY3VtZW50ID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XHJcbiAgICBjb25zdCB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgIGNvbnN0IEV2ZW50ID0gd2luZG93LkV2ZW50O1xyXG5cclxuICAgIGxldCBldmVudDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBldmVudCA9IG5ldyBFdmVudCh0eXBlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnVUlFdmVudHMnKTtcclxuICAgIH1cclxuXHJcbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3RleHRJbnB1dCc6XHJcbiAgICAgICAgZXZlbnQuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5jaGFyQ29kZUZvcktleXN0cm9rZShrZXlzdHJva2UpKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2tleWRvd24nOlxyXG4gICAgICBjYXNlICdrZXlwcmVzcyc6XHJcbiAgICAgIGNhc2UgJ2tleXVwJzpcclxuICAgICAgICBldmVudC5zaGlmdEtleSA9IGtleXN0cm9rZS5zaGlmdEtleTtcclxuICAgICAgICBldmVudC5hbHRLZXkgPSBrZXlzdHJva2UuYWx0S2V5O1xyXG4gICAgICAgIGV2ZW50Lm1ldGFLZXkgPSBrZXlzdHJva2UubWV0YUtleTtcclxuICAgICAgICBldmVudC5jdHJsS2V5ID0ga2V5c3Ryb2tlLmN0cmxLZXk7XHJcbiAgICAgICAgZXZlbnQua2V5Q29kZSA9IHR5cGUgPT09ICdrZXlwcmVzcycgPyB0aGlzLmNoYXJDb2RlRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSkgOiBrZXlzdHJva2Uua2V5Q29kZTtcclxuICAgICAgICBldmVudC5jaGFyQ29kZSA9IHR5cGUgPT09ICdrZXlwcmVzcycgPyBldmVudC5rZXlDb2RlIDogMDtcclxuICAgICAgICBldmVudC53aGljaCA9IGV2ZW50LmtleUNvZGU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV2ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZXMgdGhlIGNvcnJlY3Qgc2VxdWVuY2Ugb2YgZXZlbnRzIG9uIHRoZSBnaXZlbiB0YXJnZXQgYXMgaWYgdGhlIGdpdmVuXHJcbiAgICogYWN0aW9uIHdhcyB1bmRlcnRha2VuIGJ5IGEgaHVtYW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIGUuZy4gXCJhbHQrc2hpZnQrbGVmdFwiIG9yIFwiYmFja3NwYWNlXCJcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKi9cclxuICBkaXNwYXRjaEV2ZW50c0ZvckFjdGlvbiAoYWN0aW9uLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGtleXN0cm9rZSA9IHRoaXMua2V5c3Ryb2tlRm9yQWN0aW9uKGFjdGlvbik7XHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnRzRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSwgdGFyZ2V0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVzIHRoZSBjb3JyZWN0IHNlcXVlbmNlIG9mIGV2ZW50cyBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IGFzIGlmIHRoZSBnaXZlblxyXG4gICAqIGlucHV0IGhhZCBiZWVuIHR5cGVkIGJ5IGEgaHVtYW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKi9cclxuICBkaXNwYXRjaEV2ZW50c0ZvcklucHV0IChpbnB1dCwgdGFyZ2V0KSB7XHJcbiAgICBsZXQgY3VycmVudE1vZGlmaWVyU3RhdGUgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGtleXN0cm9rZSA9IHRoaXMua2V5c3Ryb2tlRm9yQ2hhckNvZGUoaW5wdXQuY2hhckNvZGVBdChpKSk7XHJcbiAgICAgIGlmICgha2V5c3Ryb2tlKSBjb250aW51ZVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uKHRhcmdldCwgY3VycmVudE1vZGlmaWVyU3RhdGUsIGtleXN0cm9rZS5tb2RpZmllcnMpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnRzRm9yS2V5c3Ryb2tlKGtleXN0cm9rZSwgdGFyZ2V0LCBmYWxzZSk7XHJcbiAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlID0ga2V5c3Ryb2tlLm1vZGlmaWVycztcclxuICAgIH1cclxuICAgIHRoaXMuZGlzcGF0Y2hNb2RpZmllclN0YXRlVHJhbnNpdGlvbih0YXJnZXQsIGN1cnJlbnRNb2RpZmllclN0YXRlLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVzIHRoZSBjb3JyZWN0IHNlcXVlbmNlIG9mIGV2ZW50cyBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IGFzIGlmIHRoZSBnaXZlblxyXG4gICAqIGtleXN0cm9rZSB3YXMgcGVyZm9ybWVkIGJ5IGEgaHVtYW4uIFdoZW4gc2ltdWxhdGluZywgZm9yIGV4YW1wbGUsIHR5cGluZ1xyXG4gICAqIHRoZSBsZXR0ZXIgXCJBXCIgKGFzc3VtaW5nIGEgVS5TLiBFbmdsaXNoIGtleWJvYXJkKSB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsXHJcbiAgICogbG9vayBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTE2IChTSElGVCkgY2hhckNvZGU9MCAgICAgIHNoaWZ0S2V5PXRydWVcclxuICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTY1IChBKSAgICAgY2hhckNvZGU9MCAgICAgIHNoaWZ0S2V5PXRydWVcclxuICAgKiAgIGtleXByZXNzICBrZXlDb2RlPTY1IChBKSAgICAgY2hhckNvZGU9NjUgKEEpIHNoaWZ0S2V5PXRydWVcclxuICAgKiAgIHRleHRJbnB1dCBkYXRhPUFcclxuICAgKiAgIGlucHV0XHJcbiAgICogICBrZXl1cCAgICAga2V5Q29kZT02NSAoQSkgICAgIGNoYXJDb2RlPTAgICAgICBzaGlmdEtleT10cnVlXHJcbiAgICogICBrZXl1cCAgICAga2V5Q29kZT0xNiAoU0hJRlQpIGNoYXJDb2RlPTAgICAgICBzaGlmdEtleT1mYWxzZVxyXG4gICAqXHJcbiAgICogSWYgdGhlIGtleXN0cm9rZSB3b3VsZCBub3QgY2F1c2UgYSBjaGFyYWN0ZXIgdG8gYmUgaW5wdXQsIHN1Y2ggYXMgd2hlblxyXG4gICAqIHByZXNzaW5nIGFsdCtzaGlmdCtsZWZ0LCB0aGUgc2VxdWVuY2UgbG9va3MgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogICBrZXlkb3duICAga2V5Q29kZT0xNiAoU0hJRlQpIGNoYXJDb2RlPTAgYWx0S2V5PWZhbHNlIHNoaWZ0S2V5PXRydWVcclxuICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTE4IChBTFQpICAgY2hhckNvZGU9MCBhbHRLZXk9dHJ1ZSAgc2hpZnRLZXk9dHJ1ZVxyXG4gICAqICAga2V5ZG93biAgIGtleUNvZGU9MzcgKExFRlQpICBjaGFyQ29kZT0wIGFsdEtleT10cnVlICBzaGlmdEtleT10cnVlXHJcbiAgICogICBrZXl1cCAgICAga2V5Q29kZT0zNyAoTEVGVCkgIGNoYXJDb2RlPTAgYWx0S2V5PXRydWUgIHNoaWZ0S2V5PXRydWVcclxuICAgKiAgIGtleXVwICAgICBrZXlDb2RlPTE4IChBTFQpICAgY2hhckNvZGU9MCBhbHRLZXk9ZmFsc2Ugc2hpZnRLZXk9dHJ1ZVxyXG4gICAqICAga2V5dXAgICAgIGtleUNvZGU9MTYgKFNISUZUKSBjaGFyQ29kZT0wIGFsdEtleT1mYWxzZSBzaGlmdEtleT1mYWxzZVxyXG4gICAqXHJcbiAgICogVG8gZGlzYWJsZSBoYW5kbGluZyBvZiBtb2RpZmllciBrZXlzLCBjYWxsIHdpdGggYHRyYW5zaXRpb25Nb2RpZmVyc2Agc2V0XHJcbiAgICogdG8gZmFsc2UuIERvaW5nIHNvIHdpbGwgb21pdCB0aGUga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aFxyXG4gICAqIHNoaWZ0LCBjdHJsLCBhbHQsIGFuZCBtZXRhIGtleXMgc3Vycm91bmRpbmcgdGhlIGFjdHVhbCBrZXlzdHJva2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0tleXN0cm9rZX0ga2V5c3Ryb2tlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdHJhbnNpdGlvbk1vZGlmaWVyc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudHNcclxuICAgKi9cclxuICBkaXNwYXRjaEV2ZW50c0ZvcktleXN0cm9rZSAoa2V5c3Ryb2tlLCB0YXJnZXQsIHRyYW5zaXRpb25Nb2RpZmllcnMgPSB0cnVlLCBldmVudHMgPSBLZXlFdmVudHMuQUxMKSB7XHJcbiAgICBpZiAoIWtleXN0cm9rZSkgcmV0dXJuXHJcblxyXG4gICAgaWYgKHRyYW5zaXRpb25Nb2RpZmllcnMpIHtcclxuICAgICAgdGhpcy5kaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uKHRhcmdldCwgMCwga2V5c3Ryb2tlLm1vZGlmaWVycywgZXZlbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQga2V5ZG93bkV2ZW50O1xyXG4gICAgaWYgKGV2ZW50cyAmIEtleUV2ZW50cy5ET1dOKSB7XHJcbiAgICAgIGtleWRvd25FdmVudCA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXlkb3duJywga2V5c3Ryb2tlLCB0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXlkb3duRXZlbnQgJiYgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoa2V5ZG93bkV2ZW50KSAmJiB0aGlzLnRhcmdldENhblJlY2VpdmVUZXh0SW5wdXQodGFyZ2V0KSkge1xyXG4gICAgICBsZXQga2V5cHJlc3NFdmVudDtcclxuICAgICAgaWYgKGV2ZW50cyAmIEtleUV2ZW50cy5QUkVTUykge1xyXG4gICAgICAgIGtleXByZXNzRXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5cHJlc3MnLCBrZXlzdHJva2UsIHRhcmdldCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGtleXByZXNzRXZlbnQgJiYga2V5cHJlc3NFdmVudC5jaGFyQ29kZSAmJiB0YXJnZXQuZGlzcGF0Y2hFdmVudChrZXlwcmVzc0V2ZW50KSkge1xyXG4gICAgICAgIGlmIChldmVudHMgJiBLZXlFdmVudHMuSU5QVVQpIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRpbnB1dEV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ3RleHRJbnB1dCcsIGtleXN0cm9rZSwgdGFyZ2V0KTtcclxuICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRleHRpbnB1dEV2ZW50KTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbnB1dEV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2lucHV0Jywga2V5c3Ryb2tlLCB0YXJnZXQpO1xyXG4gICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoaW5wdXRFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV2ZW50cyAmIEtleUV2ZW50cy5VUCkge1xyXG4gICAgICBjb25zdCBrZXl1cEV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleXVwJywga2V5c3Ryb2tlLCB0YXJnZXQpO1xyXG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChrZXl1cEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHJhbnNpdGlvbk1vZGlmaWVycykge1xyXG4gICAgICB0aGlzLmRpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24odGFyZ2V0LCBrZXlzdHJva2UubW9kaWZpZXJzLCAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zaXRpb25zIGZyb20gb25lIG1vZGlmaWVyIHN0YXRlIHRvIGFub3RoZXIgYnkgZGlzcGF0Y2hpbmcga2V5IGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tTW9kaWZpZXJTdGF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b01vZGlmaWVyU3RhdGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnRzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBkaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uICh0YXJnZXQsIGZyb21Nb2RpZmllclN0YXRlLCB0b01vZGlmaWVyU3RhdGUsIGV2ZW50cyA9IEtleUV2ZW50cy5BTEwpIHtcclxuICAgIGxldCBjdXJyZW50TW9kaWZpZXJTdGF0ZSA9IGZyb21Nb2RpZmllclN0YXRlO1xyXG4gICAgbGV0IGRpZEhhdmVNZXRhID0gKGZyb21Nb2RpZmllclN0YXRlICYgTUVUQSkgPT09IE1FVEE7XHJcbiAgICBsZXQgd2lsbEhhdmVNZXRhID0gKHRvTW9kaWZpZXJTdGF0ZSAmIE1FVEEpID09PSBNRVRBO1xyXG4gICAgbGV0IGRpZEhhdmVDdHJsID0gKGZyb21Nb2RpZmllclN0YXRlICYgQ1RSTCkgPT09IENUUkw7XHJcbiAgICBsZXQgd2lsbEhhdmVDdHJsID0gKHRvTW9kaWZpZXJTdGF0ZSAmIENUUkwpID09PSBDVFJMO1xyXG4gICAgbGV0IGRpZEhhdmVTaGlmdCA9IChmcm9tTW9kaWZpZXJTdGF0ZSAmIFNISUZUKSA9PT0gU0hJRlQ7XHJcbiAgICBsZXQgd2lsbEhhdmVTaGlmdCA9ICh0b01vZGlmaWVyU3RhdGUgJiBTSElGVCkgPT09IFNISUZUO1xyXG4gICAgbGV0IGRpZEhhdmVBbHQgPSAoZnJvbU1vZGlmaWVyU3RhdGUgJiBBTFQpID09PSBBTFQ7XHJcbiAgICBsZXQgd2lsbEhhdmVBbHQgPSAodG9Nb2RpZmllclN0YXRlICYgQUxUKSA9PT0gQUxUO1xyXG5cclxuICAgIGNvbnN0IGluY2x1ZGVLZXlVcCA9IGV2ZW50cyAmIEtleUV2ZW50cy5VUDtcclxuICAgIGNvbnN0IGluY2x1ZGVLZXlEb3duID0gZXZlbnRzICYgS2V5RXZlbnRzLkRPV047XHJcblxyXG4gICAgaWYgKGluY2x1ZGVLZXlVcCAmJiBkaWRIYXZlTWV0YSA9PT0gdHJ1ZSAmJiB3aWxsSGF2ZU1ldGEgPT09IGZhbHNlKSB7XHJcbiAgICAgIC8vIFJlbGVhc2UgdGhlIG1ldGEga2V5LlxyXG4gICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSAmPSB+TUVUQTtcclxuICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoXHJcbiAgICAgICAgICAna2V5dXAnLFxyXG4gICAgICAgICAgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5NRVRBKSxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVkZUtleVVwICYmIGRpZEhhdmVDdHJsID09PSB0cnVlICYmIHdpbGxIYXZlQ3RybCA9PT0gZmFsc2UpIHtcclxuICAgICAgLy8gUmVsZWFzZSB0aGUgY3RybCBrZXkuXHJcbiAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlICY9IH5DVFJMO1xyXG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZShcclxuICAgICAgICAgICdrZXl1cCcsXHJcbiAgICAgICAgICBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLkNUUkwpLFxyXG4gICAgICAgICAgdGFyZ2V0XHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmNsdWRlS2V5VXAgJiYgZGlkSGF2ZVNoaWZ0ID09PSB0cnVlICYmIHdpbGxIYXZlU2hpZnQgPT09IGZhbHNlKSB7XHJcbiAgICAgIC8vIFJlbGVhc2UgdGhlIHNoaWZ0IGtleS5cclxuICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgJj0gflNISUZUO1xyXG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZShcclxuICAgICAgICAgICdrZXl1cCcsXHJcbiAgICAgICAgICBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLlNISUZUKSxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVkZUtleVVwICYmIGRpZEhhdmVBbHQgPT09IHRydWUgJiYgd2lsbEhhdmVBbHQgPT09IGZhbHNlKSB7XHJcbiAgICAgIC8vIFJlbGVhc2UgdGhlIGFsdCBrZXkuXHJcbiAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlICY9IH5BTFQ7XHJcbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgIHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKFxyXG4gICAgICAgICAgJ2tleXVwJyxcclxuICAgICAgICAgIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuQUxUKSxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVkZUtleURvd24gJiYgZGlkSGF2ZU1ldGEgPT09IGZhbHNlICYmIHdpbGxIYXZlTWV0YSA9PT0gdHJ1ZSkge1xyXG4gICAgICAvLyBQcmVzcyB0aGUgbWV0YSBrZXkuXHJcbiAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlIHw9IE1FVEE7XHJcbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgIHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKFxyXG4gICAgICAgICAgJ2tleWRvd24nLFxyXG4gICAgICAgICAgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5NRVRBKSxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVkZUtleURvd24gJiYgZGlkSGF2ZUN0cmwgPT09IGZhbHNlICYmIHdpbGxIYXZlQ3RybCA9PT0gdHJ1ZSkge1xyXG4gICAgICAvLyBQcmVzcyB0aGUgY3RybCBrZXkuXHJcbiAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlIHw9IENUUkw7XHJcbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgIHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKFxyXG4gICAgICAgICAgJ2tleWRvd24nLFxyXG4gICAgICAgICAgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5DVFJMKSxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVkZUtleURvd24gJiYgZGlkSGF2ZVNoaWZ0ID09PSBmYWxzZSAmJiB3aWxsSGF2ZVNoaWZ0ID09PSB0cnVlKSB7XHJcbiAgICAgIC8vIFByZXNzIHRoZSBzaGlmdCBrZXkuXHJcbiAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlIHw9IFNISUZUO1xyXG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZShcclxuICAgICAgICAgICdrZXlkb3duJyxcclxuICAgICAgICAgIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuU0hJRlQpLFxyXG4gICAgICAgICAgdGFyZ2V0XHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmNsdWRlS2V5RG93biAmJiBkaWRIYXZlQWx0ID09PSBmYWxzZSAmJiB3aWxsSGF2ZUFsdCA9PT0gdHJ1ZSkge1xyXG4gICAgICAvLyBQcmVzcyB0aGUgYWx0IGtleS5cclxuICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgfD0gQUxUO1xyXG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZShcclxuICAgICAgICAgICdrZXlkb3duJyxcclxuICAgICAgICAgIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuQUxUKSxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VycmVudE1vZGlmaWVyU3RhdGUgIT09IHRvTW9kaWZpZXJTdGF0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYGludGVybmFsIGVycm9yLCBleHBlY3RlZCBtb2RpZmllciBzdGF0ZTogJHt0b01vZGlmaWVyU3RhdGV9YCArXHJcbiAgICAgICAgYCwgZ290OiAke2N1cnJlbnRNb2RpZmllclN0YXRlfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGtleXN0cm9rZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGFjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cclxuICAgKiBAcmV0dXJuIHs/S2V5c3Ryb2tlfVxyXG4gICAqL1xyXG4gIGtleXN0cm9rZUZvckFjdGlvbiAoYWN0aW9uKSB7XHJcbiAgICBsZXQga2V5Q29kZSA9IG51bGw7XHJcbiAgICBsZXQgbW9kaWZpZXJzID0gMDtcclxuXHJcbiAgICAvLyBOb3RlOiB3aGVuIGl0IGNvbWVzIHRvIGEgc2luZ2xlIGNoYXJhY3RlciBhcyAnKycsXHJcbiAgICAvLyBzaG91bGQgbm90IHRha2UgaXQgYXMgYSBrZXkgY29tYmluaWF0aW9uIChubyBhY3Rpb24uc3BsaXQpXHJcbiAgICBsZXQgcGFydHMgPSBhY3Rpb24ubGVuZ3RoID09PSAxID8gW2FjdGlvbl0gOiBhY3Rpb24uc3BsaXQoJysnKTtcclxuICAgIGxldCBsYXN0UGFydCA9IHBhcnRzLnBvcCgpO1xyXG5cclxuICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcclxuICAgICAgc3dpdGNoIChwYXJ0LnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlICdDVFJMJzpcclxuICAgICAgICAgIG1vZGlmaWVycyB8PSBDVFJMO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnTUVUQSc6XHJcbiAgICAgICAgICBtb2RpZmllcnMgfD0gTUVUQTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0FMVCc6XHJcbiAgICAgICAgICBtb2RpZmllcnMgfD0gQUxUO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnU0hJRlQnOlxyXG4gICAgICAgICAgbW9kaWZpZXJzIHw9IFNISUZUO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3BhcnRzJywgcGFydHMpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluIFwiJHthY3Rpb259XCIsIGludmFsaWQgbW9kaWZpZXI6ICR7cGFydH1gKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGxhc3RQYXJ0LnRvVXBwZXJDYXNlKCkgaW4gdGhpcy5fYWN0aW9uS2V5Q29kZU1hcCkge1xyXG4gICAgICBrZXlDb2RlID0gdGhpcy5fYWN0aW9uS2V5Q29kZU1hcFtsYXN0UGFydC50b1VwcGVyQ2FzZSgpXTtcclxuICAgIH0gZWxzZSBpZiAobGFzdFBhcnQubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGxldCBsYXN0UGFydEtleXN0cm9rZSA9IHRoaXMua2V5c3Ryb2tlRm9yQ2hhckNvZGUobGFzdFBhcnQuY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgIGlmICghbGFzdFBhcnRLZXlzdHJva2UpIHJldHVybiBudWxsXHJcblxyXG4gICAgICBtb2RpZmllcnMgfD0gbGFzdFBhcnRLZXlzdHJva2UubW9kaWZpZXJzO1xyXG4gICAgICBrZXlDb2RlID0gbGFzdFBhcnRLZXlzdHJva2Uua2V5Q29kZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW4gXCIke2FjdGlvbn1cIiwgaW52YWxpZCBhY3Rpb246ICR7bGFzdFBhcnR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBLZXlzdHJva2UobW9kaWZpZXJzLCBrZXlDb2RlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGtleXN0cm9rZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiBjaGFyYWN0ZXIgY29kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyQ29kZVxyXG4gICAqIEByZXR1cm4gez9LZXlzdHJva2V9XHJcbiAgICovXHJcbiAga2V5c3Ryb2tlRm9yQ2hhckNvZGUgKGNoYXJDb2RlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2hhckNvZGVLZXlDb2RlTWFwW2NoYXJDb2RlXSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB0YXJnZXRDYW5SZWNlaXZlVGV4dElucHV0ICh0YXJnZXQpIHtcclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNFZGl0YWJsZSh0YXJnZXQpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgVVNfRU5HTElTSF9DSEFSQ09ERV9LRVlDT0RFX01BUCA9IHtcclxuICAzMjogbmV3IEtleXN0cm9rZSgwLCAzMiksIC8vIDxzcGFjZT5cclxuICAzMzogbmV3IEtleXN0cm9rZShTSElGVCwgNDkpLCAvLyAhXHJcbiAgMzQ6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDIyMiksIC8vIFwiXHJcbiAgMzU6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDUxKSwgLy8gI1xyXG4gIDM2OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1MiksIC8vICRcclxuICAzNzogbmV3IEtleXN0cm9rZShTSElGVCwgNTMpLCAvLyAlXHJcbiAgMzg6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDU1KSwgLy8gJlxyXG4gIDM5OiBuZXcgS2V5c3Ryb2tlKDAsIDIyMiksIC8vICdcclxuICA0MDogbmV3IEtleXN0cm9rZShTSElGVCwgNTcpLCAvLyAoXHJcbiAgNDE6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDQ4KSwgLy8gKVxyXG4gIDQyOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1NiksIC8vICpcclxuICA0MzogbmV3IEtleXN0cm9rZShTSElGVCwgMTg3KSwgLy8gK1xyXG4gIDQ0OiBuZXcgS2V5c3Ryb2tlKDAsIDE4OCksIC8vICxcclxuICA0NTogbmV3IEtleXN0cm9rZSgwLCAxODkpLCAvLyAtXHJcbiAgNDY6IG5ldyBLZXlzdHJva2UoMCwgMTkwKSwgLy8gLlxyXG4gIDQ3OiBuZXcgS2V5c3Ryb2tlKDAsIDE5MSksIC8vIC9cclxuICA0ODogbmV3IEtleXN0cm9rZSgwLCA0OCksIC8vIDBcclxuICA0OTogbmV3IEtleXN0cm9rZSgwLCA0OSksIC8vIDFcclxuICA1MDogbmV3IEtleXN0cm9rZSgwLCA1MCksIC8vIDJcclxuICA1MTogbmV3IEtleXN0cm9rZSgwLCA1MSksIC8vIDNcclxuICA1MjogbmV3IEtleXN0cm9rZSgwLCA1MiksIC8vIDRcclxuICA1MzogbmV3IEtleXN0cm9rZSgwLCA1MyksIC8vIDVcclxuICA1NDogbmV3IEtleXN0cm9rZSgwLCA1NCksIC8vIDZcclxuICA1NTogbmV3IEtleXN0cm9rZSgwLCA1NSksIC8vIDdcclxuICA1NjogbmV3IEtleXN0cm9rZSgwLCA1NiksIC8vIDhcclxuICA1NzogbmV3IEtleXN0cm9rZSgwLCA1NyksIC8vIDlcclxuICA1ODogbmV3IEtleXN0cm9rZShTSElGVCwgMTg2KSwgLy8gOlxyXG4gIDU5OiBuZXcgS2V5c3Ryb2tlKDAsIDE4NiksIC8vIDtcclxuICA2MDogbmV3IEtleXN0cm9rZShTSElGVCwgMTg4KSwgLy8gPFxyXG4gIDYxOiBuZXcgS2V5c3Ryb2tlKDAsIDE4NyksIC8vID1cclxuICA2MjogbmV3IEtleXN0cm9rZShTSElGVCwgMTkwKSwgLy8gPlxyXG4gIDYzOiBuZXcgS2V5c3Ryb2tlKFNISUZULCAxOTEpLCAvLyA/XHJcbiAgNjQ6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDUwKSwgLy8gQFxyXG4gIDY1OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA2NSksIC8vIEFcclxuICA2NjogbmV3IEtleXN0cm9rZShTSElGVCwgNjYpLCAvLyBCXHJcbiAgNjc6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDY3KSwgLy8gQ1xyXG4gIDY4OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA2OCksIC8vIERcclxuICA2OTogbmV3IEtleXN0cm9rZShTSElGVCwgNjkpLCAvLyBFXHJcbiAgNzA6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDcwKSwgLy8gRlxyXG4gIDcxOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3MSksIC8vIEdcclxuICA3MjogbmV3IEtleXN0cm9rZShTSElGVCwgNzIpLCAvLyBIXHJcbiAgNzM6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDczKSwgLy8gSVxyXG4gIDc0OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3NCksIC8vIEpcclxuICA3NTogbmV3IEtleXN0cm9rZShTSElGVCwgNzUpLCAvLyBLXHJcbiAgNzY6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDc2KSwgLy8gTFxyXG4gIDc3OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3NyksIC8vIE1cclxuICA3ODogbmV3IEtleXN0cm9rZShTSElGVCwgNzgpLCAvLyBOXHJcbiAgNzk6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDc5KSwgLy8gT1xyXG4gIDgwOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4MCksIC8vIFBcclxuICA4MTogbmV3IEtleXN0cm9rZShTSElGVCwgODEpLCAvLyBRXHJcbiAgODI6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDgyKSwgLy8gUlxyXG4gIDgzOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4MyksIC8vIFNcclxuICA4NDogbmV3IEtleXN0cm9rZShTSElGVCwgODQpLCAvLyBUXHJcbiAgODU6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDg1KSwgLy8gVVxyXG4gIDg2OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4NiksIC8vIFZcclxuICA4NzogbmV3IEtleXN0cm9rZShTSElGVCwgODcpLCAvLyBXXHJcbiAgODg6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDg4KSwgLy8gWFxyXG4gIDg5OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4OSksIC8vIFlcclxuICA5MDogbmV3IEtleXN0cm9rZShTSElGVCwgOTApLCAvLyBaXHJcbiAgOTE6IG5ldyBLZXlzdHJva2UoMCwgMjE5KSwgLy8gW1xyXG4gIDkyOiBuZXcgS2V5c3Ryb2tlKDAsIDIyMCksIC8vIFxcXHJcbiAgOTM6IG5ldyBLZXlzdHJva2UoMCwgMjIxKSwgLy8gXVxyXG4gIDk0OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1NCksIC8vIF5cclxuICA5NTogbmV3IEtleXN0cm9rZShTSElGVCwgMTg5KSwgLy8gX1xyXG4gIDk2OiBuZXcgS2V5c3Ryb2tlKDAsIDE5MiksIC8vIGBcclxuICA5NzogbmV3IEtleXN0cm9rZSgwLCA2NSksIC8vIGFcclxuICA5ODogbmV3IEtleXN0cm9rZSgwLCA2NiksIC8vIGJcclxuICA5OTogbmV3IEtleXN0cm9rZSgwLCA2NyksIC8vIGNcclxuICAxMDA6IG5ldyBLZXlzdHJva2UoMCwgNjgpLCAvLyBkXHJcbiAgMTAxOiBuZXcgS2V5c3Ryb2tlKDAsIDY5KSwgLy8gZVxyXG4gIDEwMjogbmV3IEtleXN0cm9rZSgwLCA3MCksIC8vIGZcclxuICAxMDM6IG5ldyBLZXlzdHJva2UoMCwgNzEpLCAvLyBnXHJcbiAgMTA0OiBuZXcgS2V5c3Ryb2tlKDAsIDcyKSwgLy8gaFxyXG4gIDEwNTogbmV3IEtleXN0cm9rZSgwLCA3MyksIC8vIGlcclxuICAxMDY6IG5ldyBLZXlzdHJva2UoMCwgNzQpLCAvLyBqXHJcbiAgMTA3OiBuZXcgS2V5c3Ryb2tlKDAsIDc1KSwgLy8ga1xyXG4gIDEwODogbmV3IEtleXN0cm9rZSgwLCA3NiksIC8vIGxcclxuICAxMDk6IG5ldyBLZXlzdHJva2UoMCwgNzcpLCAvLyBtXHJcbiAgMTEwOiBuZXcgS2V5c3Ryb2tlKDAsIDc4KSwgLy8gblxyXG4gIDExMTogbmV3IEtleXN0cm9rZSgwLCA3OSksIC8vIG9cclxuICAxMTI6IG5ldyBLZXlzdHJva2UoMCwgODApLCAvLyBwXHJcbiAgMTEzOiBuZXcgS2V5c3Ryb2tlKDAsIDgxKSwgLy8gcVxyXG4gIDExNDogbmV3IEtleXN0cm9rZSgwLCA4MiksIC8vIHJcclxuICAxMTU6IG5ldyBLZXlzdHJva2UoMCwgODMpLCAvLyBzXHJcbiAgMTE2OiBuZXcgS2V5c3Ryb2tlKDAsIDg0KSwgLy8gdFxyXG4gIDExNzogbmV3IEtleXN0cm9rZSgwLCA4NSksIC8vIHVcclxuICAxMTg6IG5ldyBLZXlzdHJva2UoMCwgODYpLCAvLyB2XHJcbiAgMTE5OiBuZXcgS2V5c3Ryb2tlKDAsIDg3KSwgLy8gd1xyXG4gIDEyMDogbmV3IEtleXN0cm9rZSgwLCA4OCksIC8vIHhcclxuICAxMjE6IG5ldyBLZXlzdHJva2UoMCwgODkpLCAvLyB5XHJcbiAgMTIyOiBuZXcgS2V5c3Ryb2tlKDAsIDkwKSwgLy8gelxyXG4gIDEyMzogbmV3IEtleXN0cm9rZShTSElGVCwgMjE5KSwgLy8ge1xyXG4gIDEyNDogbmV3IEtleXN0cm9rZShTSElGVCwgMjIwKSwgLy8gfFxyXG4gIDEyNTogbmV3IEtleXN0cm9rZShTSElGVCwgMjIxKSwgLy8gfVxyXG4gIDEyNjogbmV3IEtleXN0cm9rZShTSElGVCwgMTkyKSAvLyB+XHJcbn07XHJcblxyXG5jb25zdCBVU19FTkdMSVNIX0FDVElPTl9LRVlDT0RFX01BUCA9IHtcclxuICBCQUNLU1BBQ0U6IDgsXHJcbiAgVEFCOiA5LFxyXG4gIEVOVEVSOiAxMyxcclxuICBTSElGVDogMTYsXHJcbiAgQ1RSTDogMTcsXHJcbiAgQUxUOiAxOCxcclxuICBQQVVTRTogMTksXHJcbiAgQ0FQU0xPQ0s6IDIwLFxyXG4gIEVTQ0FQRTogMjcsXHJcbiAgUEFHRVVQOiAzMyxcclxuICBQQUdFRE9XTjogMzQsXHJcbiAgRU5EOiAzNSxcclxuICBIT01FOiAzNixcclxuICBMRUZUOiAzNyxcclxuICBVUDogMzgsXHJcbiAgUklHSFQ6IDM5LFxyXG4gIERPV046IDQwLFxyXG4gIElOU0VSVDogNDUsXHJcbiAgREVMRVRFOiA0NixcclxuICBNRVRBOiA5MSxcclxuICBGMTogMTEyLFxyXG4gIEYyOiAxMTMsXHJcbiAgRjM6IDExNCxcclxuICBGNDogMTE1LFxyXG4gIEY1OiAxMTYsXHJcbiAgRjY6IDExNyxcclxuICBGNzogMTE4LFxyXG4gIEY4OiAxMTksXHJcbiAgRjk6IDEyMCxcclxuICBGMTA6IDEyMSxcclxuICBGMTE6IDEyMixcclxuICBGMTI6IDEyM1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgYSBrZXlib2FyZCBpbnN0YW5jZSBjb25maWd1cmVkIGFzIGEgVS5TLiBFbmdsaXNoIGtleWJvYXJkIHdvdWxkIGJlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtLZXlib2FyZH1cclxuICovXHJcbktleWJvYXJkLlVTX0VOR0xJU0ggPSBuZXcgS2V5Ym9hcmQoXHJcbiAgVVNfRU5HTElTSF9DSEFSQ09ERV9LRVlDT0RFX01BUCxcclxuICBVU19FTkdMSVNIX0FDVElPTl9LRVlDT0RFX01BUFxyXG4pO1xyXG4iLCJcclxuZXhwb3J0IGNvbnN0IGxvZ0ZhY3RvcnkgPSAoZW5hYmxlZCkgPT4ge1xyXG4gIGxldCBpc0VuYWJsZWQgPSAhIWVuYWJsZWRcclxuXHJcbiAgY29uc3Qgb2JqID0gWydsb2cnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10ucmVkdWNlKChwcmV2LCBtZXRob2QpID0+IHtcclxuICAgIHByZXZbbWV0aG9kXSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgIGlmICghaXNFbmFibGVkKSByZXR1cm5cclxuICAgICAgY29uc29sZVttZXRob2RdKChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpLCAnIC0gJywgLi4uYXJncylcclxuICAgIH1cclxuICAgIHJldHVybiBwcmV2XHJcbiAgfSwge30pXHJcblxyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKG9iai5sb2csIG9iaiwge1xyXG4gICAgZW5hYmxlOiAgICgpID0+IHsgaXNFbmFibGVkID0gdHJ1ZSB9LFxyXG4gICAgZGlzYWJsZTogICgpID0+IHsgaXNFbmFibGVkID0gZmFsc2UgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGxvZ0ZhY3RvcnkoXHJcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xyXG4pXHJcbiIsImltcG9ydCBmcyBmcm9tICcuL2ZpbGVzeXN0ZW0nXHJcbmltcG9ydCBGaWxlTWFuIGZyb20gJy4vZmlsZV9tYW4nXHJcbmltcG9ydCBFeHQgZnJvbSAnLi93ZWJfZXh0ZW5zaW9uJ1xyXG5cclxuZXhwb3J0IGNsYXNzIFNjcmVlbnNob3RNYW4gZXh0ZW5kcyBGaWxlTWFuIHtcclxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XHJcbiAgICBzdXBlcih7IC4uLm9wdHMsIGJhc2VEaXI6ICdzY3JlZW5zaG90cycgfSlcclxuICB9XHJcblxyXG4gIHdyaXRlIChmaWxlTmFtZSwgYmxvYikge1xyXG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZSh0aGlzLl9fZmlsZVBhdGgoZmlsZU5hbWUsIHRydWUpLCBibG9iKVxyXG4gIH1cclxuXHJcbiAgcmVhZCAoZmlsZU5hbWUpIHtcclxuICAgIHJldHVybiBmcy5yZWFkRmlsZSh0aGlzLl9fZmlsZVBhdGgoZmlsZU5hbWUpLCAnQXJyYXlCdWZmZXInKVxyXG4gIH1cclxuXHJcbiAgcmVhZEFzRGF0YVVSTCAoZmlsZU5hbWUpIHtcclxuICAgIHJldHVybiBmcy5yZWFkRmlsZSh0aGlzLl9fZmlsZVBhdGgoZmlsZU5hbWUpLCAnRGF0YVVSTCcpXHJcbiAgfVxyXG5cclxuICBnZXRMaW5rIChmaWxlTmFtZSkge1xyXG4gICAgaWYgKCFFeHQuaXNGaXJlZm94KCkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3VwZXIuZ2V0TGluayhmaWxlTmFtZSkgKyAnPycgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcclxuXHJcbiAgICAvLyBOb3RlOiBFeGNlcHQgZm9yIENocm9tZSwgdGhlIGZpbGVzeXN0ZW0gQVBJIHdlIHVzZSBpcyBhIHBvbHlmaWxsIGZyb20gaWRiLmZpbGVzeXN0ZW0uanNcclxuICAgIC8vIGlkYi5maWxlc3lzdGVtLmpzIHdvcmtzIGdyZWF0IGJ1dCB0aGUgb25seSBwcm9ibGVtIGlzIHRoYXQgeW91IGNhbid0IHVzZSAnZmlsZXN5c3RlbTonIHNjaGVtYSB0byByZXRyaWV2ZSB0aGF0IGZpbGVcclxuICAgIC8vIHNvIGhlcmUsIHdlIGhhdmUgdG8gY29udmVydCB0aGUgZmlsZSB0byBkYXRhIHVybFxyXG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlKHRoaXMuX19maWxlUGF0aChmaWxlTmFtZSksICdEYXRhVVJMJylcclxuICB9XHJcbn1cclxuXHJcbmxldCBtYW5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JlZW5zaG90TWFuIChvcHRzID0ge30pIHtcclxuICBpZiAob3B0cykge1xyXG4gICAgbWFuID0gbmV3IFNjcmVlbnNob3RNYW4ob3B0cylcclxuICB9XHJcblxyXG4gIGlmICghbWFuKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjcmVlbnNob3QgbWFuYWdlciBub3QgaW5pdGlhbGl6ZWQnKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1hblxyXG59XHJcbiIsImltcG9ydCAqIGFzIEtleXNpbSBmcm9tICcuL2xpYi9rZXlzaW0nXHJcbmltcG9ydCB7IHNwbGl0S2VlcCB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2cnXHJcblxyXG5sZXQga2V5Ym9hcmQgPSBLZXlzaW0uS2V5Ym9hcmQuVVNfRU5HTElTSFxyXG5cclxuY29uc3QgZmluZFBhcmVudEJ5VGFnID0gKGVsLCB0YWcpID0+IHtcclxuICBsZXQgcCA9IGVsXHJcblxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gIHdoaWxlIChwID0gcC5wYXJlbnROb2RlKSB7XHJcbiAgICBpZiAocC50YWdOYW1lID09PSB0YWcudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICByZXR1cm4gcFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGxcclxufVxyXG5cclxuY29uc3Qgc3BsaXRTdHJpbmdUb0NoYXJzID0gKHN0cikgPT4ge1xyXG4gIGNvbnN0IHNwZWNpYWxLZXlzID0gW1xyXG4gICAgJ0tFWV9MRUZUJywgJ0tFWV9VUCcsICdLRVlfUklHSFQnLCAnS0VZX0RPV04nLFxyXG4gICAgJ0tFWV9QR1VQJywgJ0tFWV9QQUdFX1VQJywgJ0tFWV9QR0ROJywgJ0tFWV9QQUdFX0RPV04nLFxyXG4gICAgJ0tFWV9CS1NQJywgJ0tFWV9CQUNLU1BBQ0UnLCAnS0VZX0RFTCcsICdLRVlfREVMRVRFJyxcclxuICAgICdLRVlfRU5URVInLCAnS0VZX1RBQidcclxuICBdXHJcbiAgY29uc3QgcmVnICAgPSBuZXcgUmVnRXhwKGBcXFxcJFxcXFx7KCR7c3BlY2lhbEtleXMuam9pbignfCcpfSlcXFxcfWApXHJcbiAgY29uc3QgcGFydHMgPSBzcGxpdEtlZXAocmVnLCBzdHIpXHJcblxyXG4gIHJldHVybiBwYXJ0cy5yZWR1Y2UoKHByZXYsIGN1cikgPT4ge1xyXG4gICAgaWYgKHJlZy50ZXN0KGN1cikpIHtcclxuICAgICAgcHJldi5wdXNoKGN1cilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByZXYgPSBwcmV2LmNvbmNhdChjdXIuc3BsaXQoJycpKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcmV2XHJcbiAgfSwgW10pXHJcbn1cclxuXHJcbmNvbnN0IGdldEtleVN0cm9rZUFjdGlvbiA9IChzdHIpID0+IHtcclxuICBjb25zdCByZWcgPSAvXlxcJFxceyhbXn1dKylcXH0kL1xyXG4gIGxldCBtYXRjaFxyXG5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cclxuICBpZiAobWF0Y2ggPSBzdHIubWF0Y2gocmVnKSkge1xyXG4gICAgc3dpdGNoIChtYXRjaFsxXSkge1xyXG4gICAgICBjYXNlICdLRVlfTEVGVCc6XHJcbiAgICAgICAgcmV0dXJuICdMRUZUJ1xyXG5cclxuICAgICAgY2FzZSAnS0VZX1VQJzpcclxuICAgICAgICByZXR1cm4gJ1VQJ1xyXG5cclxuICAgICAgY2FzZSAnS0VZX1JJR0hUJzpcclxuICAgICAgICByZXR1cm4gJ1JJR0hUJ1xyXG5cclxuICAgICAgY2FzZSAnS0VZX0RPV04nOlxyXG4gICAgICAgIHJldHVybiAnRE9XTidcclxuXHJcbiAgICAgIGNhc2UgJ0tFWV9QR1VQJzpcclxuICAgICAgY2FzZSAnS0VZX1BBR0VfVVAnOlxyXG4gICAgICAgIHJldHVybiAnUEFHRVVQJ1xyXG5cclxuICAgICAgY2FzZSAnS0VZX1BHRE4nOlxyXG4gICAgICBjYXNlICdLRVlfUEFHRV9ET1dOJzpcclxuICAgICAgICByZXR1cm4gJ1BBR0VET1dOJ1xyXG5cclxuICAgICAgY2FzZSAnS0VZX0JLU1AnOlxyXG4gICAgICBjYXNlICdLRVlfQkFDS1NQQUNFJzpcclxuICAgICAgICByZXR1cm4gJ0JBQ0tTUEFDRSdcclxuXHJcbiAgICAgIGNhc2UgJ0tFWV9ERUwnOlxyXG4gICAgICBjYXNlICdLRVlfREVMRVRFJzpcclxuICAgICAgICByZXR1cm4gJ0RFTEVURSdcclxuXHJcbiAgICAgIGNhc2UgJ0tFWV9FTlRFUic6XHJcbiAgICAgICAgcmV0dXJuICdFTlRFUidcclxuXHJcbiAgICAgIGNhc2UgJ0tFWV9UQUInOlxyXG4gICAgICAgIHJldHVybiAnVEFCJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0clxyXG59XHJcblxyXG5jb25zdCBpc0VkaXRhYmxlID0gKGVsKSA9PiB7XHJcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZSgncmVhZG9ubHknKSAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlXHJcbiAgY29uc3QgdGFnICAgPSBlbC50YWdOYW1lLnRvVXBwZXJDYXNlKClcclxuICBjb25zdCB0eXBlICA9IChlbC50eXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpXHJcbiAgY29uc3QgZWRpdGFibGVUeXBlcyA9IFtcclxuICAgICd0ZXh0JyxcclxuICAgICdzZWFyY2gnLFxyXG4gICAgJ3RlbCcsXHJcbiAgICAndXJsJyxcclxuICAgICdlbWFpbCcsXHJcbiAgICAncGFzc3dvcmQnLFxyXG4gICAgJ251bWJlcidcclxuICBdXHJcblxyXG4gIGlmICh0YWcgPT09ICdURVhUQVJFQScpIHJldHVybiB0cnVlXHJcbiAgaWYgKHRhZyA9PT0gJ0lOUFVUJyAmJiBlZGl0YWJsZVR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xKSAgcmV0dXJuIHRydWVcclxuXHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbmNvbnN0IG1heWJlRWRpdFRleHQgPSAodGFyZ2V0LCBjKSA9PiB7XHJcbiAgaWYgKCFpc0VkaXRhYmxlKHRhcmdldCkpICByZXR1cm5cclxuICBpZiAoYy5sZW5ndGggPT09IDEpIHtcclxuICAgIGlmICghaXNOaWwodGFyZ2V0LnNlbGVjdGlvblN0YXJ0KSkge1xyXG4gICAgICBjb25zdCBsYXN0U3RhcnQgPSB0YXJnZXQuc2VsZWN0aW9uU3RhcnRcclxuICAgICAgdGFyZ2V0LnZhbHVlICAgID0gdGFyZ2V0LnZhbHVlLnN1YnN0cmluZygwLCB0YXJnZXQuc2VsZWN0aW9uU3RhcnQpICsgYyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC52YWx1ZS5zdWJzdHJpbmcodGFyZ2V0LnNlbGVjdGlvbkVuZClcclxuXHJcbiAgICAgIHNldFNlbGVjdGlvbih0YXJnZXQsIGxhc3RTdGFydCArIDEpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0YXJnZXQudmFsdWUgICAgPSB0YXJnZXQudmFsdWUgKyBjXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHN3aXRjaCAoYykge1xyXG4gICAgICBjYXNlICdFTlRFUic6XHJcbiAgICAgICAgdGFyZ2V0LnZhbHVlID0gdGFyZ2V0LnZhbHVlICsgJ1xcbidcclxuICAgICAgICBzZXRTZWxlY3Rpb24odGFyZ2V0LCB0YXJnZXQudmFsdWUubGVuZ3RoKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ1RBQic6XHJcbiAgICAgICAgdGFyZ2V0LnZhbHVlID0gdGFyZ2V0LnZhbHVlICsgJ1xcdCdcclxuICAgICAgICBzZXRTZWxlY3Rpb24odGFyZ2V0LCB0YXJnZXQudmFsdWUubGVuZ3RoKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ0xFRlQnOlxyXG4gICAgICAgIHNldFNlbGVjdGlvbih0YXJnZXQsIHRhcmdldC5zZWxlY3Rpb25TdGFydCAtIDEpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnUklHSFQnOlxyXG4gICAgICAgIHNldFNlbGVjdGlvbih0YXJnZXQsIHRhcmdldC5zZWxlY3Rpb25FbmQgKyAxKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ0JBQ0tTUEFDRSc6IHtcclxuICAgICAgICBjb25zdCBwb3MgICAgPSAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0XHJcbiAgICAgICAgdGFyZ2V0LnZhbHVlID0gIHRhcmdldC52YWx1ZS5zdWJzdHJpbmcoMCwgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0IC0gMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUuc3Vic3RyaW5nKHRhcmdldC5zZWxlY3Rpb25FbmQpXHJcbiAgICAgICAgc2V0U2VsZWN0aW9uKHRhcmdldCwgcG9zIC0gMSlcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgJ0RFTEVURSc6IHtcclxuICAgICAgICBjb25zdCBwb3MgICAgPSAgdGFyZ2V0LnNlbGVjdGlvbkVuZFxyXG4gICAgICAgIHRhcmdldC52YWx1ZSA9ICB0YXJnZXQudmFsdWUuc3Vic3RyaW5nKDAsIHRhcmdldC5zZWxlY3Rpb25TdGFydCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUuc3Vic3RyaW5nKHRhcmdldC5zZWxlY3Rpb25FbmQgKyAxKVxyXG4gICAgICAgIHNldFNlbGVjdGlvbih0YXJnZXQsIHBvcylcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBtYXliZVN1Ym1pdEZvcm0gPSAodGFyZ2V0LCBrZXkpID0+IHtcclxuICBpZiAoa2V5ICE9PSAnRU5URVInKSAgICAgIHJldHVyblxyXG4gIGlmICghaXNFZGl0YWJsZSh0YXJnZXQpKSAgcmV0dXJuXHJcblxyXG4gIGNvbnN0IGZvcm0gPSBmaW5kUGFyZW50QnlUYWcodGFyZ2V0LCAnRk9STScpXHJcbiAgaWYgKCFmb3JtKSAgICAgICAgICAgICAgICByZXR1cm5cclxuXHJcbiAgZm9ybS5zdWJtaXQoKVxyXG59XHJcblxyXG5jb25zdCBpc05pbCA9ICh2YWwpID0+IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZFxyXG5cclxuY29uc3Qgc2V0U2VsZWN0aW9uID0gKCRlbCwgc3RhcnQsIGVuZCkgPT4ge1xyXG4gIC8vIE5vdGU6IElucHV0cyBsaWtlIG51bWJlciBhbmQgZW1haWwsIGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25FbmRcclxuICAvLyBmb3Igc2FmZXR5LCBtYWtlIHN1cmUgdGhvc2UgdmFsdWVzIGFyZSBub3QgbnVsbCBvciB1bmRlZmluZWQgKGluZmVycyB0aGF0IGl0J3MgYXZhaWxhYmxlKVxyXG4gIGlmICghaXNOaWwoJGVsLnNlbGVjdGlvblN0YXJ0KSkge1xyXG4gICAgJGVsLnNlbGVjdGlvblN0YXJ0ID0gc3RhcnRcclxuICB9XHJcblxyXG4gIGlmICghaXNOaWwoJGVsLnNlbGVjdGlvbkVuZCkpIHtcclxuICAgICRlbC5zZWxlY3Rpb25FbmQgPSAoZW5kICE9PSB1bmRlZmluZWQgPyBlbmQgOiBzdGFydClcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHJlcGxhY2VBY3Rpb25LZXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGNvbnN0IG1hcHBpbmcgPSB7XHJcbiAgICAwOiAgbnVsbCwgICAgLy8gdGhlIE5VTEwgY2hhcmFjdGVyXHJcbiAgICA4OiAgJ0JBQ0tTUEFDRScsXHJcbiAgICA5OiAgJ1RBQicsXHJcbiAgICAxMDogJ0VOVEVSJywgLy8gXFxuICBuZXcgbGluZVxyXG4gICAgMTE6ICBudWxsLCAgIC8vIFxcdiAgdmVydGljYWwgdGFiXHJcbiAgICAxMjogIG51bGwsICAgLy8gXFxmICBmb3JtIGZlZWRcclxuICAgIDEzOiAgbnVsbCAgICAvLyBcXHIgIGNhcnJpYWdlIHJldHVyblxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChjKSA9PiB7XHJcbiAgICAvLyBOb3RlOiBpdCBtZWFucyBpdCdzIGFscmVhZHkga2V5IHN0cm9rZSBhY3Rpb25cclxuICAgIGlmIChjLmxlbmd0aCA+IDEpIHJldHVybiBjXHJcbiAgICByZXR1cm4gbWFwcGluZ1tjLmNoYXJDb2RlQXQoMCldIHx8IGNcclxuICB9XHJcbn0pKClcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlbmRLZXlzICh0YXJnZXQsIHN0ciwgbm9TcGVjaWFsS2V5cykge1xyXG4gIGNvbnN0IHJhd0NoYXJzICA9IG5vU3BlY2lhbEtleXMgPyBzdHIuc3BsaXQoJycpIDogc3BsaXRTdHJpbmdUb0NoYXJzKHN0cilcclxuICBjb25zdCBjaGFycyAgICAgPSByYXdDaGFycy5tYXAocmVwbGFjZUFjdGlvbktleSkuZmlsdGVyKHggPT4geCAmJiB4Lmxlbmd0aClcclxuXHJcbiAgdGFyZ2V0LmZvY3VzKClcclxuICBpZiAodGFyZ2V0LnZhbHVlKSB7XHJcbiAgICBzZXRTZWxlY3Rpb24odGFyZ2V0LCB0YXJnZXQudmFsdWUubGVuZ3RoKVxyXG4gIH1cclxuXHJcbiAgY2hhcnMuZm9yRWFjaChjID0+IHtcclxuICAgIGNvbnN0IGFjdGlvbiA9IGdldEtleVN0cm9rZUFjdGlvbihjKVxyXG5cclxuICAgIG1heWJlRWRpdFRleHQodGFyZ2V0LCBhY3Rpb24pXHJcbiAgICAvLyBOb3RlOiBUaGlzIGxpbmUgd2lsbCB0YWtlIGNhcmUgb2YgS0VZRE9XTiBLRVlQUkVTUyBLRVlVUCBhbmQgVEVYVElOUFVUXHJcbiAgICBrZXlib2FyZC5kaXNwYXRjaEV2ZW50c0ZvckFjdGlvbihhY3Rpb24sIHRhcmdldClcclxuXHJcbiAgICBpZiAoIW5vU3BlY2lhbEtleXMpIHtcclxuICAgICAgbWF5YmVTdWJtaXRGb3JtKHRhcmdldCwgYWN0aW9uKVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuIiwiaW1wb3J0IEV4dCBmcm9tICcuLi93ZWJfZXh0ZW5zaW9uJ1xyXG5cclxuY29uc3QgbG9jYWwgPSBFeHQuc3RvcmFnZS5sb2NhbFxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGdldDogKGtleSkgPT4ge1xyXG4gICAgcmV0dXJuIGxvY2FsLmdldChrZXkpLnRoZW4ob2JqID0+IG9ialtrZXldKVxyXG4gIH0sXHJcblxyXG4gIHNldDogKGtleSwgdmFsdWUpID0+IHtcclxuICAgIHJldHVybiBsb2NhbC5zZXQoe1trZXldOiB2YWx1ZX0pLnRoZW4oKCkgPT4gdHJ1ZSlcclxuICB9LFxyXG5cclxuICByZW1vdmU6IChrZXkpID0+IHtcclxuICAgIHJldHVybiBsb2NhbC5yZW1vdmUoa2V5KS50aGVuKCgpID0+IHRydWUpXHJcbiAgfSxcclxuXHJcbiAgY2xlYXI6ICgpID0+IHtcclxuICAgIHJldHVybiBsb2NhbC5jbGVhcigpLnRoZW4oKCkgPT4gdHJ1ZSlcclxuICB9LFxyXG5cclxuICBhZGRMaXN0ZW5lcjogKGZuKSA9PiB7XHJcbiAgICBFeHQuc3RvcmFnZS5vbkNoYW5nZWQuYWRkTGlzdGVuZXIoKGNoYW5nZXMsIGFyZWFOYW1lKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5tYXAoa2V5ID0+ICh7IC4uLmNoYW5nZXNba2V5XSwga2V5IH0pKVxyXG4gICAgICBmbihsaXN0KVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuIiwiXHJcbmltcG9ydCBFeHRTdG9yYWdlIGZyb20gJy4vZXh0X3N0b3JhZ2UnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBFeHRTdG9yYWdlXHJcbiIsIlxyXG4vLyBkZWxheSB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uIGFuZCByZXR1cm4gYSBwcm9taXNlXHJcbmV4cG9ydCBjb25zdCBkZWxheSA9IChmbiwgdGltZW91dCkgPT4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXNvbHZlKGZuKCkpXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZWplY3QoZSlcclxuICAgICAgfVxyXG4gICAgfSwgdGltZW91dClcclxuICB9KVxyXG59XHJcblxyXG4vLyBQb2xsIG9uIHdoYXRldmVyIHlvdSB3YW50IHRvIGNoZWNrLCBhbmQgd2lsbCB0aW1lIG91dCBhZnRlciBhIHNwZWNpZmljIGR1cmF0aW9uXHJcbi8vIGBjaGVja2Agc2hvdWxkIHJldHVybiBgeyBwYXNzOiBCb29sZWFuLCByZXN1bHQ6IEFueSB9YFxyXG4vLyBgbmFtZWAgaXMgZm9yIGEgbWVhbmluZ2Z1bCBlcnJvciBtZXNzYWdlXHJcbmV4cG9ydCBjb25zdCB1bnRpbCA9IChuYW1lLCBjaGVjaywgaW50ZXJ2YWwgPSAxMDAwLCBleHBpcmUgPSAxMDAwMCwgZXJyb3JNc2cpID0+IHtcclxuICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKClcclxuICBjb25zdCBnbyAgICA9ICgpID0+IHtcclxuICAgIGlmIChleHBpcmUgJiYgbmV3IERhdGUoKSAtIHN0YXJ0ID49IGV4cGlyZSkge1xyXG4gICAgICBjb25zdCBtc2cgPSBlcnJvck1zZyB8fCBgdW50aWw6ICR7bmFtZX0gZXhwaXJlZCFgXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBwYXNzLCByZXN1bHQgfSA9IGNoZWNrKClcclxuXHJcbiAgICBpZiAocGFzcykgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpXHJcbiAgICByZXR1cm4gZGVsYXkoZ28sIGludGVydmFsKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlc29sdmUoZ28oKSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmVqZWN0KGUpXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHJhbmdlID0gKHN0YXJ0LCBlbmQsIHN0ZXAgPSAxKSA9PiB7XHJcbiAgY29uc3QgcmV0ID0gW11cclxuXHJcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IHN0ZXApIHtcclxuICAgIHJldC5wdXNoKGkpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIGN1cnJ5IHZlcnNpb24gb2YgdGhlIHBhc3NlZCBpbiBmdW5jdGlvblxyXG5leHBvcnQgY29uc3QgcGFydGlhbCA9IChmbikgPT4ge1xyXG4gIGNvbnN0IGxlbiA9IGZuLmxlbmd0aFxyXG4gIGxldCBhcmJpdGFyeVxyXG5cclxuICBhcmJpdGFyeSA9IChjdXJBcmdzLCBsZWZ0QXJnQ250KSA9PiAoLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IGxlZnRBcmdDbnQpIHtcclxuICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGN1ckFyZ3MuY29uY2F0KGFyZ3MpKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcmJpdGFyeShjdXJBcmdzLmNvbmNhdChhcmdzKSwgbGVmdEFyZ0NudCAtIGFyZ3MubGVuZ3RoKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFyYml0YXJ5KFtdLCBsZW4pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VSaWdodCA9IChmbiwgaW5pdGlhbCwgbGlzdCkgPT4ge1xyXG4gIHZhciByZXQgPSBpbml0aWFsXHJcblxyXG4gIGZvciAobGV0IGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICByZXQgPSBmbihsaXN0W2ldLCByZXQpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbi8vIGNvbXBvc2UgZnVuY3Rpb25zIGludG8gb25lXHJcbmV4cG9ydCBjb25zdCBjb21wb3NlID0gKC4uLmFyZ3MpID0+IHtcclxuICByZXR1cm4gcmVkdWNlUmlnaHQoKGN1ciwgcHJldikgPT4ge1xyXG4gICAgcmV0dXJuIHggPT4gY3VyKHByZXYoeCkpXHJcbiAgfSwgeCA9PiB4LCBhcmdzKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgbWFwID0gcGFydGlhbCgoZm4sIGxpc3QpID0+IHtcclxuICB2YXIgcmVzdWx0ID0gW11cclxuXHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHJlc3VsdC5wdXNoKGZuKGxpc3RbaV0pKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdFxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IG9uID0gcGFydGlhbCgoa2V5LCBmbiwgZGljdCkgPT4ge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGRpY3QpKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAuLi5kaWN0LnNsaWNlKDAsIGtleSksXHJcbiAgICAgIGZuKGRpY3Rba2V5XSksXHJcbiAgICAgIC4uLmRpY3Quc2xpY2Uoa2V5ICsgMSlcclxuICAgIF1cclxuICB9XHJcblxyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkaWN0LCB7XHJcbiAgICBba2V5XTogZm4oZGljdFtrZXldKVxyXG4gIH0pXHJcbn0pXHJcblxyXG4vLyBpbW11dGFibHkgdXBkYXRlIGFueSBwYXJ0IGluIGFuIG9iamVjdFxyXG5leHBvcnQgY29uc3QgdXBkYXRlSW4gPSBwYXJ0aWFsKChrZXlzLCBmbiwgb2JqKSA9PiB7XHJcbiAgY29uc3QgdXBkYXRlciA9IGNvbXBvc2UuYXBwbHkobnVsbCwga2V5cy5tYXAoa2V5ID0+IG9uKGtleSkpKVxyXG4gIHJldHVybiB1cGRhdGVyKGZuKShvYmopXHJcbn0pXHJcblxyXG4vLyBpbW11dGFibHkgc2V0IGFueSBwYXJ0IGluIGFuIG9iamVjdFxyXG4vLyBhIHJlc3RyaWN0ZWQgdmVyc2lvbiBvZiB1cGRhdGVJblxyXG5leHBvcnQgY29uc3Qgc2V0SW4gPSBwYXJ0aWFsKChrZXlzLCB2YWx1ZSwgb2JqKSA9PiB7XHJcbiAgY29uc3QgdXBkYXRlciA9IGNvbXBvc2UuYXBwbHkobnVsbCwga2V5cy5tYXAoa2V5ID0+IG9uKGtleSkpKVxyXG4gIHJldHVybiB1cGRhdGVyKCgpID0+IHZhbHVlKShvYmopXHJcbn0pXHJcblxyXG4vLyByZXR1cm4gcGFydCBvZiB0aGUgb2JqZWN0IHdpdGggYSBmZXcga2V5cyBkZWVwIGluc2lkZVxyXG5leHBvcnQgY29uc3QgZ2V0SW4gPSBwYXJ0aWFsKChrZXlzLCBvYmopID0+IHtcclxuICByZXR1cm4ga2V5cy5yZWR1Y2UoKHByZXYsIGtleSkgPT4ge1xyXG4gICAgaWYgKCFwcmV2KSAgcmV0dXJuIHByZXZcclxuICAgIHJldHVybiBwcmV2W2tleV1cclxuICB9LCBvYmopXHJcbn0pXHJcblxyXG4vLyByZXR1cm4gdGhlIHBhc3NlZCBpbiBvYmplY3Qgd2l0aCBvbmx5IGNlcnRhaW5zIGtleXNcclxuZXhwb3J0IGNvbnN0IHBpY2sgPSAoa2V5cywgb2JqKSA9PiB7XHJcbiAgcmV0dXJuIGtleXMucmVkdWNlKChwcmV2LCBrZXkpID0+IHtcclxuICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHByZXZba2V5XSA9IG9ialtrZXldXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJldlxyXG4gIH0sIHt9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdWlkID0gKCkgPT4ge1xyXG4gIHJldHVybiAnJyArIChuZXcgRGF0ZSgpICogMSkgKyAnLicgK1xyXG4gICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCkudG9TdHJpbmcoMTYpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gKGxpc3QpID0+IHtcclxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBsaXN0KTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNwbGl0SW50b1R3byA9IChwYXR0ZXJuLCBzdHIpID0+IHtcclxuICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKHBhdHRlcm4pXHJcbiAgaWYgKGluZGV4ID09PSAtMSkgIHJldHVybiBbc3RyXVxyXG5cclxuICByZXR1cm4gW1xyXG4gICAgc3RyLnN1YnN0cigwLCBpbmRleCksXHJcbiAgICBzdHIuc3Vic3RyKGluZGV4ICsgMSlcclxuICBdXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjbiA9ICguLi5hcmdzKSA9PiB7XHJcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKChwcmV2LCBjdXIpID0+IHtcclxuICAgIGlmICh0eXBlb2YgY3VyID09PSAnc3RyaW5nJykge1xyXG4gICAgICBwcmV2LnB1c2goY3VyKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgT2JqZWN0LmtleXMoY3VyKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cltrZXldKSB7XHJcbiAgICAgICAgICBwcmV2LnB1c2goa2V5KVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJldlxyXG4gIH0sIFtdKVxyXG4gIC5qb2luKCcgJylcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG9iak1hcCA9IChmbiwgb2JqKSA9PiB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChwcmV2LCBrZXksIGkpID0+IHtcclxuICAgIHByZXZba2V5XSA9IGZuKG9ialtrZXldLCBrZXksIGkpXHJcbiAgICByZXR1cm4gcHJldlxyXG4gIH0sIHt9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZm9ybWF0RGF0ZSA9IChkKSA9PiB7XHJcbiAgY29uc3QgcGFkID0gKG4pID0+IG4gPj0gMTAgPyAoJycgKyBuKSA6ICgnMCcgKyBuKVxyXG4gIHJldHVybiBbZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkgKyAxLCBkLmdldERhdGUoKV0ubWFwKHBhZCkuam9pbignLScpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBzcGxpdEtlZXAgPSAocGF0dGVybiwgc3RyKSA9PiB7XHJcbiAgY29uc3QgcmVzdWx0ICAgID0gW11cclxuICBsZXQgc3RhcnRJbmRleCAgPSAwXHJcbiAgbGV0IHJlZywgbWF0Y2gsIGxhc3RNYXRjaEluZGV4XHJcblxyXG4gIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICByZWcgPSBuZXcgUmVnRXhwKFxyXG4gICAgICBwYXR0ZXJuLFxyXG4gICAgICBwYXR0ZXJuLmZsYWdzLmluZGV4T2YoJ2cnKSAhPT0gLTEgPyBwYXR0ZXJuLmZsYWdzIDogKHBhdHRlcm4uZmxhZ3MgKyAnZycpXHJcbiAgICApXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJlZyA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKVxyXG4gIH1cclxuXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXHJcbiAgd2hpbGUgKG1hdGNoID0gcmVnLmV4ZWMoc3RyKSkge1xyXG4gICAgaWYgKGxhc3RNYXRjaEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXRjaC5pbmRleCA+IHN0YXJ0SW5kZXgpIHtcclxuICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhzdGFydEluZGV4LCBtYXRjaC5pbmRleCkpXHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0LnB1c2gobWF0Y2hbMF0pXHJcbiAgICBzdGFydEluZGV4ICAgICAgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxyXG4gICAgbGFzdE1hdGNoSW5kZXggID0gbWF0Y2guaW5kZXhcclxuICB9XHJcblxyXG4gIGlmIChzdGFydEluZGV4IDwgc3RyLmxlbmd0aCkge1xyXG4gICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cihzdGFydEluZGV4KSlcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG5hbWVGYWN0b3J5ID0gKCkgPT4ge1xyXG4gIGNvbnN0IGFsbCA9IHt9XHJcblxyXG4gIHJldHVybiAoc3RyKSA9PiB7XHJcbiAgICBpZiAoIWFsbFtzdHJdKSB7XHJcbiAgICAgIGFsbFtzdHJdID0gdHJ1ZVxyXG4gICAgICByZXR1cm4gc3RyXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG4gPSAyXHJcbiAgICB3aGlsZSAoYWxsW3N0ciArICctJyArIG5dKSB7XHJcbiAgICAgIG4rK1xyXG4gICAgfVxyXG5cclxuICAgIGFsbFtzdHIgKyAnLScgKyBuXSA9IHRydWVcclxuICAgIHJldHVybiBzdHIgKyAnLScgKyBuXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29tcG9zZVByb21pc2VGbiA9ICguLi5saXN0KSA9PiB7XHJcbiAgcmV0dXJuIHJlZHVjZVJpZ2h0KChjdXIsIHByZXYpID0+IHtcclxuICAgIHJldHVybiB4ID0+IHByZXYoeCkudGhlbihjdXIpXHJcbiAgfSwgeCA9PiBQcm9taXNlLnJlc29sdmUoeCksIGxpc3QpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZVF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XHJcbiAgcmV0dXJuIHF1ZXJ5LnNsaWNlKDEpLnNwbGl0KCcmJykucmVkdWNlKChwcmV2LCBjdXIpID0+IHtcclxuICAgIGNvbnN0IGluZGV4ID0gY3VyLmluZGV4T2YoJz0nKVxyXG4gICAgY29uc3Qga2V5ID0gY3VyLnN1YnN0cmluZygwLCBpbmRleClcclxuICAgIGNvbnN0IHZhbCA9IGN1ci5zdWJzdHJpbmcoaW5kZXggKyAxKVxyXG5cclxuICAgIHByZXZba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpXHJcbiAgICByZXR1cm4gcHJldlxyXG4gIH0sIHt9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdG9SZWdFeHAgPSAoc3RyLCB7IG5lZWRFbmNvZGUgPSBmYWxzZSwgZmxhZyA9ICcnIH0gPSB7fSkgPT4ge1xyXG4gIHJldHVybiBuZXcgUmVnRXhwKFxyXG4gICAgbmVlZEVuY29kZSA/IHN0ci5yZXBsYWNlKC9bW1xcXSgpe31eJC4qKz98XS9nLCAnXFxcXCQmJykgOiBzdHIsXHJcbiAgICBmbGFnXHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaW5zZXJ0U2NyaXB0ID0gKGZpbGUpID0+IHtcclxuICBjb25zdCBzID0gZG9jdW1lbnQuY29uc3RydWN0b3IucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgJ3NjcmlwdCcpXHJcblxyXG4gIHMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpXHJcbiAgcy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGZpbGUpXHJcblxyXG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzKVxyXG4gIHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgd2l0aFRpbWVvdXQgPSAodGltZW91dCwgZm4pID0+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgY2FuY2VsICA9ICgpID0+IGNsZWFyVGltZW91dCh0aW1lcilcclxuICAgIGNvbnN0IHRpbWVyICAgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcmVqZWN0KG5ldyBFcnJvcignd2l0aFRpbWVvdXQ6IHRpbWVvdXQnKSlcclxuICAgIH0sIHRpbWVvdXQpXHJcblxyXG4gICAgZm4oY2FuY2VsKVxyXG4gICAgLnRoZW4oXHJcbiAgICAgIGRhdGEgPT4ge1xyXG4gICAgICAgIGNhbmNlbCgpXHJcbiAgICAgICAgcmVzb2x2ZShkYXRhKVxyXG4gICAgICB9LFxyXG4gICAgICBlID0+IHtcclxuICAgICAgICBjYW5jZWwoKVxyXG4gICAgICAgIHJlamVjdChlKVxyXG4gICAgICB9XHJcbiAgICApXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHJldHJ5ID0gKGZuLCBvcHRpb25zKSA9PiAoLi4uYXJncykgPT4ge1xyXG4gIGNvbnN0IHsgdGltZW91dCwgb25GaXJzdEZhaWwsIG9uRmluYWwsIHNob3VsZFJldHJ5LCByZXRyeUludGVydmFsIH0gPSB7XHJcbiAgICB0aW1lb3V0OiA1MDAwLFxyXG4gICAgcmV0cnlJbnRlcnZhbDogMTAwMCxcclxuICAgIG9uRmlyc3RGYWlsOiAgKCkgPT4ge30sXHJcbiAgICBvbkZpbmFsOiAgICAgICgpID0+IHt9LFxyXG4gICAgc2hvdWxkUmV0cnk6ICAoKSA9PiBmYWxzZSxcclxuICAgIC4uLm9wdGlvbnNcclxuICB9XHJcblxyXG4gIGxldCByZXRyeUNvdW50ICAgID0gMFxyXG4gIGxldCBsYXN0RXJyb3IgICAgID0gbnVsbFxyXG4gIGxldCB0aW1lclRvQ2xlYXIgID0gbnVsbFxyXG4gIGxldCBkb25lICAgICAgICAgID0gZmFsc2VcclxuXHJcbiAgY29uc3Qgd3JhcHBlZE9uRmluYWwgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgZG9uZSA9IHRydWVcclxuXHJcbiAgICBpZiAodGltZXJUb0NsZWFyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lclRvQ2xlYXIpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9uRmluYWwoLi4uYXJncylcclxuICB9XHJcblxyXG4gIGNvbnN0IGludGVydmFsTWFuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCBsYXN0SW50ZXJ2YWwgICAgICA9IG51bGxcclxuICAgIGNvbnN0IGludGVydmFsRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHN3aXRjaCAodHlwZW9mIHJldHJ5SW50ZXJ2YWwpIHtcclxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAgICByZXR1cm4gcmV0cnlJbnRlcnZhbFxyXG5cclxuICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgcmV0dXJuICgpID0+IHJldHJ5SW50ZXJ2YWxcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cnlJbnRlcnZhbCBtdXN0IGJlIGVpdGhlciBhIG51bWJlciBvciBhIGZ1bmN0aW9uJylcclxuICAgICAgfVxyXG4gICAgfSkoKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldExhc3RJbnRlcnZhbDogKCkgPT4gbGFzdEludGVydmFsLFxyXG4gICAgICBnZXRJbnRlcnZhbDogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gaW50ZXJ2YWxGYWN0b3J5KHJldHJ5Q291bnQsIGxhc3RJbnRlcnZhbClcclxuICAgICAgICBsYXN0SW50ZXJ2YWwgPSBpbnRlcnZhbFxyXG4gICAgICAgIHJldHVybiBpbnRlcnZhbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSkoKVxyXG5cclxuICBjb25zdCBvbkVycm9yID0gKGUsIHJlamVjdCkgPT4ge1xyXG4gICAgaWYgKCFzaG91bGRSZXRyeShlLCByZXRyeUNvdW50KSkge1xyXG4gICAgICB3cmFwcGVkT25GaW5hbChlKVxyXG5cclxuICAgICAgaWYgKHJlamVjdCkgcmV0dXJuIHJlamVjdChlKVxyXG4gICAgICBlbHNlICAgICAgICB0aHJvdyBlXHJcbiAgICB9XHJcbiAgICBsYXN0RXJyb3IgPSBlXHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgaWYgKHJldHJ5Q291bnQrKyA9PT0gMCkge1xyXG4gICAgICAgIG9uRmlyc3RGYWlsKGUpXHJcbiAgICAgICAgdGltZXJUb0NsZWFyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB3cmFwcGVkT25GaW5hbChsYXN0RXJyb3IpXHJcbiAgICAgICAgICByZWplY3QobGFzdEVycm9yKVxyXG4gICAgICAgIH0sIHRpbWVvdXQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkb25lKSByZXR1cm5cclxuXHJcbiAgICAgIGRlbGF5KHJ1biwgaW50ZXJ2YWxNYW4uZ2V0SW50ZXJ2YWwoKSlcclxuICAgICAgLnRoZW4ocmVzb2x2ZSwgZSA9PiBvbkVycm9yKGUsIHJlamVjdCkpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcnVuID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIGZuKC4uLmFyZ3MsIHtcclxuICAgICAgcmV0cnlDb3VudCxcclxuICAgICAgcmV0cnlJbnRlcnZhbDogaW50ZXJ2YWxNYW4uZ2V0TGFzdEludGVydmFsKClcclxuICAgIH0pXHJcbiAgICAuY2F0Y2gob25FcnJvcilcclxuICB9XHJcblxyXG4gIHJldHVybiBydW4oKVxyXG4gIC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgIHdyYXBwZWRPbkZpbmFsKG51bGwsIHJlc3VsdClcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9KVxyXG59XHJcblxyXG4vLyByZWZlciB0byBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjE2ODkwOS9ibG9iLWZyb20tZGF0YXVybFxyXG5leHBvcnQgZnVuY3Rpb24gZGF0YVVSSXRvQmxvYiAoZGF0YVVSSSkge1xyXG4gIC8vIGNvbnZlcnQgYmFzZTY0IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgc3RyaW5nXHJcbiAgLy8gZG9lc24ndCBoYW5kbGUgVVJMRW5jb2RlZCBEYXRhVVJJcyAtIHNlZSBTTyBhbnN3ZXIgIzY4NTAyNzYgZm9yIGNvZGUgdGhhdCBkb2VzIHRoaXNcclxuICB2YXIgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVSSS5zcGxpdCgnLCcpWzFdKTtcclxuXHJcbiAgLy8gc2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudFxyXG4gIHZhciBtaW1lU3RyaW5nID0gZGF0YVVSSS5zcGxpdCgnLCcpWzBdLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXVxyXG5cclxuICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxyXG4gIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XHJcblxyXG4gIC8vIGNyZWF0ZSBhIHZpZXcgaW50byB0aGUgYnVmZmVyXHJcbiAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xyXG5cclxuICAvLyBzZXQgdGhlIGJ5dGVzIG9mIHRoZSBidWZmZXIgdG8gdGhlIGNvcnJlY3QgdmFsdWVzXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYiwgYW5kIHlvdSdyZSBkb25lXHJcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYWJdLCB7dHlwZTogbWltZVN0cmluZ30pO1xyXG4gIHJldHVybiBibG9iO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcmFuZG9tTmFtZSA9IChsZW5ndGggPSA2KSA9PiB7XHJcbiAgaWYgKGxlbmd0aCA8PSAwIHx8IGxlbmd0aCA+IDEwMCkgIHRocm93IG5ldyBFcnJvcigncmFuZG9tTmFtZSwgbGVuZ3RoIG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMDAnKVxyXG5cclxuICBjb25zdCByYW5kb21DaGFyID0gKCkgPT4ge1xyXG4gICAgY29uc3QgbiA9IE1hdGguZmxvb3IoNjIgKiBNYXRoLnJhbmRvbSgpKVxyXG4gICAgbGV0IGNvZGVcclxuXHJcbiAgICBpZiAobiA8PSA5KSB7XHJcbiAgICAgIGNvZGUgPSA0OCArIG5cclxuICAgIH0gZWxzZSBpZiAobiA8PSAzNSkge1xyXG4gICAgICBjb2RlID0gNjUgKyBuIC0gMTBcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvZGUgPSA5NyArIG4gLSAzNlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmFuZ2UoMCwgbGVuZ3RoKS5tYXAocmFuZG9tQ2hhcikuam9pbignJylcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHdpdGhGaWxlRXh0ZW5zaW9uID0gKG9yaWdOYW1lLCBmbikgPT4ge1xyXG4gIGNvbnN0IHJlZyA9IC9cXC5cXHcrJC9cclxuICBjb25zdCBtICAgPSBvcmlnTmFtZS5tYXRjaChyZWcpXHJcblxyXG4gIGNvbnN0IGV4dE5hbWUgICA9IG0gPyBtWzBdIDogJydcclxuICBjb25zdCBiYXNlTmFtZSAgPSBtID8gb3JpZ05hbWUucmVwbGFjZShyZWcsICcnKSA6IG9yaWdOYW1lXHJcbiAgY29uc3QgcmVzdWx0ICAgID0gZm4oYmFzZU5hbWUsIChuYW1lKSA9PiBuYW1lICsgZXh0TmFtZSlcclxuXHJcbiAgaWYgKCFyZXN1bHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignd2l0aEZpbGVFeHRlbnNpb246IHNob3VsZCBub3QgcmV0dXJuIG51bGwvdW5kZWZpbmVkJylcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiByZXN1bHQudGhlbihuYW1lID0+IG5hbWUgKyBleHROYW1lKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdCArIGV4dE5hbWVcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVuaXF1ZU5hbWUgPSAobmFtZSwgb3B0aW9ucykgPT4ge1xyXG4gIGNvbnN0IG9wdHMgPSB7XHJcbiAgICBnZW5lcmF0ZTogKG9sZCwgc3RlcCA9IDEpID0+IHtcclxuICAgICAgY29uc3QgcmVnID0gL19cXCgoXFxkKylcXCkkL1xyXG4gICAgICBjb25zdCBtICAgPSBvbGQubWF0Y2gocmVnKVxyXG5cclxuICAgICAgaWYgKCFtKSByZXR1cm4gYCR7b2xkfV8oJHtzdGVwfSlgXHJcbiAgICAgIHJldHVybiBvbGQucmVwbGFjZShyZWcsIChfLCBuKSA9PiBgXygke3BhcnNlSW50KG4sIDEwKSArIHN0ZXB9KWApXHJcbiAgICB9LFxyXG4gICAgY2hlY2s6ICgpID0+IFByb21pc2UucmVzb2x2ZSh0cnVlKSxcclxuICAgIC4uLm9wdGlvbnNcclxuICB9XHJcbiAgY29uc3QgeyBnZW5lcmF0ZSwgY2hlY2sgfSA9IG9wdHNcclxuXHJcbiAgcmV0dXJuIHdpdGhGaWxlRXh0ZW5zaW9uKG5hbWUsIChiYXNlTmFtZSwgZ2V0RnVsbE5hbWUpID0+IHtcclxuICAgIGNvbnN0IGdvID0gKGZpbGVOYW1lLCBzdGVwKSA9PiB7XHJcbiAgICAgIHJldHVybiBjaGVjayhnZXRGdWxsTmFtZShmaWxlTmFtZSkpXHJcbiAgICAgIC50aGVuKHBhc3MgPT4ge1xyXG4gICAgICAgIGlmIChwYXNzKSByZXR1cm4gZmlsZU5hbWVcclxuICAgICAgICByZXR1cm4gZ28oZ2VuZXJhdGUoZmlsZU5hbWUsIHN0ZXApLCBzdGVwKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnbyhiYXNlTmFtZSwgMSlcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5kID0gKC4uLmxpc3QpID0+IGxpc3QucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYgJiYgY3VyLCB0cnVlKVxyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRDc3YgPSAodXJsKSA9PiB7XHJcbiAgcmV0dXJuIGZldGNoKHVybClcclxuICAudGhlbihyZXMgPT4ge1xyXG4gICAgaWYgKCFyZXMub2spICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGNzdiAtICR7dXJsfWApXHJcbiAgICByZXR1cm4gcmVzLnRleHQoKVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkSW1hZ2UgPSAodXJsKSA9PiB7XHJcbiAgcmV0dXJuIGZldGNoKHVybClcclxuICAudGhlbihyZXMgPT4ge1xyXG4gICAgaWYgKCFyZXMub2spICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGltYWdlIC0gJHt1cmx9YClcclxuICAgIHJldHVybiByZXMuYmxvYigpXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGVuc3VyZUV4dE5hbWUgPSAoZXh0LCBuYW1lKSA9PiB7XHJcbiAgY29uc3QgZXh0TmFtZSA9IGV4dC5pbmRleE9mKCcuJykgPT09IDAgPyBleHQgOiAoJy4nICsgZXh0KVxyXG4gIGlmIChuYW1lLmxhc3RJbmRleE9mKGV4dE5hbWUpICsgZXh0TmFtZS5sZW5ndGggPT09IG5hbWUubGVuZ3RoKSByZXR1cm4gbmFtZVxyXG4gIHJldHVybiBuYW1lICsgZXh0TmFtZVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVTdGFuZGFyZE5hbWUgPSAobmFtZSwgaXNGaWxlTmFtZSkgPT4ge1xyXG4gIGlmICghaXNGaWxlTmFtZSAmJiAhL15ffFthLXpBLVpdLy50ZXN0KG5hbWUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciBvciB0aGUgdW5kZXJzY29yZSBjaGFyYWN0ZXIuYClcclxuICB9XHJcblxyXG4gIGlmIChpc0ZpbGVOYW1lICYmICEvXl98W2EtekEtWjAtOV0vLnRlc3QobmFtZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgbXVzdCBzdGFydCB3aXRoIGFscGhhLW51bWVyaWMgb3IgdGhlIHVuZGVyc2NvcmUgY2hhcmFjdGVyLmApXHJcbiAgfVxyXG5cclxuICBpZiAoIS9eW2EtekEtWjAtOV9dKyQvLnRlc3QobmFtZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgY2FuIG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMgYW5kIHVuZGVyc2NvcmVzIChBLXosIDAtOSwgYW5kIF8gKWApXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc2FuaXRpemVGaWxlTmFtZSA9IChmaWxlTmFtZSkgPT4ge1xyXG4gIHJldHVybiB3aXRoRmlsZUV4dGVuc2lvbihmaWxlTmFtZSwgKGJhc2VOYW1lKSA9PiBiYXNlTmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csICdfJykpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JlZW5EcGkgPSAoKSA9PiB7XHJcbiAgY29uc3QgREVGQVVMVF9EUEkgPSA5NlxyXG4gIGNvbnN0IG1hdGNoRHBpID0gKGRwaSkgPT4ge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKGAobWF4LXJlc29sdXRpb246ICR7ZHBpfWRwaSlgKS5tYXRjaGVzID09PSB0cnVlXHJcbiAgfVxyXG5cclxuICAvLyBXZSBpdGVyYXRpdmVseSBzY2FuIGFsbCBwb3NzaWJsZSBtZWRpYSBxdWVyeSBtYXRjaGVzLlxyXG4gIC8vIFdlIGNhbid0IHVzZSBiaW5hcnkgc2VhcmNoLCBiZWNhdXNlIHRoZXJlIGFyZSBcIm1hbnlcIiBjb3JyZWN0IGFuc3dlciBpblxyXG4gIC8vIHByb2JsZW0gc3BhY2UgYW5kIHdlIG5lZWQgdGhlIHZlcnkgZmlyc3QgbWF0Y2guXHJcbiAgLy8gVG8gc3BlZWQgdXAgY29tcHV0YXRpb24gd2UgZGl2aWRlIHByb2JsZW0gc3BhY2UgaW50byBidWNrZXRzLlxyXG4gIC8vIFdlIHRlc3QgZWFjaCBidWNrZXQncyBmaXJzdCBlbGVtZW50IGFuZCBpZiB3ZSBmb3VuZCBhIG1hdGNoLFxyXG4gIC8vIHdlIG1ha2UgYSBmdWxsIHNjYW4gZm9yIHByZXZpb3VzIGJ1Y2tldCB3aXRoIGluY2x1ZGluZyBmaXJzdCBtYXRjaC5cclxuICAvLyBTdGlsbCwgd2UgY291bGQgdXNlIFwiZGl2aWRlLWFuZC1jb25xdWVyXCIgZm9yIHN1Y2ggcHJvYmxlbXMuXHJcbiAgLy8gRHVlIHRvIGNvbW1vbiBEUEkgdmFsdWVzLCBpdCdzIG5vdCB3b3J0aCB0byBpbXBsZW1lbnQgc3VjaCBhbGdvcml0aG0uXHJcblxyXG4gIGNvbnN0IGJ1Y2tldFNpemUgPSAyNCAvLyBjb21tb24gZGl2aXNvciBmb3IgNzIsIDk2LCAxMjAsIDE0NCBldGMuXHJcblxyXG4gIGZvciAobGV0IGkgPSBidWNrZXRTaXplOyBpIDwgMzAwMDsgaSArPSBidWNrZXRTaXplKSB7XHJcbiAgICBpZiAobWF0Y2hEcGkoaSkpIHtcclxuICAgICAgY29uc3Qgc3RhcnQgPSBpIC0gYnVja2V0U2l6ZVxyXG4gICAgICBjb25zdCBlbmQgICA9IGlcclxuXHJcbiAgICAgIGZvciAobGV0IGsgPSBzdGFydDsgayA8PSBlbmQ7ICsraykge1xyXG4gICAgICAgIGlmIChtYXRjaERwaShrKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBERUZBVUxUX0RQSTsgLy8gZGVmYXVsdCBmYWxsYmFja1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZHBpRnJvbUZpbGVOYW1lID0gKGZpbGVOYW1lKSA9PiB7XHJcbiAgY29uc3QgcmVnID0gL19kcGlfKFxcZCspL2lcclxuICBjb25zdCBtID0gZmlsZU5hbWUubWF0Y2gocmVnKVxyXG4gIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApIDogMFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgbW9ja0FQSVdpdGggPSAoZmFjdG9yeSwgbW9jaywgcHJvbWlzZUZ1bmN0aW9uS2V5cyA9IFtdKSA9PiB7XHJcbiAgbGV0IHJlYWwgPSBtb2NrXHJcbiAgbGV0IGV4cG9ydGVkID0gb2JqTWFwKCh2YWwsIGtleSkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaWYgKHByb21pc2VGdW5jdGlvbktleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gcC50aGVuKCgpID0+IHJlYWxba2V5XSguLi5hcmdzKSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgIHAudGhlbigoKSA9PiByZWFsW2tleV0oLi4uYXJncykpXHJcbiAgICAgICAgICByZXR1cm4gcmVhbFtrZXldKC4uLmFyZ3MpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdmFsXHJcbiAgICB9XHJcbiAgfSwgbW9jaylcclxuXHJcbiAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZShmYWN0b3J5KCkpXHJcbiAgICAgICAgICAgIC50aGVuKGFwaSA9PiB7IHJlYWwgPSBhcGkgfSlcclxuXHJcbiAgcmV0dXJuIGV4cG9ydGVkXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB3aXRoQ291bnREb3duID0gKG9wdGlvbnMpID0+IHtcclxuICBjb25zdCB7IGludGVydmFsLCB0aW1lb3V0LCBvblRpY2sgfSA9IG9wdGlvbnNcclxuICBsZXQgcGFzdCA9IDBcclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBwYXN0ICs9IGludGVydmFsXHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG9uVGljayh7IHBhc3QsIHRvdGFsOiB0aW1lb3V0IH0pXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5lcnJvcihlKSB9XHJcblxyXG4gICAgICBpZiAocGFzdCA+PSB0aW1lb3V0KSAgY2xlYXJJbnRlcnZhbCh0aW1lcilcclxuICAgIH0sIGludGVydmFsKVxyXG5cclxuICAgIGNvbnN0IHAgPSBkZWxheSgoKSA9PiB7fSwgdGltZW91dClcclxuICAgIC50aGVuKCgpID0+IGNsZWFySW50ZXJ2YWwodGltZXIpKVxyXG5cclxuICAgIHJlc29sdmUocClcclxuICB9KVxyXG59XHJcbiIsIi8qIGdsb2JhbCBjaHJvbWUgYnJvd3NlciAqL1xyXG5cclxuLy8gTm90ZTogaXQncyBhbiBhZGFwdGVyIGZvciBib3RoIGNocm9tZSBhbmQgd2ViIGV4dGVuc2lvbiBBUElcclxuLy8gY2hyb21lIGFuZCB3ZWIgZXh0ZW5zaW9uIEFQSSBoYXZlIGFsbW9zdCB0aGUgc2FtZSBBUEkgc2lnbmF0dXJlc1xyXG4vLyBleGNlcHQgdGhhdCBjaHJvbWUgYWNjZXB0cyBjYWxsYmFjayB3aGlsZSB3ZWIgZXh0ZW5zaW9uIHJldHVybnMgcHJvbWlzZXNcclxuLy9cclxuLy8gVGhlIHdob2xlIGlkZWEgaGVyZSBpcyB0byBtYWtlIHN1cmUgYWxsIGNhbGxiYWNrIHN0eWxlIEFQSSBvZiBjaHJvbWVcclxuLy8gYWxzbyByZXR1cm4gcHJvbWlzZXNcclxuLy9cclxuLy8gSW1wb3J0YW50OiBZb3UgbmVlZCB0byBzcGVjaWZ5IHdoYXRldmVyIEFQSSB5b3UgbmVlZCB0byB1c2UgaW4gYFVzZWRBUElgIGJlbG93XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIHZhciBhZGFwdENocm9tZSA9IGZ1bmN0aW9uIChvYmosIGNocm9tZSkge1xyXG4gICAgdmFyIGFkYXB0ID0gZnVuY3Rpb24gKHNyYywgcmV0LCBvYmosIGZuKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAocHJldiwga2V5KSB7XHJcbiAgICAgICAgdmFyIGtleVBhcnRzID0ga2V5LnNwbGl0KCcuJylcclxuICAgICAgICB2YXIgW1xyXG4gICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgc291cmNlXHJcbiAgICAgICAgXSA9IGtleVBhcnRzLnJlZHVjZShmdW5jdGlvbiAodHVwbGUsIHN1YmtleSkge1xyXG4gICAgICAgICAgdmFyIHRhciA9IHR1cGxlWzBdXHJcbiAgICAgICAgICB2YXIgc3JjID0gdHVwbGVbMV1cclxuXHJcbiAgICAgICAgICB0YXJbc3Via2V5XSA9IHRhcltzdWJrZXldIHx8IHt9XHJcbiAgICAgICAgICByZXR1cm4gW3RhcltzdWJrZXldLCBzcmMgJiYgc3JjW3N1YmtleV1dXHJcbiAgICAgICAgfSwgW1xyXG4gICAgICAgICAgcHJldixcclxuICAgICAgICAgIHNyY1xyXG4gICAgICAgIF0pXHJcblxyXG4gICAgICAgIG9ialtrZXldLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgICAgZm4obWV0aG9kLCBzb3VyY2UsIHRhcmdldClcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gcHJldlxyXG4gICAgICB9LCByZXQpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb21pc2lmeSA9IGZ1bmN0aW9uIChtZXRob2QsIHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICAgIGlmICghc291cmNlKSAgcmV0dXJuXHJcbiAgICAgIHZhciByZWcgPSAvVGhlIG1lc3NhZ2UgcG9ydCBjbG9zZWQgYmVmb3JlIGEgcmVzP3BvbnNlIHdhcyByZWNlaXZlZC9cclxuXHJcbiAgICAgIHRhcmdldFttZXRob2RdID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgbWVzc2FnZSBwb3J0IGNsb3NlZCBiZWZvcmUgYSByZXBvbnNlIHdhcyByZWNlaXZlZC5cclxuICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgbWVzc2FnZVxyXG4gICAgICAgICAgICBpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yICYmXHJcbiAgICAgICAgICAgICAgICAhcmVnLnRlc3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHtjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZX0sICR7bWV0aG9kfSwgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKVxyXG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNvdXJjZVttZXRob2RdLmFwcGx5KHNvdXJjZSwgYXJncy5jb25jYXQoY2FsbGJhY2spKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29weSA9IGZ1bmN0aW9uIChtZXRob2QsIHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICAgIGlmICghc291cmNlKSAgcmV0dXJuXHJcbiAgICAgIHRhcmdldFttZXRob2RdID0gc291cmNlW21ldGhvZF1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBbb2JqLnRvUHJvbWlzaWZ5LCBwcm9taXNpZnldLFxyXG4gICAgICBbb2JqLnRvQ29weSwgY29weV1cclxuICAgIF1cclxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHR1cGxlKSB7XHJcbiAgICAgIHJldHVybiBhZGFwdChjaHJvbWUsIHByZXYsIHR1cGxlWzBdLCB0dXBsZVsxXSlcclxuICAgIH0sIHt9KVxyXG4gIH1cclxuXHJcbiAgdmFyIFVzZWRBUEkgPSB7XHJcbiAgICB0b1Byb21pc2lmeToge1xyXG4gICAgICB0YWJzOiBbJ2NyZWF0ZScsICdzZW5kTWVzc2FnZScsICdnZXQnLCAndXBkYXRlJywgJ3F1ZXJ5JywgJ2NhcHR1cmVWaXNpYmxlVGFiJywgJ3JlbW92ZSddLFxyXG4gICAgICB3aW5kb3dzOiBbJ3VwZGF0ZScsICdnZXRMYXN0Rm9jdXNlZCcsICdnZXRDdXJyZW50JywgJ2dldEFsbCcsICdyZW1vdmUnLCAnY3JlYXRlJywgJ2dldCddLFxyXG4gICAgICBydW50aW1lOiBbJ3NlbmRNZXNzYWdlJywgJ3NldFVuaW5zdGFsbFVSTCddLFxyXG4gICAgICBjb29raWVzOiBbJ2dldCcsICdnZXRBbGwnLCAnc2V0JywgJ3JlbW92ZSddLFxyXG4gICAgICBub3RpZmljYXRpb25zOiBbJ2NyZWF0ZScsICdjbGVhciddLFxyXG4gICAgICBicm93c2VyQWN0aW9uOiBbJ2dldEJhZGdlVGV4dCddLFxyXG4gICAgICBib29rbWFya3M6IFsnY3JlYXRlJywgJ2dldFRyZWUnXSxcclxuICAgICAgZGVidWdnZXI6IFsnYXR0YWNoJywgJ2RldGFjaCcsICdzZW5kQ29tbWFuZCcsICdnZXRUYXJnZXRzJ10sXHJcbiAgICAgICdzdG9yYWdlLmxvY2FsJzogWydnZXQnLCAnc2V0J11cclxuICAgIH0sXHJcbiAgICB0b0NvcHk6IHtcclxuICAgICAgdGFiczogWydvbkFjdGl2YXRlZCcsICdvblVwZGF0ZWQnXSxcclxuICAgICAgd2luZG93czogWydvbkZvY3VzQ2hhbmdlZCddLFxyXG4gICAgICBydW50aW1lOiBbJ29uTWVzc2FnZScsICdvbkluc3RhbGxlZCcsICdnZXRNYW5pZmVzdCddLFxyXG4gICAgICBzdG9yYWdlOiBbJ29uQ2hhbmdlZCddLFxyXG4gICAgICBicm93c2VyQWN0aW9uOiBbJ3NldEJhZGdlVGV4dCcsICdzZXRCYWRnZUJhY2tncm91bmRDb2xvcicsICdvbkNsaWNrZWQnXSxcclxuICAgICAgZXh0ZW5zaW9uOiBbJ2dldFVSTCddLFxyXG4gICAgICBkZWJ1Z2dlcjogWydvbkV2ZW50JywgJ29uRGV0YWNoJ10sXHJcbiAgICAgIGRvd25sb2FkczogWydvbkNyZWF0ZWQnLCAnb25DaGFuZ2VkJywgJ29uRGV0ZXJtaW5pbmdGaWxlbmFtZSddXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgRXh0ID0gdHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgPyBhZGFwdENocm9tZShVc2VkQVBJLCBjaHJvbWUpIDogYnJvd3NlclxyXG5cclxuICBPYmplY3QuYXNzaWduKEV4dCwge1xyXG4gICAgaXNGaXJlZm94OiAoKSA9PiB7XHJcbiAgICAgIHJldHVybiAvRmlyZWZveC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcclxuICAgIH1cclxuICB9KVxyXG5cclxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXh0XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgd2luZG93LkV4dCA9IEV4dFxyXG4gIH1cclxufSkoKVxyXG4iLCJpbXBvcnQgRXh0IGZyb20gJy4uLy4uL2NvbW1vbi93ZWJfZXh0ZW5zaW9uJ1xyXG5pbXBvcnQgc3RvcmFnZSBmcm9tICcuLi8uLi9jb21tb24vc3RvcmFnZSdcclxuaW1wb3J0IGNzSXBjIGZyb20gJy4uLy4uL2NvbW1vbi9pcGMvaXBjX2NzJ1xyXG5pbXBvcnQgeyBwb3N0TWVzc2FnZSwgb25NZXNzYWdlIH0gZnJvbSAnLi4vLi4vY29tbW9uL2lwYy9jc19wb3N0bWVzc2FnZSdcclxuaW1wb3J0IGluc3BlY3RvciBmcm9tICcuLi8uLi9jb21tb24vaW5zcGVjdG9yJ1xyXG5pbXBvcnQgKiBhcyBDIGZyb20gJy4uLy4uL2NvbW1vbi9jb25zdGFudCdcclxuaW1wb3J0IHsgc2V0SW4sIHVwZGF0ZUluLCB1bnRpbCwgcGFyc2VRdWVyeSwgb2JqTWFwIH0gZnJvbSAnLi4vLi4vY29tbW9uL3V0aWxzJ1xyXG5pbXBvcnQgeyBiaW5kQ29udGVudEVkaXRhYmxlQ2hhbmdlLCBpc1Bvc2l0aW9uRml4ZWQgfSBmcm9tICcuLi8uLi9jb21tb24vZG9tX3V0aWxzJ1xyXG5pbXBvcnQgeyBydW4sIGdldEVsZW1lbnRCeUxvY2F0b3IgfSBmcm9tICcuLi8uLi9jb21tb24vY29tbWFuZF9ydW5uZXInXHJcbmltcG9ydCB7IGNhcHR1cmVDbGllbnRBUEkgfSBmcm9tICcuLi8uLi9jb21tb24vY2FwdHVyZV9zY3JlZW5zaG90J1xyXG5pbXBvcnQgeyBlbmNyeXB0SWZOZWVkZWQgfSBmcm9tICcuLi8uLi9jb21tb24vZW5jcnlwdCdcclxuaW1wb3J0IGxvZyBmcm9tICcuLi8uLi9jb21tb24vbG9nJ1xyXG5pbXBvcnQgeyBzZWxlY3RBcmVhIH0gZnJvbSAnLi9zZWxlY3RfYXJlYSdcclxuXHJcbmNvbnN0IE1BU0tfQ0xJQ0tfRkFERV9USU1FT1VUID0gMjAwMFxyXG5jb25zdCBvb3BzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJ1xyXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7fVxyXG4gICAgICAgICAgICAgICAgOiAoZSkgPT4gbG9nLmVycm9yKGUuc3RhY2spXHJcblxyXG5jb25zdCBzdGF0ZSA9IHtcclxuICBzdGF0dXM6IEMuQ09OVEVOVF9TQ1JJUFRfU1RBVFVTLk5PUk1BTCxcclxuICAvLyBOb3RlOiBpdCBkZWNpZGVzIHdoZXRoZXIgd2UncmUgcnVubmluZyBjb21tYW5kc1xyXG4gIC8vIGluIHRoZSBjdXJyZW50IHdpbmRvdyBvciBzb21lIGlmcmFtZS9mcmFtZVxyXG4gIHBsYXlpbmdGcmFtZTogd2luZG93LFxyXG4gIC8vIE5vdGU6IGN1cnJlbnQgZnJhbWUgc3RhY2sgd2hlbiByZWNvcmRpbmcsIGl0IGhlbHBzXHJcbiAgLy8gdG8gZ2VuZXJhdGUgYHNlbGVjdEZyYW1lYCBjb21tYW5kc1xyXG4gIHJlY29yZGluZ0ZyYW1lU3RhY2s6IFtdLFxyXG4gIC8vIE5vdGU6IHNuYXBzaG90IG9mIGV4dGVuc2lvbiBjb25maWcgKGNvbnRlbnQgc2NyaXB0IGNhcmVzIGFib3V0IGNsaWNrL2NsaWNrQXQgd2hlbiByZWNvcmRpbmcpXHJcbiAgLy8gSXQgaXMgc3VwcG9zZWQgdG8gYmUgdXBkYXRlZCB3aGVuIHVzZXIgYWN0aXZhdGVzIHRoYXQgcGFnZVxyXG4gIGNvbmZpZzoge31cclxufVxyXG5cclxuLy8gTm90ZTogV2hldGhlciBpdCdzIHRvcCBvciBpbm5lciB3aW5kb3csIGEgY29udGVudCBzY3JpcHQgaGFzIHRoZSBuZWVkXHJcbi8vIHRvIHNlbmQgSVBDIG1lc3NhZ2UgdG8gYmFja2dyb3VuZC4gQnV0IGluIG91ciBkZXNpZ24sIG9ubHkgdGhlIHRvcCB3aW5kb3dcclxuLy8gaGFzIGFjY2VzcyB0byB0aGUgcmVhbCBjc0lwYywgd2hpbGUgaW5uZXIgZnJhbWVzIGhhdmUgdG8gYnViYmxlIHVwIHRoZSBtZXNzYWdlc1xyXG4vLyB0byB0aGUgdG9wIHdpbmRvdy5cclxuLy8gU28gaW5uZXIgd2luZG93cyBhcmUgcHJvdmlkZWQgd2l0aCBhIGZha2UgY3NJcGMsIHdoaWNoIHBvc3QgbWVzc2FnZXMgdG8gaXRzIHBhcmVudFxyXG5jb25zdCBzdXBlckNzSXBjID1cclxuICB3aW5kb3cudG9wID09PSB3aW5kb3dcclxuICAgID8gY3NJcGNcclxuICAgIDoge1xyXG4gICAgICBhc2s6IChpcGNBY3Rpb24sIGlwY0RhdGEpID0+IHtcclxuICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2Uod2luZG93LnBhcmVudCwgd2luZG93LCB7XHJcbiAgICAgICAgICBhY3Rpb246ICdJUENfQ0FMTCcsXHJcbiAgICAgICAgICBkYXRhOiB7IGlwY0FjdGlvbiwgaXBjRGF0YSB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuY29uc3QgY2FsY1NlbGVjdEZyYW1lQ21kcyA9IChmcmFtZVN0YWNrKSA9PiB7XHJcbiAgdmFyIHhzICA9IHN0YXRlLnJlY29yZGluZ0ZyYW1lU3RhY2tcclxuICB2YXIgeXMgID0gZnJhbWVTdGFja1xyXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4cy5sZW5ndGgsIHlzLmxlbmd0aClcclxuICB2YXIgdHBsID0geyBjbWQ6ICdzZWxlY3RGcmFtZScsIHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYgfVxyXG4gIHZhciByZXQgPSBbXVxyXG4gIHZhciBpICAgPSAwXHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgaWYgKHhzW2ldICE9PSB5c1tpXSkge1xyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGkgPT09IDApIHtcclxuICAgIC8vIE5vIG5lZWQgZm9yIHJlbGF0aXZlPXRvcCwgaWYgc3RhdGUucmVjb3JkaW5nRnJhbWVTdGFjayBpcyBlbXB0eVxyXG4gICAgaWYgKHhzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICByZXQucHVzaCh7IC4uLnRwbCwgdGFyZ2V0OiAncmVsYXRpdmU9dG9wJyB9KVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaSA8IGxlbikge1xyXG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCB4cy5sZW5ndGg7IGorKykge1xyXG4gICAgICByZXQucHVzaCh7IC4uLnRwbCwgdGFyZ2V0OiAncmVsYXRpdmU9cGFyZW50JyB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaiA9IGk7IGogPCB5cy5sZW5ndGg7IGorKykge1xyXG4gICAgcmV0LnB1c2goeyAuLi50cGwsIHRhcmdldDogeXNbal0gfSlcclxuICB9XHJcblxyXG4gIHJldHVybiByZXRcclxufVxyXG5cclxuLy8gVHdvIG1hc2tzIHRvIHNob3cgb24gcGFnZVxyXG4vLyAxLiBtYXNrIG9uIGNsaWNrXHJcbi8vIDIuIG1hc2sgb24gaG92ZXJcclxuY29uc3QgZ2V0TWFzayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgbGV0IG1hc2ssIGZhY3RvcnlcclxuXHJcbiAgY29uc3QgYWRkTG9nb0ltZyA9ICgkZG9tKSA9PiB7XHJcbiAgICBjb25zdCAkaW1nID0gY3JlYXRlTG9nb0ltZygpXHJcblxyXG4gICAgaW5zcGVjdG9yLnNldFN0eWxlKCRpbWcsIHtcclxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgIHRvcDogJy0yNXB4JyxcclxuICAgICAgbGVmdDogJzAnLFxyXG4gICAgICB3aWR0aDogJzIwcHgnLFxyXG4gICAgICBoZWlnaHQ6ICcyMHB4J1xyXG4gICAgfSlcclxuXHJcbiAgICAkZG9tLmFwcGVuZENoaWxkKCRpbWcpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gKHJlbW92ZSkgPT4ge1xyXG4gICAgaWYgKHJlbW92ZSAmJiBmYWN0b3J5KSAgcmV0dXJuIGZhY3RvcnkuY2xlYXIoKVxyXG4gICAgaWYgKG1hc2spICAgICAgICAgICAgICAgcmV0dXJuIG1hc2tcclxuXHJcbiAgICBmYWN0b3J5ID0gaW5zcGVjdG9yLm1hc2tGYWN0b3J5KClcclxuXHJcbiAgICBjb25zdCBtYXNrQ2xpY2sgICA9IGZhY3RvcnkuZ2VuKHsgYmFja2dyb3VuZDogJ2dyZWVuJywgYm9yZGVyOiAnMnB4IHNvbGlkIHB1cnBsZScgfSlcclxuICAgIGNvbnN0IG1hc2tIb3ZlciAgID0gZmFjdG9yeS5nZW4oeyBiYWNrZ3JvdW5kOiAnI2ZmYTgwMCcsIGJvcmRlcjogJzJweCBzb2xpZCBwdXJwbGUnIH0pXHJcblxyXG4gICAgYWRkTG9nb0ltZyhtYXNrQ2xpY2spXHJcbiAgICBhZGRMb2dvSW1nKG1hc2tIb3ZlcilcclxuXHJcbiAgICBjb25zb2xlLmxvZygnbWFza0NsaWNrJywgbWFza0NsaWNrKVxyXG5cclxuICAgIG1hc2sgPSB7IG1hc2tDbGljaywgbWFza0hvdmVyIH1cclxuXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1hc2tDbGljaylcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWFza0hvdmVyKVxyXG5cclxuICAgIHJldHVybiBtYXNrXHJcbiAgfVxyXG59KSgpXHJcblxyXG5jb25zdCBjcmVhdGVMb2dvSW1nID0gKCkgPT4ge1xyXG4gIC8vIE5vdGU6IEV4dC5leHRlbnNpb24uZ2V0VVJMIGlzIGF2YWlsYWJsZSBpbiBjb250ZW50IHNjcmlwdCwgYnV0IG5vdCBpbmplY3RlZCBqc1xyXG4gIC8vIFNvIHRoZXJlIGFyZSBjYXNlcyB3aGVuIGNvbnRlbnRfc2NyaXB0LmpzIGlzIHJ1biBhcyBpbmplY3RlZCBqcywgd2hlcmUgYEV4dC5leHRlbnNpb24uZ2V0VVJMYFxyXG4gIC8vIGlzIG5vdCBhdmFpbGFibGVcclxuICAvLyBXZWlyZCBlbm91Z2gsIGBFeHQuZXh0ZW5zaW9uLmdldFVSTGAgYWx3YXlzIHdvcmtzIHdlbGwgaW4gbWFjT1NcclxuICBjb25zdCB1cmwgICA9IEV4dC5leHRlbnNpb24uZ2V0VVJMID8gRXh0LmV4dGVuc2lvbi5nZXRVUkwoJ2xvZ28ucG5nJykgOiAnJ1xyXG4gIGNvbnN0IGltZyAgID0gbmV3IEltYWdlKClcclxuXHJcbiAgaW1nLnNyYyAgICAgPSB1cmxcclxuICByZXR1cm4gaW1nXHJcbn1cclxuXHJcbmNvbnN0IGFkZFdhaXRJbkNvbW1hbmQgPSAoY21kT2JqKSA9PiB7XHJcbiAgY29uc3QgeyBjbWQgfSA9IGNtZE9ialxyXG5cclxuICBzd2l0Y2ggKGNtZCkge1xyXG4gICAgY2FzZSAnY2xpY2snOlxyXG4gICAgY2FzZSAnY2xpY2tBdCc6XHJcbiAgICAgIHJldHVybiB7Li4uY21kT2JqLCBjbWQ6ICdjbGlja0FuZFdhaXQnLCB2YWx1ZTogJyd9XHJcblxyXG4gICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgcmV0dXJuIHsuLi5jbWRPYmosIGNtZDogJ3NlbGVjdEFuZFdhaXQnfVxyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBjbWRPYmpcclxuICB9XHJcbn1cclxuXHJcbi8vIHJlcG9ydCByZWNvcmRlZCBjb21tYW5kcyB0byBiYWNrZ3JvdW5kLlxyXG4vLyB0cmFuc2Zvcm0gYGxlYXZlYCBldmVudCB0byBjbGlja0FuZFdhaXQgLyBzZWxlY3RBbmRXYWl0IGV2ZW50IGJhc2VkIG9uIHRoZSBsYXN0IGNvbW1hbmRcclxuY29uc3QgcmVwb3J0Q29tbWFuZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3QgTEVBVkVfSU5URVJWQUwgID0gNTAwXHJcbiAgbGV0IGxhc3QgICAgICAgICAgICAgID0gbnVsbFxyXG4gIGxldCBsYXN0VGltZSAgICAgICAgICA9IG51bGxcclxuICBsZXQgdGltZXIgICAgICAgICAgICAgPSBudWxsXHJcblxyXG4gIHJldHVybiAob2JqKSA9PiB7XHJcbiAgICBvYmogPSB7Li4ub2JqLCB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmfVxyXG5cclxuICAgIGxvZygndG8gcmVwb3J0Jywgb2JqKVxyXG5cclxuICAgIC8vIENoYW5nZSBiYWNrIHRvIHRvcCBmcmFtZSBpZiBpdCB3YXMgcmVjb3JkaW5nIGluc2lkZVxyXG4gICAgaWYgKHN0YXRlLnJlY29yZGluZ0ZyYW1lU3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICBzdGF0ZS5yZWNvcmRpbmdGcmFtZVN0YWNrID0gW11cclxuXHJcbiAgICAgIHN1cGVyQ3NJcGMuYXNrKCdDU19SRUNPUkRfQUREX0NPTU1BTkQnLCB7XHJcbiAgICAgICAgY21kOiAnc2VsZWN0RnJhbWUnLFxyXG4gICAgICAgIHRhcmdldDogJ3JlbGF0aXZlPXRvcCcsXHJcbiAgICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZlxyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2gob29wcylcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKG9iai5jbWQpIHtcclxuICAgICAgY2FzZSAnbGVhdmUnOiB7XHJcbiAgICAgICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKG5ldyBEYXRlKCkgLSBsYXN0VGltZSkgPCBMRUFWRV9JTlRFUlZBTCkge1xyXG4gICAgICAgICAgb2JqID0gYWRkV2FpdEluQ29tbWFuZChsYXN0KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgICAgY2FzZSAnY2xpY2snOlxyXG4gICAgICBjYXNlICdjbGlja0F0JzpcclxuICAgICAgY2FzZSAnc2VsZWN0Jzoge1xyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBzdXBlckNzSXBjLmFzaygnQ1NfUkVDT1JEX0FERF9DT01NQU5EJywgb2JqKVxyXG4gICAgICAgICAgLmNhdGNoKG9vcHMpXHJcbiAgICAgICAgfSwgTEVBVkVfSU5URVJWQUwpXHJcblxyXG4gICAgICAgIGxhc3QgICAgICA9IG9ialxyXG4gICAgICAgIGxhc3RUaW1lICA9IG5ldyBEYXRlKClcclxuXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuXHJcbiAgICBsYXN0ICAgICAgPSBvYmpcclxuICAgIGxhc3RUaW1lICA9IG5ldyBEYXRlKClcclxuXHJcbiAgICBzdXBlckNzSXBjLmFzaygnQ1NfUkVDT1JEX0FERF9DT01NQU5EJywgb2JqKVxyXG4gICAgLmNhdGNoKG9vcHMpXHJcbiAgfVxyXG59KSgpXHJcblxyXG5jb25zdCBpc1ZhbGlkQ2xpY2sgPSAoZWwpID0+IHtcclxuICAvLyBOb3RlOiBhbGwgZWxlbWVudHMgYXJlIGFsbG93ZWQgdG8gYmUgcmVjb3JkZWQgd2hlbiBjbGlja2VkXHJcbiAgcmV0dXJuIHRydWVcclxuXHJcbiAgLy8gaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZmFsc2VcclxuICAvL1xyXG4gIC8vIGNvbnN0IHRhZyAgID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgLy8gY29uc3QgdHlwZSAgPSBlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxyXG4gIC8vIGNvbnN0IHJvbGUgID0gZWwuZ2V0QXR0cmlidXRlKCdyb2xlJylcclxuICAvL1xyXG4gIC8vIGlmICh0YWcgPT09ICdhJyB8fCB0YWcgPT09ICdidXR0b24nKSAgcmV0dXJuIHRydWVcclxuICAvLyBpZiAodGFnID09PSAnaW5wdXQnICYmIFsncmFkaW8nLCAnY2hlY2tib3gnXS5pbmRleE9mKHR5cGUpICE9PSAtMSkgIHJldHVybiB0cnVlXHJcbiAgLy8gaWYgKFsnbGluaycsICdidXR0b24nLCAnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHJvbGUpICE9PSAtMSkgICByZXR1cm4gdHJ1ZVxyXG4gIC8vXHJcbiAgLy8gcmV0dXJuIGlzVmFsaWRDbGljayhlbC5wYXJlbnROb2RlKVxyXG59XHJcblxyXG5jb25zdCBpc1ZhbGlkU2VsZWN0ID0gKGVsKSA9PiB7XHJcbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXHJcblxyXG4gIGlmIChbJ29wdGlvbicsICdzZWxlY3QnXS5pbmRleE9mKHRhZykgIT09IC0xKSByZXR1cm4gdHJ1ZVxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5jb25zdCBpc1ZhbGlkVHlwZSA9IChlbCkgPT4ge1xyXG4gIGNvbnN0IHRhZyAgID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgY29uc3QgdHlwZSAgPSBlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxyXG5cclxuICBpZiAodGFnID09PSAndGV4dGFyZWEnKSByZXR1cm4gdHJ1ZVxyXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgWydyYWRpbywgY2hlY2tib3gnXS5pbmRleE9mKHR5cGUpID09PSAtMSkgIHJldHVybiB0cnVlXHJcblxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5jb25zdCBoaWdobGlnaHREb20gPSAoJGRvbSwgdGltZW91dCkgPT4ge1xyXG4gIGNvbnN0IG1hc2sgPSBnZXRNYXNrKClcclxuXHJcbiAgaW5zcGVjdG9yLnNob3dNYXNrT3ZlcihtYXNrLm1hc2tDbGljaywgJGRvbSlcclxuXHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBpbnNwZWN0b3Iuc2V0U3R5bGUobWFzay5tYXNrQ2xpY2ssIHsgZGlzcGxheTogJ25vbmUnIH0pXHJcbiAgfSwgdGltZW91dCB8fCBNQVNLX0NMSUNLX0ZBREVfVElNRU9VVClcclxufVxyXG5cclxuY29uc3QgY3JlYXRlSGlnaGxpZ2h0UmVjdCA9IGZ1bmN0aW9uIChvcHRzID0ge30pIHtcclxuICBjb25zdCAkbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgY29uc3QgJHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gIGxldCB0aW1lclxyXG5cclxuICBpbnNwZWN0b3Iuc2V0U3R5bGUoJG1hc2ssIHtcclxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgekluZGV4OiAxMTAwMDEsXHJcbiAgICBib3JkZXI6ICcxcHggc29saWQgb3JhbmdlJyxcclxuICAgIGNvbG9yOiAnb3JhbmdlJyxcclxuICAgIGRpc3BsYXk6ICdub25lJyxcclxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xyXG4gIH0pXHJcblxyXG4gIGluc3BlY3Rvci5zZXRTdHlsZSgkdGV4dCwge1xyXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICB0b3A6IDAsXHJcbiAgICBsZWZ0OiAwLFxyXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC0xMDAlLCAtMTAwJSknLFxyXG4gICAgZm9udFNpemU6ICcxNHB4J1xyXG4gIH0pXHJcblxyXG4gICRtYXNrLmFwcGVuZENoaWxkKCR0ZXh0KVxyXG5cclxuICByZXR1cm4gKHJlY3QsIHRpbWVvdXQpID0+IHtcclxuICAgIGNsZWFyVGltZW91dCh0aW1lcilcclxuICAgICR0ZXh0LmlubmVyVGV4dCA9IHBhcnNlRmxvYXQocmVjdC5zY29yZSkudG9GaXhlZCgyKVxyXG5cclxuICAgIGluc3BlY3Rvci5zZXRTdHlsZSgkbWFzaywge1xyXG4gICAgICBkaXNwbGF5OiAgJ2Jsb2NrJyxcclxuICAgICAgdG9wOiAgICAgIGAke3JlY3QudG9wfXB4YCxcclxuICAgICAgbGVmdDogICAgIGAke3JlY3QubGVmdH1weGAsXHJcbiAgICAgIHdpZHRoOiAgICBgJHtyZWN0LndpZHRofXB4YCxcclxuICAgICAgaGVpZ2h0OiAgIGAke3JlY3QuaGVpZ2h0fXB4YCxcclxuICAgICAgLi4uKG9wdHMucmVjdFN0eWxlIHx8IHt9KVxyXG4gICAgfSlcclxuXHJcbiAgICBpbnNwZWN0b3Iuc2V0U3R5bGUoJHRleHQsIG9wdHMudGV4dFN0eWxlIHx8IHt9KVxyXG5cclxuICAgIGlmICghJG1hc2sucGFyZW50Tm9kZSkge1xyXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCRtYXNrKVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRzLnNjcm9sbEludG9WaWV3KSB7XHJcbiAgICAgICRtYXNrLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICdjZW50ZXInLCBiZWhhdmlvcjogJ3Ntb290aCcgfSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGltZW91dCAmJiB0aW1lb3V0ID4gMCkge1xyXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGluc3BlY3Rvci5zZXRTdHlsZSgkbWFzaywgeyBkaXNwbGF5OiAnbm9uZScgfSlcclxuICAgICAgfSwgdGltZW91dClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpbnNwZWN0b3Iuc2V0U3R5bGUoJG1hc2ssIHsgZGlzcGxheTogJ25vbmUnIH0pXHJcbiAgICAgICRtYXNrLnJlbW92ZSgpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBoaWdobGlnaHRSZWN0ID0gY3JlYXRlSGlnaGxpZ2h0UmVjdCgpXHJcblxyXG5jb25zdCBoaWdobGlnaHRSZWN0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3QgdG9wTWF0Y2hlZE9wdGlvbnMgPSB7XHJcbiAgICByZWN0U3R5bGU6IHtcclxuICAgICAgYm9yZGVyQ29sb3I6ICcjZmYwMGZmJyxcclxuICAgICAgY29sb3I6ICcjZmYwMGZmJ1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgZGVzdHJveVxyXG5cclxuICByZXR1cm4gKHJlY3RzLCB0aW1lb3V0KSA9PiB7XHJcbiAgICBpZiAoZGVzdHJveSkgIGRlc3Ryb3koKVxyXG4gICAgY29uc3QgZGVzdHJveUZucyA9IHJlY3RzLm1hcCgocmVjdCwgaSkgPT4gY3JlYXRlSGlnaGxpZ2h0UmVjdChpID09PSAwID8gdG9wTWF0Y2hlZE9wdGlvbnMgOiB7fSkocmVjdCwgdGltZW91dCkpXHJcbiAgICBkZXN0cm95ID0gKCkgPT4gZGVzdHJveUZucy5mb3JFYWNoKGRlc3Ryb3kgPT4gZGVzdHJveSgpKVxyXG4gICAgcmV0dXJuIGRlc3Ryb3lcclxuICB9XHJcbn0pKClcclxuXHJcbmNvbnN0IG9uQ2xpY2sgPSAoZSkgPT4ge1xyXG4gIGlmICghaXNWYWxpZENsaWNrKGUudGFyZ2V0KSkgIHJldHVyblxyXG5cclxuICBjb25zdCB0YXJnZXRJbmZvID0gaW5zcGVjdG9yLmdldExvY2F0b3IoZS50YXJnZXQsIHRydWUpXHJcblxyXG4gIGxvZygnb25DbGljaywgc3dpdGNoICBjYXNlJywgc3RhdGUuY29uZmlnLnJlY29yZENsaWNrVHlwZSlcclxuICBzd2l0Y2ggKHN0YXRlLmNvbmZpZy5yZWNvcmRDbGlja1R5cGUpIHtcclxuICAgIGNhc2UgJ2NsaWNrQXQnOlxyXG4gICAgICByZXBvcnRDb21tYW5kKHtcclxuICAgICAgICAuLi50YXJnZXRJbmZvLFxyXG4gICAgICAgIGNtZDogJ2NsaWNrQXQnLFxyXG4gICAgICAgIHZhbHVlOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlXHJcbiAgICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKGNsaWVudFggLSBsZWZ0KVxyXG4gICAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQoY2xpZW50WSAtIHRvcClcclxuXHJcbiAgICAgICAgICByZXR1cm4gYCR7eH0sJHt5fWBcclxuICAgICAgICB9KSgpXHJcbiAgICAgIH0pXHJcbiAgICAgIGJyZWFrXHJcblxyXG4gICAgY2FzZSAnY2xpY2snOlxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmVwb3J0Q29tbWFuZCh7XHJcbiAgICAgICAgLi4udGFyZ2V0SW5mbyxcclxuICAgICAgICBjbWQ6ICdjbGljaydcclxuICAgICAgfSlcclxuICAgICAgYnJlYWtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IG9uQ2hhbmdlID0gKGUpID0+IHtcclxuICBpZiAoaXNWYWxpZFNlbGVjdChlLnRhcmdldCkpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWVcclxuICAgIGNvbnN0ICRvcHRpb24gPSBBcnJheS5mcm9tKGUudGFyZ2V0LmNoaWxkcmVuKS5maW5kKCRvcCA9PiAkb3AudmFsdWUgPT09IHZhbHVlKVxyXG5cclxuICAgIHJlcG9ydENvbW1hbmQoe1xyXG4gICAgICBjbWQ6ICdzZWxlY3QnLFxyXG4gICAgICB2YWx1ZTogJ2xhYmVsPScgKyBpbnNwZWN0b3IuZG9tVGV4dCgkb3B0aW9uKS50cmltKCksXHJcbiAgICAgIC4uLmluc3BlY3Rvci5nZXRMb2NhdG9yKGUudGFyZ2V0LCB0cnVlKVxyXG4gICAgfSlcclxuICB9IGVsc2UgaWYgKGlzVmFsaWRUeXBlKGUudGFyZ2V0KSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSAoZS50YXJnZXQudmFsdWUgfHwgJycpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxyXG5cclxuICAgIGVuY3J5cHRJZk5lZWRlZCh2YWx1ZSwgZS50YXJnZXQpXHJcbiAgICAudGhlbihyZWFsVmFsdWUgPT4ge1xyXG4gICAgICByZXBvcnRDb21tYW5kKHtcclxuICAgICAgICBjbWQ6ICd0eXBlJyxcclxuICAgICAgICB2YWx1ZTogcmVhbFZhbHVlLFxyXG4gICAgICAgIC4uLmluc3BlY3Rvci5nZXRMb2NhdG9yKGUudGFyZ2V0LCB0cnVlKVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IG9uQ29udGVudEVkaXRhYmxlQ2hhbmdlID0gKGUpID0+IHtcclxuICByZXBvcnRDb21tYW5kKHtcclxuICAgIGNtZDogICAgJ2VkaXRDb250ZW50JyxcclxuICAgIHZhbHVlOiAgZS50YXJnZXQuaW5uZXJIVE1MLFxyXG4gICAgLi4uaW5zcGVjdG9yLmdldExvY2F0b3IoZS50YXJnZXQsIHRydWUpXHJcbiAgfSlcclxufVxyXG5cclxuY29uc3Qgb25EcmFnRHJvcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgbGV0IGRyYWdTdGFydCA9IG51bGxcclxuXHJcbiAgcmV0dXJuIChlKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xyXG4gICAgICBjYXNlICdkcmFnc3RhcnQnOiB7XHJcbiAgICAgICAgZHJhZ1N0YXJ0ID0gaW5zcGVjdG9yLmdldExvY2F0b3IoZS50YXJnZXQsIHRydWUpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICBjYXNlICdkcm9wJzoge1xyXG4gICAgICAgIGlmICghZHJhZ1N0YXJ0KSByZXR1cm5cclxuICAgICAgICBjb25zdCB0bXAgICA9IGluc3BlY3Rvci5nZXRMb2NhdG9yKGUudGFyZ2V0LCB0cnVlKVxyXG4gICAgICAgIGNvbnN0IGRyb3AgID0ge1xyXG4gICAgICAgICAgdmFsdWU6IHRtcC50YXJnZXQsXHJcbiAgICAgICAgICB2YWx1ZU9wdGlvbnM6IHRtcC50YXJnZXRPcHRpb25zXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXBvcnRDb21tYW5kKHtcclxuICAgICAgICAgIGNtZDogJ2RyYWdBbmREcm9wVG9PYmplY3QnLFxyXG4gICAgICAgICAgLi4uZHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgLi4uZHJvcFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGRyYWdTdGFydCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSkoKVxyXG5cclxuY29uc3Qgb25MZWF2ZSA9IChlKSA9PiB7XHJcbiAgcmVwb3J0Q29tbWFuZCh7XHJcbiAgICBjbWQ6ICdsZWF2ZScsXHJcbiAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICB2YWx1ZTogbnVsbFxyXG4gIH0pXHJcblxyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgcmVwb3J0Q29tbWFuZCh7XHJcbiAgICAgIGNtZDogJ3B1bGxiYWNrJyxcclxuICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICB2YWx1ZTogbnVsbFxyXG4gICAgfSlcclxuICB9LCA4MDApXHJcbn1cclxuXHJcbmxldCB1bmJpbmRDb250ZW50RWRpdGFibGVFdmVudHNcclxuXHJcbmNvbnN0IGJpbmRFdmVudHNUb1JlY29yZCA9ICgpID0+IHtcclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIHRydWUpXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0Jywgb25EcmFnRHJvcCwgdHJ1ZSlcclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgb25EcmFnRHJvcCwgdHJ1ZSlcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgb25MZWF2ZSwgdHJ1ZSlcclxuXHJcbiAgdW5iaW5kQ29udGVudEVkaXRhYmxlRXZlbnRzID0gYmluZENvbnRlbnRFZGl0YWJsZUNoYW5nZSh7IG9uQ2hhbmdlOiBvbkNvbnRlbnRFZGl0YWJsZUNoYW5nZSB9KVxyXG59XHJcblxyXG5jb25zdCB1bmJpbmRFdmVudHNUb1JlY29yZCA9ICgpID0+IHtcclxuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpXHJcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIHRydWUpXHJcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0Jywgb25EcmFnRHJvcCwgdHJ1ZSlcclxuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgb25EcmFnRHJvcCwgdHJ1ZSlcclxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgb25MZWF2ZSwgdHJ1ZSlcclxuXHJcbiAgaWYgKHVuYmluZENvbnRlbnRFZGl0YWJsZUV2ZW50cykge1xyXG4gICAgdW5iaW5kQ29udGVudEVkaXRhYmxlRXZlbnRzKClcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHdhaXRGb3JEb21SZWFkeSA9IChhY2N1cmF0ZSkgPT4ge1xyXG4gIHJldHVybiB1bnRpbCgnZG9tIHJlYWR5JywgKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFzczogWydjb21wbGV0ZScsICdpbnRlcmFjdGl2ZSddLnNsaWNlKDAsIGFjY3VyYXRlID8gMSA6IDIpLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgIT09IC0xLFxyXG4gICAgICByZXN1bHQ6IHRydWVcclxuICAgIH1cclxuICB9LCAxMDAwLCA2MDAwICogMTApXHJcbn1cclxuXHJcbmNvbnN0IGJyb2FkY2FzdFRvQWxsRnJhbWVzID0gKGFjdGlvbiwgZGF0YSkgPT4ge1xyXG4gIC8vIElNUE9SVEFOVDogYnJvYWRjYXN0IHN0YXR1cyBjaGFuZ2UgdG8gYWxsIGZyYW1lcyBpbnNpZGVcclxuICBjb25zdCBmcmFtZXMgPSB3aW5kb3cuZnJhbWVzXHJcblxyXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIHBvc3RNZXNzYWdlKGZyYW1lc1tpXSwgd2luZG93LCB7XHJcbiAgICAgIGFjdGlvbixcclxuICAgICAgZGF0YVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHVwZGF0ZVN0YXR1cyA9IChhcmdzKSA9PiB7XHJcbiAgaWYgKCFhcmdzLnN0YXR1cykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTRVRfU1RBVFVTOiBtaXNzaW5nIGFyZ3Muc3RhdHVzJylcclxuICB9XHJcbiAgaWYgKCFDLkNPTlRFTlRfU0NSSVBUX1NUQVRVU1thcmdzLnN0YXR1c10pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU0VUX1NUQVRVUzogaW52YWxpZCBhcmdzLnN0YXR1cyAtICcgKyBhcmdzLnN0YXR1cylcclxuICB9XHJcblxyXG4gIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcclxuICAgIHN0YXR1czogYXJncy5zdGF0dXNcclxuICB9KVxyXG5cclxuICBpZiAoYXJncy5zdGF0dXMgPT09IEMuQ09OVEVOVF9TQ1JJUFRfU1RBVFVTLk5PUk1BTCB8fFxyXG4gICAgICBhcmdzLnN0YXR1cyA9PT0gQy5DT05URU5UX1NDUklQVF9TVEFUVVMuUkVDT1JESU5HKSB7XHJcbiAgICBiaW5kRXZlbnRzVG9SZWNvcmQoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB1bmJpbmRFdmVudHNUb1JlY29yZCgpXHJcbiAgfVxyXG5cclxuICAvLyByZXBsYWNlIGFsZXJ0L2NvbmZpcm0vcHJvbXB0IHdpdGggb3VyIHZlcnNpb24gd2hlbiBwbGF5aW5nXHJcbiAgaWYgKGFyZ3Muc3RhdHVzID09PSBDLkNPTlRFTlRfU0NSSVBUX1NUQVRVUy5QTEFZSU5HKSB7XHJcbiAgICBoYWNrQWxlcnRDb25maXJtUHJvbXB0KClcclxuICB9IGVsc2Uge1xyXG4gICAgcmVzdG9yZUFsZXJ0Q29uZmlybVByb21wdCgpXHJcbiAgfVxyXG5cclxuICAvLyBOb3RlOiBjbGVhciByZWNvcmRpbmcgZnJhbWUgc3RhY2sgd2hlbmV2ZXIgaXQgc3RvcHMgcmVjb3JkaW5nXHJcbiAgaWYgKGFyZ3Muc3RhdHVzID09PSBDLkNPTlRFTlRfU0NSSVBUX1NUQVRVUy5OT1JNQUwpIHtcclxuICAgIHN0YXRlLnJlY29yZGluZ0ZyYW1lU3RhY2sgPSBbXVxyXG4gICAgc3RhdGUucGxheWluZ0ZyYW1lID0gd2luZG93XHJcbiAgfVxyXG5cclxuICAvLyBJTVBPUlRBTlQ6IGJyb2FkY2FzdCBzdGF0dXMgY2hhbmdlIHRvIGFsbCBmcmFtZXMgaW5zaWRlXHJcbiAgYnJvYWRjYXN0VG9BbGxGcmFtZXMoJ1NFVF9TVEFUVVMnLCBhcmdzKVxyXG59XHJcblxyXG5jb25zdCBiaW5kSVBDTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgLy8gTm90ZTogbmVlZCB0byBjaGVjayBjc0lwYyBpbiBjYXNlIGl0J3MgYSBub25lLXNyYyBpZnJhbWUgaW50byB3aGljaCB3ZVxyXG4gIC8vIGluamVjdCBjb250ZW50X3NjcmlwdC5qcy4gSXQgaGFzIG5vIGFjY2VzcyB0byBjaHJvbWUgYXBpLCB0aHVzIG5vIGNzSXBjIGF2YWlsYWJsZVxyXG4gIGlmICghY3NJcGMpIHJldHVyblxyXG5cclxuICAvLyBOb3RlOiBjc0lwYyBpbnN0ZWFkIG9mIHN1cGVySXBjLCBiZWNhdXNlIG9ubHkgdG9wIHdpbmRvdyBpcyBhYmxlXHJcbiAgLy8gdG8gbGlzdGVuIHRvIGlwYyBldmVudHMgZnJvbSBiZ1xyXG4gIGNzSXBjLm9uQXNrKChjbWQsIGFyZ3MpID0+IHtcclxuICAgIGxvZyhjbWQsIGFyZ3MpXHJcblxyXG4gICAgc3dpdGNoIChjbWQpIHtcclxuICAgICAgY2FzZSAnSEVBUlRfQkVBVCc6XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuXHJcbiAgICAgIGNhc2UgJ1NFVF9TVEFUVVMnOiB7XHJcbiAgICAgICAgdXBkYXRlU3RhdHVzKGFyZ3MpXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSAnRE9NX1JFQURZJzpcclxuICAgICAgICByZXR1cm4gd2FpdEZvckRvbVJlYWR5KGZhbHNlKVxyXG5cclxuICAgICAgY2FzZSAnUlVOX0NPTU1BTkQnOlxyXG4gICAgICAgIHJldHVybiBydW5Db21tYW5kKGFyZ3MuY29tbWFuZClcclxuICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAvLyBNYXJrIHRoYXQgdGhlcmUgaXMgYWxyZWFkeSBhdCBsZWFzdCBvbmUgY29tbWFuZCBydW5cclxuICAgICAgICAgIHdpbmRvdy5ub0NvbW1hbmRzWWV0ID0gZmFsc2VcclxuXHJcbiAgICAgICAgICBsb2cuZXJyb3IoZS5zdGFjaylcclxuICAgICAgICAgIHRocm93IGVcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgLy8gTWFyayB0aGF0IHRoZXJlIGlzIGFscmVhZHkgYXQgbGVhc3Qgb25lIGNvbW1hbmQgcnVuXHJcbiAgICAgICAgICB3aW5kb3cubm9Db21tYW5kc1lldCA9IGZhbHNlXHJcblxyXG4gICAgICAgICAgaWYgKHN0YXRlLnBsYXlpbmdGcmFtZSAhPT0gd2luZG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGlzSUZyYW1lOiB0cnVlIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4geyBkYXRhIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgY2FzZSAnRklORF9ET00nOiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0ICRlbCA9IGdldEVsZW1lbnRCeUxvY2F0b3IoYXJncy5sb2NhdG9yKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ0hJR0hMSUdIVF9ET00nOiB7XHJcbiAgICAgICAgY29uc3QgJGVsID0gZ2V0RWxlbWVudEJ5TG9jYXRvcihhcmdzLmxvY2F0b3IpXHJcblxyXG4gICAgICAgIGlmICgkZWwpIHtcclxuICAgICAgICAgICRlbC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnY2VudGVyJyB9KVxyXG4gICAgICAgICAgaGlnaGxpZ2h0RG9tKCRlbClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ0hJR0hMSUdIVF9SRUNUJzoge1xyXG4gICAgICAgIGhpZ2hsaWdodFJlY3QoYXJncy5zY29yZWRSZWN0KVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ0hJR0hMSUdIVF9SRUNUUyc6IHtcclxuICAgICAgICBoaWdobGlnaHRSZWN0cyhhcmdzLnNjb3JlZFJlY3RzKVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ0NMRUFSX1ZJU0lPTl9SRUNUUyc6IHtcclxuICAgICAgICAvLyBOb3RlOiBpdCB3aWxsIGNsZWFyIHByZXZpb3VzIHJlY3RzXHJcbiAgICAgICAgaGlnaGxpZ2h0UmVjdHMoW10pXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSAnSEFDS19BTEVSVCc6IHtcclxuICAgICAgICBoYWNrQWxlcnRDb25maXJtUHJvbXB0KClcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdNQVJLX05PX0NPTU1BTkRTX1lFVCc6IHtcclxuICAgICAgICB3aW5kb3cubm9Db21tYW5kc1lldCA9IHRydWVcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdTQ1JFRU5TSE9UX1BBR0VfSU5GTyc6IHtcclxuICAgICAgICByZXR1cm4gY2FwdHVyZUNsaWVudEFQSS5nZXRQYWdlSW5mbygpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ1NUQVJUX0NBUFRVUkVfRlVMTF9TQ1JFRU5TSE9UJzoge1xyXG4gICAgICAgIHJldHVybiBjYXB0dXJlQ2xpZW50QVBJLnN0YXJ0Q2FwdHVyZShhcmdzIHx8IHt9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdFTkRfQ0FQVFVSRV9GVUxMX1NDUkVFTlNIT1QnOiB7XHJcbiAgICAgICAgcmV0dXJuIGNhcHR1cmVDbGllbnRBUEkuZW5kQ2FwdHVyZShhcmdzLnBhZ2VJbmZvKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdTQ1JPTExfUEFHRSc6IHtcclxuICAgICAgICByZXR1cm4gY2FwdHVyZUNsaWVudEFQSS5zY3JvbGxQYWdlKGFyZ3Mub2Zmc2V0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdUQUJfQUNUSVZBVEVEJzoge1xyXG4gICAgICAgIGxvYWRDb25maWcoKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdTRUxFQ1RfU0NSRUVOX0FSRUEnOiB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdEFyZWEoe1xyXG4gICAgICAgICAgcHJvbWlzZTogIHRydWUsXHJcbiAgICAgICAgICBkb25lOiAgICAgKHJlY3QsIGJvdW5kaW5nUmVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsb2coJ1NFTEVDVF9TQ1JFRU5fQVJFQSAgLSBzZWxlY3RBcmVhJywgcmVjdCwgYm91bmRpbmdSZWN0KVxyXG4gICAgICAgICAgICByZXR1cm4gY3NJcGMuYXNrKCdDU19TQ1JFRU5fQVJFQV9TRUxFQ1RFRCcsIHtcclxuICAgICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICB4OiBib3VuZGluZ1JlY3QueCxcclxuICAgICAgICAgICAgICAgIHk6IGJvdW5kaW5nUmVjdC55LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogd2luZG93LmRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY21kIG5vdCBzdXBwb3J0ZWQ6ICcgKyBjbWQpXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuY29uc3QgYmluZEV2ZW50c1RvSW5zcGVjdCA9ICgpID0+IHtcclxuICAvLyBCaW5kIGNsaWNrIGV2ZW50cyBmb3IgaW5zcGVjdGluZ1xyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgIHN3aXRjaCAoc3RhdGUuc3RhdHVzKSB7XHJcbiAgICAgIGNhc2UgQy5DT05URU5UX1NDUklQVF9TVEFUVVMuSU5TUEVDVElORzoge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgICAgICBjb25zdCBtYXNrID0gZ2V0TWFzaygpXHJcblxyXG4gICAgICAgIGluc3BlY3Rvci5zZXRTdHlsZShtYXNrLm1hc2tIb3ZlciwgeyBkaXNwbGF5OiAnbm9uZScgfSlcclxuICAgICAgICBpbnNwZWN0b3Iuc2hvd01hc2tPdmVyKG1hc2subWFza0NsaWNrLCBlLnRhcmdldClcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpbnNwZWN0b3Iuc2V0U3R5bGUobWFzay5tYXNrQ2xpY2ssIHsgZGlzcGxheTogJ25vbmUnIH0pXHJcbiAgICAgICAgfSwgTUFTS19DTElDS19GQURFX1RJTUVPVVQpXHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcclxuICAgICAgICAgIHN0YXR1czogQy5DT05URU5UX1NDUklQVF9TVEFUVVMuTk9STUFMXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1cGVyQ3NJcGMuYXNrKCdDU19ET05FX0lOU1BFQ1RJTkcnLCB7XHJcbiAgICAgICAgICBsb2NhdG9ySW5mbzogaW5zcGVjdG9yLmdldExvY2F0b3IoZS50YXJnZXQsIHRydWUpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2gob29wcylcclxuICAgICAgfVxyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIC8vIGJpbmQgbW91c2Ugb3ZlciBldmVudCBmb3IgYXBwbHlpbmcgZm9yIGEgaW5zcGVjdG9yIHJvbGVcclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xyXG4gICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gQy5DT05URU5UX1NDUklQVF9TVEFUVVMuTk9STUFMKSB7XHJcbiAgICAgIHJldHVybiBzdXBlckNzSXBjLmFzaygnQ1NfQUNUSVZBVEVfTUUnLCB7fSlcclxuICAgICAgLmNhdGNoKG9vcHMpXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgLy8gYmluZCBtb3VzZSBtb3ZlIGV2ZW50IHRvIHNob3cgaG92ZXIgbWFzayBpbiBpbnNwZWN0aW5nXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcclxuICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09IEMuQ09OVEVOVF9TQ1JJUFRfU1RBVFVTLklOU1BFQ1RJTkcpICByZXR1cm5cclxuXHJcbiAgICBjb25zdCBtYXNrID0gZ2V0TWFzaygpXHJcbiAgICBpbnNwZWN0b3Iuc2hvd01hc2tPdmVyKG1hc2subWFza0hvdmVyLCBlLnRhcmdldClcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBiaW5kT25NZXNzYWdlID0gKCkgPT4ge1xyXG4gIG9uTWVzc2FnZSh3aW5kb3csICh7IGFjdGlvbiwgZGF0YSB9LCB7IHNvdXJjZSB9KSA9PiB7XHJcbiAgICBsb2coJ29uTWVzc2FnZScsIGFjdGlvbiwgZGF0YSwgc291cmNlKVxyXG5cclxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XHJcbiAgICAgIGNhc2UgJ1NFVF9TVEFUVVMnOlxyXG4gICAgICAgIHVwZGF0ZVN0YXR1cyhkYXRhKVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcblxyXG4gICAgICBjYXNlICdVUERBVEVfQ09ORklHJzoge1xyXG4gICAgICAgIHN0YXRlLmNvbmZpZyA9IGRhdGFcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpbm5lciBmcmFtZXMgbWF5IHJlY2VpdmUgdGhpcyBtZXNzYWdlIHdoZW4gdGhlcmUgYXJlXHJcbiAgICAgIC8vIHNvbWUgcHJldmlvdXMgYHNlbGVjdEZyYW1lYCBjb21tYW5kXHJcbiAgICAgIGNhc2UgJ1JVTl9DT01NQU5EJzpcclxuICAgICAgICAvLyBydW5Db21tYW5kIHdpbGwgZGVjaWRlIHdoZXRoZXIgdG8gcnVuIGluIHRoaXMgd2luZG93IG9yIHBhc3Mgb25cclxuICAgICAgICByZXR1cm4gcnVuQ29tbWFuZChkYXRhKVxyXG5cclxuICAgICAgLy8gaW5uZXIgZnJhbWVzIHNlbmQgSVBDX0NBTEwgdG8gYmFja2dyb3VuZCxcclxuICAgICAgLy8gSXQgd2lsbCBnbyBzdGVwIGJ5IHN0ZXAgdXAgdG8gdGhlIHRvcG1vc3QgZnJhbWUsIHdoaWNoIGhhc1xyXG4gICAgICAvLyB0aGUgYWNjZXNzIHRvIGNzSXBjXHJcbiAgICAgIGNhc2UgJ0lQQ19DQUxMJzpcclxuICAgICAgICAvLyBXaGVuIHJlY29yZGluZywgbmVlZCB0byBjYWxjdWxhdGUgYHNlbGVjdEZyYW1lYCBieSBvdXJzZWx2ZXNcclxuICAgICAgICAvLyAqIGZvciBpbm5lciBmcmFtZXMsIGFkZCBjdXJyZW50IGZyYW1lIGxvY2F0b3IgdG8gZnJhbWUgc3RhY2tcclxuICAgICAgICAvLyAqIGZvciB0b3AgZnJhbWUsIHNlbmQgYHNlbGVjdEZyYW1lYCBjb21tYW5kcyBiZWZvcmUgdGhlIG9yaWdpbmFsIGNvbW1hbmRcclxuICAgICAgICAvLyAgIGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgZnJhbWUgc3RhY2tcclxuICAgICAgICBpZiAoZGF0YS5pcGNBY3Rpb24gPT09ICdDU19SRUNPUkRfQUREX0NPTU1BTkQnICYmIGRhdGEuaXBjRGF0YS5jbWQgIT09ICdwdWxsYmFjaycpIHtcclxuICAgICAgICAgIC8vIE5vdGU6IERvIG5vdCBzZW5kIGFueSBSRUNPUkRfQUREX0NPTU1BTkQgaW4gcGxheWluZyBtb2RlXHJcbiAgICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSBDLkNPTlRFTlRfU0NSSVBUX1NUQVRVUy5QTEFZSU5HKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRhdGEgPSB1cGRhdGVJbihcclxuICAgICAgICAgICAgWydpcGNEYXRhJywgJ2ZyYW1lU3RhY2snXSxcclxuICAgICAgICAgICAgKHN0YWNrID0gW10pID0+IFtpbnNwZWN0b3IuZ2V0RnJhbWVMb2NhdG9yKHNvdXJjZSwgd2luZG93KSwgLi4uc3RhY2tdLFxyXG4gICAgICAgICAgICBkYXRhXHJcbiAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgaWYgKHdpbmRvdy50b3AgPT09IHdpbmRvdykge1xyXG4gICAgICAgICAgICBjYWxjU2VsZWN0RnJhbWVDbWRzKGRhdGEuaXBjRGF0YS5mcmFtZVN0YWNrKS5mb3JFYWNoKGNtZCA9PiB7XHJcbiAgICAgICAgICAgICAgY3NJcGMuYXNrKCdDU19SRUNPUkRfQUREX0NPTU1BTkQnLCBjbWQpXHJcbiAgICAgICAgICAgICAgLmNhdGNoKG9vcHMpXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5yZWNvcmRpbmdGcmFtZVN0YWNrID0gZGF0YS5pcGNEYXRhLmZyYW1lU3RhY2tcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cudG9wID09PSB3aW5kb3cpIHtcclxuICAgICAgICAgIHJldHVybiBjc0lwYy5hc2soZGF0YS5pcGNBY3Rpb24sIGRhdGEuaXBjRGF0YSlcclxuICAgICAgICAgIC5jYXRjaChvb3BzKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2Uod2luZG93LnBhcmVudCwgd2luZG93LCB7IGFjdGlvbiwgZGF0YSB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgJ1JFU0VUX1BMQVlJTkdfRlJBTUUnOiB7XHJcbiAgICAgICAgc3RhdGUucGxheWluZ0ZyYW1lID0gd2luZG93XHJcblxyXG4gICAgICAgIC8vIHBhc3Mgb24gUkVTRVRfUExBWUlOR19GUkFNRSB0byBwYXJlbnQsIGFsbCB0aGUgd2F5IHRpbGwgdG9wIHdpbmRvd1xyXG4gICAgICAgIGlmIChkYXRhID09PSAnVE9QJyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cpIHtcclxuICAgICAgICAgIHBvc3RNZXNzYWdlKHdpbmRvdy5wYXJlbnQsIHdpbmRvdywge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdSRVNFVF9QTEFZSU5HX0ZSQU1FJyxcclxuICAgICAgICAgICAgZGF0YTogJ1RPUCdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXNlICdTT1VSQ0VfUEFHRV9PRkZTRVQnOiB7XHJcbiAgICAgICAgY29uc3QgJGZyYW1lcyA9IFtcclxuICAgICAgICAgIC4uLkFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lmcmFtZScpKSxcclxuICAgICAgICAgIC4uLkFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZyYW1lJykpXHJcbiAgICAgICAgXVxyXG4gICAgICAgIGNvbnN0ICRmcmFtZUVsZW1lbnQgPSAkZnJhbWVzLmZpbmQoJGZyYW1lID0+ICRmcmFtZS5jb250ZW50V2luZG93ID09PSBzb3VyY2UpXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ICAgICAgICA9IGluc3BlY3Rvci5vZmZzZXQoJGZyYW1lRWxlbWVudCwgdHJ1ZSlcclxuICAgICAgICBjb25zdCB4ICAgICAgICAgICAgID0gb2Zmc2V0LmxlZnRcclxuICAgICAgICBjb25zdCB5ICAgICAgICAgICAgID0gb2Zmc2V0LnRvcFxyXG4gICAgICAgIGxvZygnU09VUkNFX1BBR0VfT0ZGU0VULCBpZnJhbWVET00nLCAkZnJhbWVFbGVtZW50KVxyXG5cclxuICAgICAgICBpZiAod2luZG93LnRvcCA9PT0gd2luZG93KSB7XHJcbiAgICAgICAgICByZXR1cm4geyB4LCB5IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwb3N0TWVzc2FnZSh3aW5kb3cucGFyZW50LCB3aW5kb3csIHtcclxuICAgICAgICAgIGFjdGlvbjogJ1NPVVJDRV9QQUdFX09GRlNFVCcsXHJcbiAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4ocGFyZW50T2Zmc2V0ID0+IHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHggKyBwYXJlbnRPZmZzZXQueCxcclxuICAgICAgICAgICAgeTogeSArIHBhcmVudE9mZnNldC55XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FzZSAnU09VUkNFX0JPVU5ESU5HX0JPWF9PRkZTRVQnOiB7XHJcbiAgICAgICAgY29uc3QgJGZyYW1lcyA9IFtcclxuICAgICAgICAgIC4uLkFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lmcmFtZScpKSxcclxuICAgICAgICAgIC4uLkFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZyYW1lJykpXHJcbiAgICAgICAgXVxyXG4gICAgICAgIGNvbnN0ICRmcmFtZUVsZW1lbnQgPSAkZnJhbWVzLmZpbmQoJGZyYW1lID0+ICRmcmFtZS5jb250ZW50V2luZG93ID09PSBzb3VyY2UpXHJcbiAgICAgICAgY29uc3QgcmVjdCA9ICRmcmFtZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy50b3AgPT09IHdpbmRvdykge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogcmVjdC54LFxyXG4gICAgICAgICAgICB5OiByZWN0LnlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwb3N0TWVzc2FnZSh3aW5kb3cucGFyZW50LCB3aW5kb3csIHtcclxuICAgICAgICAgIGFjdGlvbjogJ1NPVVJDRV9CT1VORElOR19CT1hfT0ZGU0VUJyxcclxuICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihwYXJlbnRPZmZzZXQgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogcmVjdC54ICsgcGFyZW50T2Zmc2V0LngsXHJcbiAgICAgICAgICAgIHk6IHJlY3QueSArIHBhcmVudE9mZnNldC55XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmNvbnN0IGJpbmRJbnZva2VFdmVudCA9ICgpID0+IHtcclxuICAvLyBNYWNyb3NcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2FudHVSdW5NYWNybycsIChlKSA9PiB7XHJcbiAgICBsb2coJ2ludm9rZSBldmVudCcsIGUpXHJcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2thbnR1SW52b2tlU3VjY2VzcycpKVxyXG5cclxuICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJzZVF1ZXJ5KHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpXHJcbiAgICBjc0lwYy5hc2soJ0NTX0lOVk9LRScsIHsgdGVzdENhc2U6IGUuZGV0YWlsLCBvcHRpb25zOiBxdWVyaWVzIH0pXHJcbiAgICAuY2F0Y2goZSA9PiBhbGVydCgnW2thbnR1XSAnICsgZS5tZXNzYWdlKSlcclxuICB9KVxyXG5cclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2FudHVTYXZlQW5kUnVuTWFjcm8nLCAoZSkgPT4ge1xyXG4gICAgbG9nKCdzYXZlIGFuZCBydW4gbWFjcm8gZXZlbnQnLCBlKVxyXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdrYW50dUludm9rZVN1Y2Nlc3MnKSlcclxuXHJcbiAgICBjb25zdCBxdWVyaWVzID0gcGFyc2VRdWVyeSh3aW5kb3cubG9jYXRpb24uc2VhcmNoKVxyXG4gICAgY29uc3QgZGlyZWN0ICA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAhIXF1ZXJpZXNbJ2RpcmVjdCddXHJcbiAgICBjb25zdCBhZ3JlZSAgID0gZGlyZWN0IHx8IGNvbmZpcm0oJ0thbnR1OiBEbyB5b3Ugd2FudCB0byBpbXBvcnQgYW5kIHJ1biB0aGlzIG1hY3JvP1xcblxcbk5vdGU6IFRvIHJ1biB0aGUgbWFjcm8gd2l0aG91dCB0aGlzIGNvbmZpcm1hdGlvbiBib3gsIGFkZCB0aGUgXFwnP2RpcmVjdD0xXFwnIHN3aXRjaCB0byB0aGUgVVJMLiBFeGFtcGxlOiBmaWxlOi8vL3h4L3h4L21hY3JvLmh0bWw/ZGlyZWN0PTEnKVxyXG5cclxuICAgIGlmIChhZ3JlZSkge1xyXG4gICAgICBjc0lwYy5hc2soJ0NTX0lNUE9SVF9IVE1MX0FORF9JTlZPS0UnLCB7Li4uZS5kZXRhaWwsIGZyb206ICdodG1sJywgb3B0aW9uczogcXVlcmllc30pXHJcbiAgICAgIC5jYXRjaChlID0+IGFsZXJ0KCdba2FudHVdICcgKyBlLm1lc3NhZ2UpKVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIC8vIFRlc3QgU3VpdGVzXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2thbnR1UnVuVGVzdFN1aXRlJywgKGUpID0+IHtcclxuICAgIGxvZygnaW52b2tlIGV2ZW50JywgZSlcclxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgna2FudHVJbnZva2VTdWNjZXNzJykpXHJcblxyXG4gICAgY29uc3QgcXVlcmllcyA9IHBhcnNlUXVlcnkod2luZG93LmxvY2F0aW9uLnNlYXJjaClcclxuICAgIGNzSXBjLmFzaygnQ1NfSU5WT0tFJywgeyB0ZXN0U3VpdGU6IGUuZGV0YWlsLCBvcHRpb25zOiBxdWVyaWVzIH0pXHJcbiAgICAuY2F0Y2goZSA9PiBhbGVydCgnW2thbnR1XSAnICsgZS5tZXNzYWdlKSlcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBoYWNrQWxlcnRDb25maXJtUHJvbXB0ID0gKGRvYyA9IGRvY3VtZW50KSA9PiB7XHJcbiAgY29uc3Qgc2NyaXB0ID0gYFxyXG4gICAgaWYgKCF3aW5kb3cub2xkQWxlcnQpICAgICB3aW5kb3cub2xkQWxlcnQgICA9IHdpbmRvdy5hbGVydFxyXG4gICAgaWYgKCF3aW5kb3cub2xkQ29uZmlybSkgICB3aW5kb3cub2xkQ29uZmlybSA9IHdpbmRvdy5jb25maXJtXHJcbiAgICBpZiAoIXdpbmRvdy5vbGRQcm9tcHQpICAgIHdpbmRvdy5vbGRQcm9tcHQgID0gd2luZG93LnByb21wdFxyXG5cclxuICAgIHdpbmRvdy5hbGVydCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWxlcnQnLCBzdHIpXHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmNvbmZpcm0gPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm0nLCBzdHIpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LnByb21wdCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgdmFyIGFuc3dlciA9IGRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKCdkYXRhLXByb21wdC1hbnN3ZXInKVxyXG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnZGF0YS1wcm9tcHQnLCBzdHIpXHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKCdkYXRhLXByb21wdC1hbnN3ZXInLCAnJylcclxuICAgICAgcmV0dXJuIGFuc3dlclxyXG4gICAgfVxyXG4gIGBcclxuICBjb25zdCBzICAgICA9IGRvYy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKGRvYywgJ3NjcmlwdCcpXHJcblxyXG4gIHMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpXHJcbiAgcy50ZXh0ID0gc2NyaXB0XHJcblxyXG4gIGRvYy5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocylcclxuICBzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocylcclxufVxyXG5cclxuY29uc3QgcmVzdG9yZUFsZXJ0Q29uZmlybVByb21wdCA9ICgpID0+IHtcclxuICBjb25zdCBzY3JpcHQgPSBgXHJcbiAgICBpZiAod2luZG93Lm9sZEFsZXJ0KSAgICB3aW5kb3cuYWxlcnQgPSB3aW5kb3cub2xkQWxlcnRcclxuICAgIGlmICh3aW5kb3cub2xkQ29uZmlybSkgIHdpbmRvdy5jb25maXJtID0gd2luZG93Lm9sZENvbmZpcm1cclxuICAgIGlmICh3aW5kb3cub2xkUHJvbXB0KSAgIHdpbmRvdy5wcm9tcHQgPSB3aW5kb3cub2xkUHJvbXB0XHJcbiAgYFxyXG4gIGNvbnN0IHMgICAgID0gZG9jdW1lbnQuY29uc3RydWN0b3IucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgJ3NjcmlwdCcpXHJcblxyXG4gIHMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpXHJcbiAgcy50ZXh0ID0gc2NyaXB0XHJcblxyXG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzKVxyXG4gIHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKVxyXG59XHJcblxyXG5jb25zdCBpbml0ID0gKCkgPT4ge1xyXG4gIHVuYmluZEV2ZW50c1RvUmVjb3JkKClcclxuICBiaW5kRXZlbnRzVG9SZWNvcmQoKVxyXG5cclxuICBiaW5kRXZlbnRzVG9JbnNwZWN0KClcclxuICBiaW5kT25NZXNzYWdlKClcclxuICBsb2FkQ29uZmlnKClcclxuXHJcbiAgLy8gTm90ZTogb25seSBiaW5kIGlwYyBldmVudHMgaWYgaXQncyB0aGUgdG9wIHdpbmRvd1xyXG4gIGlmICh3aW5kb3cudG9wID09PSB3aW5kb3cpIHtcclxuICAgIGJpbmRJUENMaXN0ZW5lcigpXHJcbiAgICBiaW5kSW52b2tlRXZlbnQoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBvblVybENoYW5nZShpbml0KVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgcnVuQ29tbWFuZCA9IChjb21tYW5kKSA9PiB7XHJcbiAgaWYgKCFjb21tYW5kLmNtZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdydW5Db21tYW5kOiBtdXN0IHByb3ZpZGUgY21kJylcclxuICB9XHJcblxyXG4gIC8vIGlmIGl0J3MgYW4gJ29wZW4nIGNvbW1hbmQsIGl0IG11c3QgYmUgZXhlY3V0ZWQgaW4gdGhlIHRvcCB3aW5kb3dcclxuICBpZiAoc3RhdGUucGxheWluZ0ZyYW1lID09PSB3aW5kb3cgfHwgY29tbWFuZC5jbWQgPT09ICdvcGVuJykge1xyXG4gICAgLy8gTm90ZTogYm90aCB0b3AgYW5kIGlubmVyIGZyYW1lcyBjb3VsZCBydW4gY29tbWFuZHMgaGVyZVxyXG4gICAgLy8gU28gbXVzdCB1c2Ugc3VwZXJDc0lwYyBpbnN0ZWFkIG9mIGNzSXBjXHJcbiAgICBjb25zdCByZXQgPSBydW4oY29tbWFuZCwgc3VwZXJDc0lwYywge1xyXG4gICAgICBoaWdobGlnaHREb20sXHJcbiAgICAgIGhhY2tBbGVydENvbmZpcm1Qcm9tcHQsXHJcbiAgICAgIHhwYXRoOiBpbnNwZWN0b3IueHBhdGhcclxuICAgIH0pXHJcblxyXG4gICAgLy8gTm90ZTogYHJ1bmAgcmV0dXJucyB0aGUgY29udGVudFdpbmRvdyBvZiB0aGUgc2VsZWN0ZWQgZnJhbWVcclxuICAgIGlmIChjb21tYW5kLmNtZCA9PT0gJ3NlbGVjdEZyYW1lJykge1xyXG4gICAgICByZXR1cm4gcmV0LnRoZW4oKHsgZnJhbWUgfSkgPT4ge1xyXG4gICAgICAgIC8vIGxldCBvdXRzaWRlIHdpbmRvdyBrbm93IHRoYXQgcGxheWluZ0ZyYW1lIGhhcyBiZWVuIGNoYW5nZWQsIGlmIGl0J3MgcGFyZW50IG9yIHRvcFxyXG4gICAgICAgIGlmIChmcmFtZSAhPT0gd2luZG93ICYmIChmcmFtZSA9PT0gd2luZG93LnRvcCB8fCBmcmFtZSA9PT0gd2luZG93LnBhcmVudCkpIHtcclxuICAgICAgICAgIHBvc3RNZXNzYWdlKHdpbmRvdy5wYXJlbnQsIHdpbmRvdywge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdSRVNFVF9QTEFZSU5HX0ZSQU1FJyxcclxuICAgICAgICAgICAgZGF0YTogZnJhbWUgPT09IHdpbmRvdy50b3AgPyAnVE9QJyA6ICdQQVJFTlQnXHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIHNldCBwbGF5aW5nRnJhbWUgdG8gb3duIHdpbmRvdywgZ2V0IHJlYWR5IGZvciBsYXRlciBjb21tYW5kcyBpZiBhbnlcclxuICAgICAgICAgIHN0YXRlLnBsYXlpbmdGcmFtZSA9IHdpbmRvd1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdGF0ZS5wbGF5aW5nRnJhbWUgPSBmcmFtZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICBwYWdlVXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcclxuICAgICAgICAgIGV4dHJhOiBjb21tYW5kLmV4dHJhXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHRyYSBpbmZvIHBhc3NlZCBvbiB0byBiYWNrZ3JvdW5kLCBpdCBjb250YWlucyB0aW1lb3V0IGluZm9cclxuICAgIGNvbnN0IHdyYXBSZXN1bHQgPSAocmV0KSA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uKHR5cGVvZiByZXQgPT09ICdvYmplY3QnID8gcmV0IDoge30pLFxyXG4gICAgICAgIHBhZ2VVcmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxyXG4gICAgICAgIGV4dHJhOiBjb21tYW5kLmV4dHJhLFxyXG4gICAgICAgIC8vIE5vdGU6IHVuZGVmaW5lZCB2YWx1ZSBpbiBhbiBPYmplY3Qgd2lsbCBiZSBlbGltaW5hdGVkIGR1cmluZyBtZXNzYWdlIHBhc3NpbmcsXHJcbiAgICAgICAgLy8gSGF2ZSB0byB0cmFuc2Zvcm0gaXQgaW50byBhbiBvYmplY3QgZmlyc3QsIGFuZCBjb252ZXJ0IGl0IGJhY2sgaW4gZnJvbnQgZW5kXHJcbiAgICAgICAgdmFyczogIXJldC52YXJzID8gdW5kZWZpbmVkIDogb2JqTWFwKHZhbCA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiB7IF9fdW5kZWZpbmVkX186IHRydWUgfVxyXG4gICAgICAgIH0sIHJldC52YXJzKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXQpLnRoZW4od3JhcFJlc3VsdClcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbG9nKCdwYXNzaW5nIGNvbW1hbmQgdG8gZnJhbWUuLi4nLCBzdGF0ZS5wbGF5aW5nRnJhbWUsICcuLi4nLCB3aW5kb3cubG9jYXRpb24uaHJlZilcclxuICAgIC8vIE5vdGU6IHBhc3Mgb24gdGhlIGNvbW1hbmQgaWYgb3VyIHdpbmRvdyBpcyBub3QgdGhlIGN1cnJlbnQgcGxheWluZyBvbmVcclxuICAgIHJldHVybiBwb3N0TWVzc2FnZShzdGF0ZS5wbGF5aW5nRnJhbWUsIHdpbmRvdywge1xyXG4gICAgICBhY3Rpb246ICdSVU5fQ09NTUFORCcsXHJcbiAgICAgIGRhdGE6IGNvbW1hbmRcclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG4vLyBOb3RlOiBmb3IgY2FzZXMgbGlrZSBodHRwczovL3d3dy53M3NjaG9vbHMuY29tL2pzcmVmL3RyeWl0LmFzcD9maWxlbmFtZT10cnlqc3JlZl9vbmJsdXJcclxuLy8gVGhlcmUgaXMgYSBraW5kIG9mIHN0cmFuZ2UgcmVmcmVzaCBpbiB0aGUgaWZyYW1lIG9uIHJpZ2h0IGhhbmQgc2lkZSxcclxuLy8gd2hpbGUgY29udGVudCBzY3JpcHQgaXMgbm90IHJlbG9hZGVkIGluIHRoZSBtZWFuIHRpbWUsIGl0IGNhdXNlcyB0aGF0IGlmcmFtZSBub3QgYWJsZSB0byBiZSByZWNvcmRlZFxyXG4vLyBTbyB3ZSBoYXZlIHRvIGxpc3RlbiB0byB1cmwgY2hhbmdlIGluIGlmcmFtZXMgZm9yIHRoaXMgY2FzZS5cclxuY29uc3Qgb25VcmxDaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGxldCBjYWxsYmFjayAgPSAoKSA9PiB7fVxyXG4gIGxldCBsYXN0VXJsICAgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxyXG4gIGNvbnN0IGNoZWNrICAgPSAoKSA9PiB7XHJcbiAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYgIT09IGxhc3RVcmwpIHtcclxuICAgICAgbG9nKCd1cmwgY2hhbmdlZCcsIGxhc3RVcmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxyXG4gICAgICBsYXN0VXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWZcclxuICAgICAgY2FsbGJhY2soKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHdpbmRvdy50b3AgPT09IHdpbmRvdykge1xyXG4gICAgcmV0dXJuICgpID0+IHt9XHJcbiAgfVxyXG5cclxuICBzZXRJbnRlcnZhbChjaGVjaywgMjAwMClcclxuXHJcbiAgcmV0dXJuIChmbikgPT4ge1xyXG4gICAgY2FsbGJhY2sgPSBmblxyXG4gIH1cclxufSkoKVxyXG5cclxuY29uc3QgbG9hZENvbmZpZyA9ICgpID0+IHtcclxuICBzdG9yYWdlLmdldCgnY29uZmlnJylcclxuICAudGhlbihjb25maWcgPT4ge1xyXG4gICAgc3RhdGUuY29uZmlnID0gY29uZmlnXHJcblxyXG4gICAgLy8gSU1QT1JUQU5UOiBicm9hZGNhc3Qgc3RhdHVzIGNoYW5nZSB0byBhbGwgZnJhbWVzIGluc2lkZVxyXG4gICAgYnJvYWRjYXN0VG9BbGxGcmFtZXMoJ1VQREFURV9DT05GSUcnLCBjb25maWcpXHJcbiAgfSlcclxufVxyXG5cclxuaW5pdCgpXHJcbiIsImltcG9ydCB7IHNldFN0eWxlLCBwaXhlbCwgYmluZERyYWcgfSBmcm9tICcuLi8uLi9jb21tb24vZG9tX3V0aWxzJ1xyXG5pbXBvcnQgeyBCb3gsIEJPWF9BTkNIT1JfUE9TIH0gZnJvbSAnLi4vLi4vY29tbW9uL2JveCdcclxuaW1wb3J0IEV4dCBmcm9tICcuLi8uLi9jb21tb24vd2ViX2V4dGVuc2lvbidcclxuXHJcbmV4cG9ydCBjb25zdCBjb21tb25TdHlsZSA9IHtcclxuICBib3hTaXppbmc6ICAnYm9yZGVyLWJveCcsXHJcbiAgZm9udEZhbWlseTogJ0FyaWFsJ1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlRWwgPSAoeyB0YWcgPSAnZGl2JywgYXR0cnMgPSB7fSwgc3R5bGUgPSB7fSwgdGV4dCB9KSA9PiB7XHJcbiAgY29uc3QgJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpXHJcblxyXG4gIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAkZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSlcclxuICB9KVxyXG5cclxuICBpZiAodGV4dCAmJiB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgJGVsLmlubmVyVGV4dCA9IHRleHRcclxuICB9XHJcblxyXG4gIHNldFN0eWxlKCRlbCwgc3R5bGUpXHJcbiAgcmV0dXJuICRlbFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUmVjdCA9IChvcHRzKSA9PiB7XHJcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XHJcbiAgICAuLi5jb21tb25TdHlsZSxcclxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgekluZGV4OiAgIDEwMDAwMCxcclxuICAgIHRvcDogICAgICBwaXhlbChvcHRzLnRvcCksXHJcbiAgICBsZWZ0OiAgICAgcGl4ZWwob3B0cy5sZWZ0KSxcclxuICAgIHdpZHRoOiAgICBwaXhlbChvcHRzLndpZHRoKSxcclxuICAgIGhlaWdodDogICBwaXhlbChvcHRzLmhlaWdodCksXHJcbiAgICAuLi4ob3B0cy5jb250YWluZXJTdHlsZSB8fCB7fSlcclxuICB9XHJcbiAgY29uc3QgcmVjdFN0eWxlID0ge1xyXG4gICAgLi4uY29tbW9uU3R5bGUsXHJcbiAgICB3aWR0aDogICAgJzEwMCUnLFxyXG4gICAgaGVpZ2h0OiAgICcxMDAlJyxcclxuICAgIGJvcmRlcjogICBgJHtvcHRzLnJlY3RCb3JkZXJXaWR0aH1weCBzb2xpZCByZ2IoMjM5LCA5MywgMTQzKWAsXHJcbiAgICBjdXJzb3I6ICAgJ21vdmUnLFxyXG4gICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcclxuICAgIC4uLihvcHRzLnJlY3RTdHlsZSB8fCB7fSlcclxuICB9XHJcblxyXG4gIGNvbnN0ICRjb250YWluZXIgPSBjcmVhdGVFbCh7IHN0eWxlOiBjb250YWluZXJTdHlsZSB9KVxyXG4gIGNvbnN0ICRyZWN0YW5nbGUgPSBjcmVhdGVFbCh7IHN0eWxlOiByZWN0U3R5bGUgfSlcclxuXHJcbiAgJGNvbnRhaW5lci5hcHBlbmRDaGlsZCgkcmVjdGFuZ2xlKVxyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoJGNvbnRhaW5lcilcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgICRjb250YWluZXIsXHJcbiAgICAkcmVjdGFuZ2xlLFxyXG4gICAgZGVzdHJveTogKCkgPT4ge1xyXG4gICAgICAkY29udGFpbmVyLnJlbW92ZSgpXHJcbiAgICB9LFxyXG4gICAgaGlkZTogKCkgPT4ge1xyXG4gICAgICBzZXRTdHlsZSgkY29udGFpbmVyLCB7IGRpc3BsYXk6ICdub25lJyB9KVxyXG4gICAgfSxcclxuICAgIHNob3c6ICgpID0+IHtcclxuICAgICAgc2V0U3R5bGUoJGNvbnRhaW5lciwgeyBkaXNwbGF5OiAnYmxvY2snIH0pXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBjcmVhdGVPdmVybGF5ID0gKCkgPT4ge1xyXG4gIGNvbnN0ICRvdmVybGF5ID0gY3JlYXRlRWwoe1xyXG4gICAgc3R5bGU6IHtcclxuICAgICAgcG9zaXRpb246ICAgJ2ZpeGVkJyxcclxuICAgICAgekluZGV4OiAgICAgOTAwMCxcclxuICAgICAgdG9wOiAgICAgICAgMCxcclxuICAgICAgYm90dG9tOiAgICAgMCxcclxuICAgICAgbGVmdDogICAgICAgMCxcclxuICAgICAgcmlnaHQ6ICAgICAgMCxcclxuICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgY3Vyc29yOiAgICAgJ2Nyb3NzaGFpcidcclxuICAgIH1cclxuICB9KVxyXG5cclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCRvdmVybGF5KVxyXG4gIHJldHVybiAoKSA9PiAkb3ZlcmxheS5yZW1vdmUoKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc2VsZWN0QXJlYSA9ICh7IGRvbmUsIHByb21pc2UgPSBmYWxzZSB9KSA9PiB7XHJcbiAgY29uc3QgZ28gPSAoZG9uZSkgPT4ge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICAgIGJveDogbnVsbCxcclxuICAgICAgYWN0aXZhdGVkOiBmYWxzZSxcclxuICAgICAgc3RhcnRQb3M6IG51bGwsXHJcbiAgICAgIHJlY3Q6IG51bGxcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc2V0Qm9keVN0eWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgY29uc3QgdXNlclNlbGVjdEtleSA9IEV4dC5pc0ZpcmVmb3goKSA/ICctbW96LXVzZXItc2VsZWN0JyA6ICd1c2VyLXNlbGVjdCdcclxuICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KVxyXG4gICAgICBjb25zdCBvbGRDdXJzb3IgPSBzdHlsZS5jdXJzb3JcclxuICAgICAgY29uc3Qgb2xkVXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RLZXldXHJcblxyXG4gICAgICBzZXRTdHlsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAgICAgICAgY3Vyc29yOiAnY3Jvc3NoYWlyJyxcclxuICAgICAgICBbdXNlclNlbGVjdEtleV06ICdub25lJ1xyXG4gICAgICB9KVxyXG4gICAgICByZXR1cm4gKCkgPT4gc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgeyBjdXJzb3I6IG9sZEN1cnNvciwgW3VzZXJTZWxlY3RLZXldOiBvbGRVc2VyU2VsZWN0IH0pXHJcbiAgICB9KSgpXHJcblxyXG4gICAgY29uc3QgcmVtb3ZlT3ZlcmxheSA9IGNyZWF0ZU92ZXJsYXkoKVxyXG4gICAgY29uc3QgdW5iaW5kRHJhZyA9IGJpbmREcmFnKHtcclxuICAgICAgJGVsOiBkb2N1bWVudCxcclxuICAgICAgb25EcmFnU3RhcnQ6IChlKSA9PiB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcblxyXG4gICAgICAgIHN0YXRlLmFjdGl2YXRlZCA9IHRydWVcclxuICAgICAgICBzdGF0ZS5zdGFydFBvcyAgPSB7XHJcbiAgICAgICAgICB4OiBlLnBhZ2VYLFxyXG4gICAgICAgICAgeTogZS5wYWdlWVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgb25EcmFnRW5kOiAoZSkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgICAgICBzdGF0ZS5hY3RpdmF0ZWQgPSBmYWxzZVxyXG5cclxuICAgICAgICBpZiAoc3RhdGUuYm94KSB7XHJcbiAgICAgICAgICBzdGF0ZS5ib3gubW92ZUFuY2hvckVuZCgpXHJcblxyXG4gICAgICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gcmVjdE9iai4kY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgICAgICBBUEkuaGlkZSgpXHJcblxyXG4gICAgICAgICAgLy8gTm90ZTogQVBJLmhpZGUoKSB0YWtlcyBzb21lIHRpbWUgdG8gaGF2ZSBlZmZlY3RcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBkb25lKHN0YXRlLnJlY3QsIGJvdW5kaW5nUmVjdClcclxuICAgICAgICAgICAgQVBJLmRlc3Ryb3koKVxyXG4gICAgICAgICAgfSwgMTAwKVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgb25EcmFnOiAoZSwgeyBkeCwgZHkgfSkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2YXRlZCkgcmV0dXJuXHJcblxyXG4gICAgICAgIGlmICghc3RhdGUuYm94KSB7XHJcbiAgICAgICAgICBjb25zdCByZWN0ID0ge1xyXG4gICAgICAgICAgICB4OiAgICAgIHN0YXRlLnN0YXJ0UG9zLngsXHJcbiAgICAgICAgICAgIHk6ICAgICAgc3RhdGUuc3RhcnRQb3MueSxcclxuICAgICAgICAgICAgd2lkdGg6ICBkeCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBkeVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3RhdGUucmVjdCAgPSByZWN0XHJcbiAgICAgICAgICBzdGF0ZS5ib3ggICA9IG5ldyBCb3goe1xyXG4gICAgICAgICAgICAuLi5yZWN0LFxyXG4gICAgICAgICAgICBvblN0YXRlQ2hhbmdlOiAoeyByZWN0IH0pID0+IHtcclxuICAgICAgICAgICAgICBzdGF0ZS5yZWN0ID0gcmVjdFxyXG4gICAgICAgICAgICAgIEFQSS5zaG93KClcclxuICAgICAgICAgICAgICBBUEkudXBkYXRlUG9zKHJlY3QpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgc3RhdGUuYm94Lm1vdmVBbmNob3JTdGFydCh7XHJcbiAgICAgICAgICAgIGFuY2hvclBvczogQk9YX0FOQ0hPUl9QT1MuQk9UVE9NX1JJR0hUXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuYm94Lm1vdmVBbmNob3Ioe1xyXG4gICAgICAgICAgeDogZS5wYWdlWCxcclxuICAgICAgICAgIHk6IGUucGFnZVlcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IHJlY3RPYmogPSBjcmVhdGVSZWN0KHtcclxuICAgICAgdG9wOiAgICAgICAgICAtOTk5LFxyXG4gICAgICBsZWZ0OiAgICAgICAgIC05OTksXHJcbiAgICAgIHdpZHRoOiAgICAgICAgMCxcclxuICAgICAgaGVpZ2h0OiAgICAgICAwLFxyXG4gICAgICByZWN0U3R5bGU6IHtcclxuICAgICAgICBib3JkZXI6ICAgICAnMXB4IHNvbGlkICNmZjAwZmYnLFxyXG4gICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDI1NSwgMC4xKSdcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIGNvbnN0IEFQSSA9IHtcclxuICAgICAgdXBkYXRlUG9zOiAocmVjdCkgPT4ge1xyXG4gICAgICAgIHNldFN0eWxlKHJlY3RPYmouJGNvbnRhaW5lciwge1xyXG4gICAgICAgICAgdG9wOiAgICBwaXhlbChyZWN0LnkpLFxyXG4gICAgICAgICAgbGVmdDogICBwaXhlbChyZWN0LngpLFxyXG4gICAgICAgICAgd2lkdGg6ICBwaXhlbChyZWN0LndpZHRoKSxcclxuICAgICAgICAgIGhlaWdodDogcGl4ZWwocmVjdC5oZWlnaHQpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSxcclxuICAgICAgZGVzdHJveTogKCkgPT4ge1xyXG4gICAgICAgIHJlc2V0Qm9keVN0eWxlKClcclxuICAgICAgICB1bmJpbmREcmFnKClcclxuICAgICAgICByZW1vdmVPdmVybGF5KClcclxuICAgICAgICByZWN0T2JqLmRlc3Ryb3koKVxyXG5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgdHJ1ZSlcclxuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpXHJcbiAgICAgICAgfSwgMClcclxuICAgICAgfSxcclxuICAgICAgaGlkZTogKCkgPT4ge1xyXG4gICAgICAgIHJlY3RPYmouaGlkZSgpXHJcbiAgICAgIH0sXHJcbiAgICAgIHNob3c6ICgpID0+IHtcclxuICAgICAgICByZWN0T2JqLnNob3coKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25DbGljayA9IChlKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCd0cmlnZ2VyIHNlbGVjdF9hcmVhIG9uY2xpY2snKVxyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICBBUEkuZGVzdHJveSgpXHJcbiAgICB9XHJcbiAgICBjb25zdCBvbktleURvd24gPSAoZSkgPT4gZS5rZXlDb2RlID09PSAyNyAmJiBBUEkuZGVzdHJveSgpXHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCB0cnVlKVxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSlcclxuXHJcbiAgICBBUEkuaGlkZSgpXHJcbiAgICByZXR1cm4gQVBJXHJcbiAgfVxyXG5cclxuICBpZiAoIXByb21pc2UpIHJldHVybiBnbyhkb25lKVxyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3Qgd3JhcHBlZERvbmUgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICByZXNvbHZlKGRvbmUoLi4uYXJncykpXHJcbiAgICB9XHJcblxyXG4gICAgZ28od3JhcHBlZERvbmUpXHJcbiAgfSlcclxufVxyXG4iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9